<?xml version="1.0" encoding="utf-8"?>


<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
    <title type="text">yuyuyuyi1&#39;s Blog</title>
    <subtitle type="html">MemE 是一个强大且可高度定制的 GoHugo 博客主题，专为个人博客设计。</subtitle>
    <updated>2025-12-23T14:05:24&#43;00:00</updated>
    <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/</id>
    <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/" />
    <link rel="self" type="application/atom&#43;xml" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/atom.xml" />
    <author>
            <name>wangkunlin</name>
            <uri>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/</uri>
            
                <email>wangkunlin2001@163.com</email>
            </author>
    <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    <generator uri="https://gohugo.io/" version="0.153.1">Hugo</generator>
        <entry>
            <title type="text">
力扣hot100—回溯8题</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/10/19/%E5%8A%9B%E6%89%A3hot100-%E5%9B%9E%E6%BA%AF8%E9%A2%98/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/10/19/%E5%8A%9B%E6%89%A3hot100-%E5%9B%9E%E6%BA%AF8%E9%A2%98/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-10-19T12:24:46&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;回溯类型的题目，大部分的模板都是三步骤：&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    判断终止条件，存储枚举结果
  &lt;/li&gt;
  &lt;li&gt;
    以某种方式遍历数组/集合，可以用visited数组辅助判断是否遍历过
  &lt;/li&gt;
  &lt;li&gt;
    进入下一层递归
  &lt;/li&gt;
  &lt;li&gt;
    恢复现场
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;全排列&#34;&gt;全排列&lt;/h2&gt;
&lt;p&gt;有点不好理解，主要是dfs思想，固定第u位，然后&lt;code&gt;for(int i = 0; i&amp;lt;length; i++)；dfs(u+1)&lt;/code&gt;枚举&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/10/19/%E5%8A%9B%E6%89%A3hot100-%E5%9B%9E%E6%BA%AF8%E9%A2%98/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/10/19/%E5%8A%9B%E6%89%A3hot100-%E5%9B%9E%E6%BA%AF8%E9%A2%98/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;回溯类型的题目，大部分的模板都是三步骤：&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    判断终止条件，存储枚举结果
  &lt;/li&gt;
  &lt;li&gt;
    以某种方式遍历数组/集合，可以用visited数组辅助判断是否遍历过
  &lt;/li&gt;
  &lt;li&gt;
    进入下一层递归
  &lt;/li&gt;
  &lt;li&gt;
    恢复现场
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;全排列&#34;&gt;全排列&lt;/h2&gt;
&lt;p&gt;有点不好理解，主要是dfs思想，固定第u位，然后&lt;code&gt;for(int i = 0; i&amp;lt;length; i++)；dfs(u+1)&lt;/code&gt;枚举&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    int length;
    List&amp;lt;Integer&gt; path;  // 当前路径
    List&amp;lt;List&amp;lt;Integer&gt;&gt; res;  // 所有结果
    int[] used;  // 标记数组
    int[] nums;  // 原始数组

    public List&amp;lt;List&amp;lt;Integer&gt;&gt; permute(int[] nums) {
        this.nums = nums;
        this.length = nums.length;
        this.used = new int[length];
        this.res = new ArrayList&amp;lt;&gt;();
        this.path = new ArrayList&amp;lt;&gt;();
        dfs(0);
        return res;
    }

    public void dfs(int u) {
        if (u == length) {  // 终止条件：已选完所有数字
            res.add(new ArrayList&amp;lt;&gt;(path));  // 添加当前排列到结果集
            return;
        }
        
        for (int i = 0; i &amp;lt; length; i++) {
            if (used[i] == 0) {  // 如果i号数字未被使用
                used[i] = 1;  // 标记为已使用
                path.add(nums[i]);  // 添加到当前路径
                dfs(u + 1);  // 递归下一层
                path.remove(path.size() - 1);  // 回溯：移除最后添加的数字
                used[i] = 0;  // 回溯：标记为未使用
            }
        }
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;子集&#34;&gt;子集&lt;/h2&gt;
&lt;p&gt;二进制枚举，有或无的情况，用二进制枚举比较直观。用0表示不选用这一位的数，用非0表示选用。注意&lt;code&gt;(i &amp;amp; ( 1 &amp;lt;&amp;lt; j)) != 0&lt;/code&gt;条件应该是非0，而不是等于1，因为位运算的结果可能非1，例如&lt;code&gt;i=010(2)&lt;/code&gt;，&lt;code&gt;1&amp;lt;&amp;lt;j=010&lt;/code&gt;，相与运算的结果非1。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public List&amp;lt;List&amp;lt;Integer&gt;&gt; subsets(int[] nums) {
        List&amp;lt;List&amp;lt;Integer&gt;&gt; res = new ArrayList&amp;lt;&gt;();
        int n = nums.length;
        int cnt = (1 &amp;lt;&amp;lt; n);
        for(int i = 0; i &amp;lt; cnt; i++){
            List&amp;lt;Integer&gt; tmp = new ArrayList&amp;lt;&gt;();
            for(int j = 0; j &amp;lt; n; j++){
                if((i &amp; ( 1 &amp;lt;&amp;lt; j)) != 0){
                    // 说明当前枚举数字的第j位为1 加入
                    tmp.add(nums[j]);
                }
            }
            res.add(tmp);
        }
        return res;
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;电话号码的字母组合&#34;&gt;电话号码的字母组合&lt;/h2&gt;
&lt;p&gt;枚举，思路：&lt;code&gt;dfs(u)&lt;/code&gt;，u为输入数字串的位数，对数字串的每一位，用map取出可能的字符集，for循环这些字符集，在for中继续&lt;code&gt;dfs(u+1)&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    private List&amp;lt;String&gt; res = new ArrayList&amp;lt;&gt;();
    private StringBuilder tmp = new StringBuilder();
    private Map&amp;lt;Character, String&gt; map = new HashMap&amp;lt;&gt;();
    private String digits;
    private int length;

    public List&amp;lt;String&gt; letterCombinations(String digits) {
        if (digits == null || digits.length() == 0) {
            return res;
        }

        this.digits = digits;
        this.length = digits.length();

        map.put(&#39;2&#39;, &#34;abc&#34;);
        map.put(&#39;3&#39;, &#34;def&#34;);
        map.put(&#39;4&#39;, &#34;ghi&#34;);
        map.put(&#39;5&#39;, &#34;jkl&#34;);
        map.put(&#39;6&#39;, &#34;mno&#34;);
        map.put(&#39;7&#39;, &#34;pqrs&#34;);
        map.put(&#39;8&#39;, &#34;tuv&#34;);
        map.put(&#39;9&#39;, &#34;wxyz&#34;);

        dfs(0);
        return res;
    }

    private void dfs(int u) {
        if (u == length) {
            res.add(tmp.toString());
            return;
        }
        char digit = digits.charAt(u);
        String letters = map.get(digit);
        for (int i = 0; i &amp;lt; letters.length(); i++) {
            tmp.append(letters.charAt(i));
            dfs(u + 1);
            tmp.deleteCharAt(tmp.length() - 1); // 回溯
        }
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;组合总数&#34;&gt;组合总数&lt;/h2&gt;
&lt;p&gt;定义递归函数 &lt;code&gt;dfs(target,combine,idx)&lt;/code&gt;表示当前在 candidates 数组的第 idx 位，还剩 target 要组合，已经组合的列表为 combine。递归的终止条件为&lt;code&gt;target≤0&lt;/code&gt;或者 candidates 数组被全部用完。那么在当前的函数中，每次我们可以选择：&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    跳过不用第 idx 个数，即执行 dfs(target,combine,idx+1)。
  &lt;/li&gt;
  &lt;li&gt;
    也可以选择使用第 idx 个数，即执行 dfs(target−candidates[idx],combine,idx)，注意到每个数字可以被无限制重复选取，因此搜索的下标仍为 idx。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    List&amp;lt;List&amp;lt;Integer&gt;&gt; res = new ArrayList&amp;lt;&gt;();
    List&amp;lt;Integer&gt; combine = new ArrayList&amp;lt;&gt;();
    
    public List&amp;lt;List&amp;lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {
        dfs(candidates, target, 0);
        return res;
    }

    public void dfs(int[] candidates, int target, int index){
        if(index == candidates.length){
            return;
        }
        if(target == 0){
            res.add(new ArrayList&amp;lt;Integer&gt;(combine));
            return;
        }
        // 情况1 直接跳过
        dfs(candidates, target, index + 1);

        // 情况2 考虑
        if(target -candidates[index] &gt;= 0){
            combine.add(candidates[index]);
            // 当前index可以重复 不需要index + 1
            dfs(candidates, target - candidates[index], index);
            combine.remove(combine.size() - 1);
        }
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;括号匹配&#34;&gt;括号匹配&lt;/h2&gt;
&lt;p&gt;找到规律，即对于输入N，潜在的含义是，左右括号的数目不超过n，因此可以递归&lt;code&gt;dfs(str, left, right)&lt;/code&gt;，递归构造括号字符串，&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    当&lt;code&gt;left == right&lt;/code&gt;的时候，说明下一个括号只能是左括号
  &lt;/li&gt;
  &lt;li&gt;
    否则下一个括号可以左也可以右
  &lt;/li&gt;
  &lt;li&gt;
    递归终止条件为&lt;code&gt;left == 0 &amp;&amp; right == 0&lt;/code&gt;括号都匹配完了
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    List&amp;lt;String&gt; res = new ArrayList&amp;lt;&gt;();

    public List&amp;lt;String&gt; generateParenthesis(int n) {
        if(n &amp;lt;= 0) return res;
        dfs(&#34;&#34;, n, n);
        return res;
    }
    // 参数分别为：当前构造的字符串, 能使用的左括号数目, 能使用的右括号数
    public void dfs(String str, int left, int right){
        if(left == 0 &amp;&amp; right == 0){
            res.add(str);
            return;
        }
        if(left == right){
            // 如果能使用的左右括号数相等 下一个只能用左括号
            dfs(str + &#34;(&#34;, left - 1, right);
        }else if(left &amp;lt; right){
            // 可以使用左括号 也可也使用右括号
            if(left &gt; 0) dfs(str + &#34;(&#34;, left - 1, right);
            if(right &gt; 0) dfs(str + &#34;)&#34;, left, right - 1);
        }
        return;
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;单词搜索&#34;&gt;单词搜索&lt;/h2&gt;
&lt;p&gt;二维的递归，用&lt;code&gt;visited[i][j]&lt;/code&gt;维护是否遍历到的情况。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    boolean[][] visited;
    int[][] dir = {{0,1}, {0,-1}, {1,0}, {-1,0}};
    
    public boolean exist(char[][] board, String word) {
        int row = board.length;
        int col = board[0].length;
        visited = new boolean[row][col];
        for(int i = 0; i &amp;lt; row; i++){
            for(int j = 0; j &amp;lt; col; j++){
                if(dfs(board, i, j, word, 0)){
                    return true;
                }
            }
        }
        return false;
    }
    
    public boolean dfs(char[][] board, int i, int j, String word, int index){
        if(index == word.length()) return true;
        // 在递归开始就判断条件 如果board[i][j] != word.charAt(index) 则终止递归 返回false
        if(i &amp;lt; 0 || j &amp;lt; 0 || i &gt;= board.length || j &gt;= board[0].length || 
           visited[i][j] || board[i][j] != word.charAt(index)){
            return false;
        }
    
        visited[i][j] = true;
        for(int[] d : dir){
            int dx = i + d[0];
            int dy = j + d[1];
            if(dfs(board, dx, dy, word, index + 1)){
                return true;
            }
        }
        visited[i][j] = false;
        
        return false;
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;分割回文串&#34;&gt;分割回文串&lt;/h2&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    我们从字符串的起始位置开始，尝试所有可能的分割点
  &lt;/li&gt;
  &lt;li&gt;
    对于每个可能的分割点，检查当前子串是否是回文
  &lt;/li&gt;
  &lt;li&gt;
    如果是回文，则继续递归处理剩余的字符串
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    List&amp;lt;List&amp;lt;String&gt;&gt; result = new ArrayList&amp;lt;&gt;();
    List&amp;lt;String&gt; current = new ArrayList&amp;lt;&gt;();
    public List&amp;lt;List&amp;lt;String&gt;&gt; partition(String s) {
        backtrack(s, 0);
        return result;
    }
    
    private void backtrack(String s, int index) {
        // 到头了 无需再分 添加current进入答案中
        if (index == s.length()) {
            result.add(new ArrayList&amp;lt;&gt;(current));
            return;
        }
        
        for (int end = index + 1; end &amp;lt;= s.length(); end++) {
            // 分割子串
            String substring = s.substring(index, end);
            if (isPalindrome(substring)) {
                // 如果是回文串 就添加进current中 递归执行从end开始的分割回文串
                current.add(substring);
                backtrack(s, end);
                current.remove(current.size() - 1); // 回溯
            }
        }
    }
    
    private boolean isPalindrome(String s) {
        int left = 0;
        int right = s.length() - 1;
        while (left &amp;lt; right) {
            if (s.charAt(left++) != s.charAt(right--)) {
                return false;
            }
        }
        return true;
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;n皇后&#34;&gt;N皇后&lt;/h2&gt;
&lt;p&gt;DFS枚举行数，每行必定有一个皇后。每层枚举的时候，判断斜线、反斜线、当前列有无皇后占用。 &lt;strong&gt;关键是如何维护visited数组，判断某个点的两个斜向有无皇后？&lt;/strong&gt; 贴一个acwing的解答：&lt;a href=&#34;https://www.acwing.com/solution/content/2820/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AcWing 843. n-皇后问题（按行枚举或按每个元素枚举） – AcWing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于某个点的斜线，其实可以用它的一元方程系数来唯一确定&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    比如，对于正斜线，&lt;code&gt;y = x + b&lt;/code&gt;，b可以用来定位整个棋盘的正斜线，因此，可以用&lt;code&gt;b = y - x&lt;/code&gt;，来确定斜线visited数组，要注意&lt;code&gt;y - x&lt;/code&gt;会小于0，因此要在前面加个系数保证它大于0即可。
  &lt;/li&gt;
  &lt;li&gt;
    同样，对于反斜线，可以用&lt;code&gt;y = -x + b&lt;/code&gt;，即&lt;code&gt;b = x + y&lt;/code&gt;来定位。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;wp-block-image&#34;&gt;
  &lt;figure class=&#34;aligncenter size-large&#34;&gt;
  &lt;div class=&#39;fancybox-wrapper lazyload-container-unload&#39; data-fancybox=&#39;post-images&#39; href=&#39;https://www.yuyuyuyi1.xyz/wp-content/uploads/2025/10/image-1-1024x497.png&#39;&gt;
    &lt;img class=&#34;lazyload lazyload-style-1&#34; src=&#34;data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+&#34;  loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1024&#34; height=&#34;497&#34; data-original=&#34;https://www.yuyuyuyi1.xyz/wp-content/uploads/2025/10/image-1-1024x497.png&#34; src=&#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC&#34; alt=&#34;&#34; class=&#34;wp-image-663&#34;  sizes=&#34;auto, (max-width: 1024px) 100vw, 1024px&#34; /&gt;
  &lt;/div&gt;&lt;figcaption class=&#34;wp-element-caption&#34;&gt;图片来源于Acwing题解&lt;/figcaption&gt;&lt;/figure&gt;
&lt;/div&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    List&amp;lt;String&gt; cur = new ArrayList&amp;lt;&gt;();
    List&amp;lt;List&amp;lt;String&gt;&gt; res = new ArrayList&amp;lt;&gt;();
    // 当前列、正向、反向visited
    boolean[] zx;
    boolean[] fx;
    boolean[] col;
    int N;
    public List&amp;lt;List&amp;lt;String&gt;&gt; solveNQueens(int n) {
        N = n;
        zx = new boolean[2 * N];
        fx = new boolean[2 * N];
        col = new boolean[N];

        dfs(0);
        return res;
    }

    public void dfs(int u){
        if(u == N){
            res.add(new ArrayList&amp;lt;&gt;(cur));
        }
        int x = u;
        for(int y = 0; y &amp;lt; N; y++){
            // 正斜线系数b=y-x 需要加上N防止小于0
            if(col[y] == false &amp;&amp; zx[y - x + N] == false &amp;&amp; fx[y + x] == false){
                // 说明当前x y 是一个当前层的解
                col[y] = true;
                zx[y - x + N] = true;
                fx[y + x] = true;
                // 构造一个解
                String tmp = handle(y);
                cur.add(tmp);
                dfs(u + 1);
                // 出递归, 恢复现场
                col[y] = false;
                zx[y - x + N] = false;
                fx[y + x] = false;
                cur.remove(cur.size() - 1);
            }
        }
    }

    public String handle(int y){
        // 第y位上有Q 其他位置上都是.
        String res = &#34;&#34;;
        for(int i = 0; i &amp;lt; N; i++){
            if(i == y) res += &#34;Q&#34;;
            else res += &#34;.&#34;;
        }
        return res;
    }
}&lt;/pre&gt;

                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/10/19/%E5%8A%9B%E6%89%A3hot100-%E5%9B%9E%E6%BA%AF8%E9%A2%98/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/10/19/%E5%8A%9B%E6%89%A3hot100-%E5%9B%9E%E6%BA%AF8%E9%A2%98/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%8A%9B%E6%89%A3hot100/" term="力扣Hot100" label="力扣Hot100" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/dfs/" term="DFS" label="DFS" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E9%80%92%E5%BD%92/" term="递归" label="递归" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
力扣hot100—图论4题</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/10/17/%E5%8A%9B%E6%89%A3hot100-%E5%9B%BE%E8%AE%BA4%E9%A2%98/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/10/17/%E5%8A%9B%E6%89%A3hot100-%E5%9B%BE%E8%AE%BA4%E9%A2%98/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-10-17T07:09:41&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;网格DFS通用板子，类似二叉树的DFS：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;void dfs(int[][] grid, int r, int c) {
    // 判断 base case
    if (!inArea(grid, r, c)) {
        return;
    }
    
    grid[r][c] = 2; // 将格子标记为「已遍历过」
    
    // 访问上、下、左、右四个相邻结点
    dfs(grid, r - 1, c);
    dfs(grid, r + 1, c);
    dfs(grid, r, c - 1);
    dfs(grid, r, c + 1);
}

// 判断坐标 (r, c) 是否在网格中
boolean inArea(int[][] grid, int r, int c) {
    return 0 &amp;lt;= r &amp;&amp; r &amp;lt; grid.length 
        	&amp;&amp; 0 &amp;lt;= c &amp;&amp; c &amp;lt; grid[0].length;
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;岛屿数量&#34;&gt;岛屿数量&lt;/h2&gt;
&lt;p&gt;循环访问每个点（i，j），递归DFS用以将某片岛屿全部表记为访问过。&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/10/17/%E5%8A%9B%E6%89%A3hot100-%E5%9B%BE%E8%AE%BA4%E9%A2%98/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/10/17/%E5%8A%9B%E6%89%A3hot100-%E5%9B%BE%E8%AE%BA4%E9%A2%98/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;网格DFS通用板子，类似二叉树的DFS：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;void dfs(int[][] grid, int r, int c) {
    // 判断 base case
    if (!inArea(grid, r, c)) {
        return;
    }
    
    grid[r][c] = 2; // 将格子标记为「已遍历过」
    
    // 访问上、下、左、右四个相邻结点
    dfs(grid, r - 1, c);
    dfs(grid, r + 1, c);
    dfs(grid, r, c - 1);
    dfs(grid, r, c + 1);
}

// 判断坐标 (r, c) 是否在网格中
boolean inArea(int[][] grid, int r, int c) {
    return 0 &amp;lt;= r &amp;&amp; r &amp;lt; grid.length 
        	&amp;&amp; 0 &amp;lt;= c &amp;&amp; c &amp;lt; grid[0].length;
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;岛屿数量&#34;&gt;岛屿数量&lt;/h2&gt;
&lt;p&gt;循环访问每个点（i，j），递归DFS用以将某片岛屿全部表记为访问过。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public int numIslands(char[][] grid) {
        int count = 0;
        for(int i = 0; i &amp;lt; grid.length; i++){
            for(int j = 0; j &amp;lt; grid[0].length; j++){
                if(grid[i][j] == &#39;1&#39;){
                    dfs(grid, i, j);
                    count++;
                }
            }
        }
        return count;
    }
    //dfs的目标是深度搜索删除这个岛屿
    public void dfs(char[][] g, int i, int j){
        if(i &amp;lt; 0 || j &amp;lt; 0 || i &gt;= g.length || j &gt;= g[0].length || g[i][j] == &#39;0&#39;) return;
        g[i][j] = &#39;0&#39;;
        dfs(g, i + 1, j);
        dfs(g, i, j + 1);
        dfs(g, i - 1, j);
        dfs(g, i, j - 1);
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;腐烂的橘子&#34;&gt;腐烂的橘子&lt;/h2&gt;
&lt;p&gt;返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。翻译一下，实际上就是求&lt;strong&gt;腐烂橘子到所有新鲜橘子的最短路径&lt;/strong&gt;。 用&lt;strong&gt;层序的BFS&lt;/strong&gt;，每一层向外迭代，round++，即时间+1。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    int cnt = 0; // 正常的橘子数
    Queue&amp;lt;int[]&gt; q = new LinkedList&amp;lt;&gt;();
    int m;
    int n;
    public int orangesRotting(int[][] grid) {
        m = grid.length;
        n = grid[0].length;
        for(int i = 0; i &amp;lt; m; i++){
            for(int j = 0; j &amp;lt; n; j++){
                if(grid[i][j] == 1) cnt++;
                if(grid[i][j] == 2){
                    q.add(new int[]{i, j});
                }
            }
        }
        int time = 0;
        // 当队列为空时终止循环
        while(cnt &gt; 0 &amp;&amp; !q.isEmpty()){
            time++;
            int n = q.size();
            for(int i = 0; i &amp;lt; n; i++){
                int[] orange = q.poll();
                int x = orange[0];
                int y = orange[1];
                handle(grid, x, y);
            }
        }
        if(cnt &gt; 0) return -1;
        else return time;

    }
    public void handle(int[][] grid, int x, int y){
        if(x &gt;= 1 &amp;&amp; grid[x-1][y] == 1){
            grid[x-1][y] = 2;
            cnt--;
            q.add(new int[]{x-1, y});
        }
        if(x + 1 &amp;lt; m &amp;&amp; grid[x+1][y] == 1){
            grid[x+1][y] = 2;
            cnt--;
            q.add(new int[]{x+1, y});
        }
        if(y &gt;= 1 &amp;&amp; grid[x][y-1] == 1){
            grid[x][y-1] = 2;
            cnt--;
            q.add(new int[]{x, y-1});
        }
        if( y + 1 &amp;lt; n &amp;&amp; grid[x][y+1] == 1){
            grid[x][y+1] = 2;
            cnt--;
            q.add(new int[]{x, y+1});
        }
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;课程表&#34;&gt;课程表&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;拓扑排序&lt;/strong&gt;，关键是维护一个入度数组（&lt;strong&gt;入度表示课程的依赖情况，如果某个课入度为0，说明前置课程修完了，或者没有前置课程需要修&lt;/strong&gt;）和一个哈希表（key为课程序号，value为该课程的后置课程集合），用BFS的思路迭代。维护一个队列，队列中的元素为入度为0的课程。每次迭代取出一个入度为0的课（表示这门课修完了），并维护其后置课程（后置课程的入度-1），记录修完课程的数量，最后对比数量得出返回值。&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    初始化的队列，入度数组、哈希表
  &lt;/li&gt;
  &lt;li&gt;
    将所有课加入哈希表，维护这些课的后置课
  &lt;/li&gt;
  &lt;li&gt;
    将入度为0的课加入队列
  &lt;/li&gt;
  &lt;li&gt;
    开始BFS迭代，取出入度为0的课，并维护它们的后置课入度
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        // 入度数组，用于记录每门课程的入度
        int[] inDegree = new int[numCourses];
        // 哈希表 key为当前课程序号 value为当前课程的后续课程数组
        Map&amp;lt;Integer, List&amp;lt;Integer&gt;&gt; m = new HashMap&amp;lt;&gt;();
        for(int i = 0; i &amp;lt; numCourses; i++){
            m.put(i, new ArrayList&amp;lt;Integer&gt;());
        }
        // 计算每门课程的入度，并构建哈希
        for (int[] prerequisite : prerequisites) {
            int course = prerequisite[0];   // 当前课
            int preCourse = prerequisite[1]; // 当前课的前置课
            inDegree[course]++; // 前置课的后续课是当前课 
            m.get(preCourse).add(course);
        }
        // 存入入度为0的课
        Queue&amp;lt;Integer&gt; q = new LinkedList&amp;lt;&gt;();
        for(int i = 0; i &amp;lt; numCourses; i++){
            if(inDegree[i] == 0){
                // 入度为0 可以直接存入数组
                q.add(i);
            }
        }
        int cnt = 0; // 记录已经完成的课
        while(!q.isEmpty()){
            int c = q.poll();
            cnt++;
            // 寻找当前这门课的后续课程 后续课程的入度-1
            List&amp;lt;Integer&gt; l = m.get(c);
            for(Integer x:l){
                inDegree[x]--;
                // 减完后入度为0 直接添加到队列里面
                if(inDegree[x] == 0){
                    q.add(x);
                }
            }
        }
        return cnt == numCourses;

    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;实现前缀树&#34;&gt;实现前缀树&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;前缀树是一种特殊的多叉树&lt;/strong&gt;，它的 TrieNode 中 chidren 是一个大小为 26 的一维数组，分别对应了26个英文字符 ‘a’ ~ ‘z’，也就是说形成了一棵 &lt;strong&gt;26叉树&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;前缀树的结构里面存储了两个信息：&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    isWord 表示从根节点到当前节点为止，该路径是否形成了一个有效的字符串
  &lt;/li&gt;
  &lt;li&gt;
    children 是该节点的所有子节点。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;在构建前缀树的时候，按照下面的方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    根节点不保存任何信息；
  &lt;/li&gt;
  &lt;li&gt;
    关键词放到「前缀树」时，需要把它拆成各个字符，每个字符按照其在 &amp;#8216;a&amp;#8217; ~ &amp;#8216;z&amp;#8217; 的序号，放在对应的 chidren 里面。下一个字符是当前字符的子节点。
  &lt;/li&gt;
  &lt;li&gt;
    一个输入字符串构建「前缀树」结束的时候，需要把该节点的 isWord 标记为 true，说明从根节点到当前节点的路径，构成了一个关键词。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Trie {
    public Trie[] children;
    public boolean isEnd;

    public Trie() {
        children = new Trie[26];
        isEnd = false;
    }
    
    public void insert(String word) {
        Trie node = this;
        for(int i = 0; i &amp;lt; word.length(); i++){
            char c = word.charAt(i);
            int index = c - &#39;a&#39;;
            if(node.children[index] == null){
                node.children[index] = new Trie();
            }
            node = node.children[index];
        }
        node.isEnd = true;
    }
    
    public boolean search(String word) {
        Trie node = this;
        for(int i = 0; i &amp;lt; word.length(); i++){
            char c = word.charAt(i);
            int index = c - &#39;a&#39;;
            if(node.children[index] == null) return false;
            node = node.children[index];
        }
        if(node.isEnd == false) return false;
        else return true;
    }
    
    public boolean startsWith(String prefix) {
        if (prefix == null || prefix.isEmpty()) return false;
        Trie node = this;
        for (int i = 0; i &amp;lt; prefix.length(); i++) {
            char c = prefix.charAt(i);
            int index = c - &#39;a&#39;;
            if (node.children[index] == null) return false;
            node = node.children[index];
        }
        return true;  // 只要前缀路径存在即可
    }
}&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/10/17/%E5%8A%9B%E6%89%A3hot100-%E5%9B%BE%E8%AE%BA4%E9%A2%98/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/10/17/%E5%8A%9B%E6%89%A3hot100-%E5%9B%BE%E8%AE%BA4%E9%A2%98/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%8A%9B%E6%89%A3hot100/" term="力扣Hot100" label="力扣Hot100" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/bfs/" term="BFS" label="BFS" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/dfs/" term="DFS" label="DFS" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%9B%BE%E8%AE%BA/" term="图论" label="图论" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
力扣hot100—二叉树15题</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/10/12/%E5%8A%9B%E6%89%A3hot100-%E4%BA%8C%E5%8F%89%E6%A0%9115%E9%A2%98/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/10/12/%E5%8A%9B%E6%89%A3hot100-%E4%BA%8C%E5%8F%89%E6%A0%9115%E9%A2%98/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-10-12T07:26:55&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;h2 class=&#34;wp-block-heading&#34; id=&#34;前中后序遍历的递归与非递归写法&#34;&gt;前、中、后序遍历的递归与非递归写法&lt;/h2&gt;
&lt;p&gt;递归写法很容易，非递归写法需要用到模拟栈。&lt;br&gt;
递归写法，对于前中后序遍历，只需要更改递归函数mid的执行顺序即可：&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/10/12/%E5%8A%9B%E6%89%A3hot100-%E4%BA%8C%E5%8F%89%E6%A0%9115%E9%A2%98/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/10/12/%E5%8A%9B%E6%89%A3hot100-%E4%BA%8C%E5%8F%89%E6%A0%9115%E9%A2%98/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;前中后序遍历的递归与非递归写法&#34;&gt;前、中、后序遍历的递归与非递归写法&lt;/h2&gt;
&lt;p&gt;递归写法很容易，非递归写法需要用到模拟栈。&lt;br&gt;
递归写法，对于前中后序遍历，只需要更改递归函数mid的执行顺序即可：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    List&amp;lt;Integer&gt; res = new ArrayList&amp;lt;&gt;();
    void mid(TreeNode node){
        if(node == null) return;
        mid(node.left);
        res.add(node.val);
        mid(node.right);
        return;
    }
    public List&amp;lt;Integer&gt; inorderTraversal(TreeNode root) {
        mid(root);
        return res;
    }
}&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;中序遍历的迭代写法&lt;/strong&gt;，用栈模拟递归栈出来，双重循环，外层循环遍历栈的情况，内层循环不断把当前访问节点的左节点压入栈。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public List&amp;lt;Integer&gt; inorderTraversal(TreeNode root) {
        List&amp;lt;Integer&gt; res = new ArrayList&amp;lt;&gt;();
        Stack&amp;lt;TreeNode&gt; s = new Stack&amp;lt;&gt;();
        TreeNode cur = root;
        while (cur != null || !s.isEmpty()) {
            // 深入左子树，压栈途径节点
            while (cur != null) {
                s.push(cur);
                cur = cur.left;
            }
            
            cur = s.pop();
            res.add(cur.val);
            cur = cur.right;
        }
        return res;
    }
}&lt;/pre&gt;
&lt;p&gt;前序遍历的写法，同样和中序遍历一致，用栈来模拟。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    List&amp;lt;Integer&gt; res = new ArrayList&amp;lt;&gt;();
    public List&amp;lt;Integer&gt; inorderTraversal(TreeNode root) {
        if(root == null) return new ArrayList&amp;lt;Integer&gt;();
        Stack&amp;lt;TreeNode&gt; s = new Stack&amp;lt;&gt;();
        s.push(root);
        TreeNode cur = root;
        while(cur != null || !s.isEmpty()){
            cur = s.pop();
            if(cur != null) res.add(cur.val);
            if(cur != null) s.push(cur.right);
            if(cur != null) s.push(cur.left);
        }
        return res;
    }
}&lt;/pre&gt;
&lt;p&gt;后序遍历，简单的方式就是基于前序遍历，最后reverse一下List。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    List&amp;lt;Integer&gt; res = new ArrayList&amp;lt;&gt;();
    public List&amp;lt;Integer&gt; inorderTraversal(TreeNode root) {
        if(root == null) return new ArrayList&amp;lt;Integer&gt;();
        Stack&amp;lt;TreeNode&gt; s = new Stack&amp;lt;&gt;();
        s.push(root);
        TreeNode cur = root;
        // 维护访问顺序为 根右左，之后reverse一下
        while(cur != null || !s.isEmpty()){
            cur = s.pop();
            if(cur != null) res.add(cur.val);
            if(cur != null) s.push(cur.left);
            if(cur != null) s.push(cur.right);
        }
        Collections.reverse(res);
        return res;
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;二叉树的最大深度&#34;&gt;二叉树的最大深度&lt;/h2&gt;
&lt;p&gt;简单DFS&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public int dfs(TreeNode node){
        if(node == null) return 0;
        int lh = dfs(node.left) + 1;
        int rh = dfs(node.right) + 1;
        return Math.max(lh, rh);
    }
    public int maxDepth(TreeNode root) {
        return dfs(root);
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;翻转二叉树&#34;&gt;翻转二叉树&lt;/h2&gt;
&lt;p&gt;递归法：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) return null;
        TreeNode l = invertTree(root.left);
        TreeNode r = invertTree(root.right);
        root.right = l;
        root.left = r;
        return root;
    }
}&lt;/pre&gt;
&lt;p&gt;还有一种方法是层序遍历方式，用队列实现BFS。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
	public TreeNode invertTree(TreeNode root) {
		if(root==null) {
			return null;
		}
		//将二叉树中的节点逐层放入队列中，再迭代处理队列中的元素
		LinkedList&amp;lt;TreeNode&gt; queue = new LinkedList&amp;lt;TreeNode&gt;();
		queue.add(root);
		while(!queue.isEmpty()) {
			//每次都从队列中拿一个节点，并交换这个节点的左右子树
			TreeNode tmp = queue.poll();
			TreeNode left = tmp.left;
			tmp.left = tmp.right;
			tmp.right = left;
			//如果当前节点的左子树不为空，则放入队列等待后续处理
			if(tmp.left!=null) {
				queue.add(tmp.left);
			}
			//如果当前节点的右子树不为空，则放入队列等待后续处理
			if(tmp.right!=null) {
				queue.add(tmp.right);
			}
			
		}
		//返回处理完的根节点
		return root;
	}
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;对称二叉树&#34;&gt;对称二叉树&lt;/h2&gt;
&lt;p&gt;递归，&lt;strong&gt;思路：比较左右节点，递归比较左节点左孩子与右节点右孩子 &amp;amp;&amp;amp; 左节点右孩子与右节点左孩子&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    
    public boolean isSymmetric(TreeNode root) {
        return check(root.left, root.right);
    }
    public boolean check(TreeNode l, TreeNode r){
        if(l == null &amp;&amp; r == null) return true;
        if(l == null || r == null) return false;
        
        return l.val == r.val &amp;&amp; check(l.left, r.right) &amp;&amp; check(l.right, r.left);
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;二叉树的直径&#34;&gt;二叉树的直径&lt;/h2&gt;
&lt;p&gt;和求深度差不多&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    int res = 0;
    public int dfs(TreeNode node){
        if(node == null) return 0;
        int l = dfs(node.left);
        int r = dfs(node.right);
        
        // 维护最大深度和
        res = Math.max(res, l + r + 1);

        // 返回当前点深度
        return Math.max(l, r) + 1;
    }
    public int diameterOfBinaryTree(TreeNode root) {
        // 当前点的直径 = 左子树最大直径 + 右子树最大直径
        dfs(root);
        // 记录的是深度 直径要-1
        return res - 1;
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;二叉树的层序遍历&#34;&gt;二叉树的层序遍历&lt;/h2&gt;
&lt;p&gt;队列BFS&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List&amp;lt;List&amp;lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        List&amp;lt;List&amp;lt;Integer&gt;&gt; res = new LinkedList&amp;lt;&gt;();
        Queue&amp;lt;TreeNode&gt; q = new LinkedList&amp;lt;&gt;();
        if(root != null) q.offer(root);
        while(!q.isEmpty()){
            int levelSize =q.size();
            List&amp;lt;Integer&gt; list = new LinkedList&amp;lt;&gt;();
            for(int i = 0; i &amp;lt; levelSize; i++){
                TreeNode cur = q.peek();
                q.remove();
                list.add(cur.val);
                if(cur.left !=  null) q.offer(cur.left);
                if(cur.right != null) q.offer(cur.right);
            }
            res.add(list);
        }
        return res;
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;将有序数组转换为二叉搜索树&#34;&gt;将有序数组转换为二叉搜索树&lt;/h2&gt;
&lt;p&gt;用递归的方法，二分开数组的左右两侧，每次递归都找出区间的中点作为root，然后继续递归左右两侧的值。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return dfs(nums, 0, nums.length - 1);
    }
    public TreeNode dfs(int[] nums, int low, int hight){
        if(low &gt; hight){
            return null;
        }
        int mid = (low + hight) / 2;
        // 选择 中间偏左的作为根节点
        TreeNode root = new TreeNode(nums[mid]);
        // 左子树是小于root值的 即数组的左部分
        root.left = dfs(nums, low, mid - 1);
        // 同理 右子树是大于root值的
        root.right = dfs(nums, mid + 1, hight);
        return root;
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;验证二叉搜索树&#34;&gt;验证二叉搜索树&lt;/h2&gt;
&lt;p&gt;由搜索树的性质，左&amp;lt;中&amp;lt;右，与中序遍历的序列一致，要判断二叉搜索树只需要验证中序遍历是否满足增序即可。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public boolean isValidBST(TreeNode root) {
        Stack&amp;lt;TreeNode&gt; st = new Stack&amp;lt;&gt;();
        TreeNode cur = root;
        long preVal = Long.MIN_VALUE;
        
        while(cur != null || !st.isEmpty()){
            while(cur != null){
                st.push(cur);
                cur = cur.left;
            }
            
            cur = st.pop();

            if(cur != null){
                // 如果小于等于前一个 说明不是二叉搜索树
                if(cur.val &amp;lt;= preVal) return false;
                preVal = cur.val;
                cur = cur.right;
            }
        }
        return true;
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;二叉搜索树中第-k-小的元素&#34;&gt;二叉搜索树中第 K 小的元素&lt;/h2&gt;
&lt;p&gt;最直观的方式就是中序遍历找出第k个。用栈迭代法的话，可以找到就停止迭代，速度更优。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {

    List&amp;lt;Integer&gt; nums = new ArrayList&amp;lt;&gt;();
    int cnt = 0;
    int res = 0;
    public void dfs(TreeNode root, int k){
        if(root == null) return;
        dfs(root.left, k);
        cnt++;
        if(cnt == k){
            res = root.val;
        }
        dfs(root.right, k);
        return;
    }
    public int kthSmallest(TreeNode root, int k) {
        dfs(root, k);
        return res;
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;二叉树的右视图&#34;&gt;二叉树的右视图&lt;/h2&gt;
&lt;p&gt;思路：先递归右子树，再递归左子树，当某个深度首次到达时，对应的节点就在右视图中。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    List&amp;lt;Integer&gt; res = new ArrayList&amp;lt;&gt;();
    public List&amp;lt;Integer&gt; rightSideView(TreeNode root) {
        dfs(root, 0);
        return res;
    }
    public void dfs(TreeNode root, int depth){
        if(root == null) return;
        // 如果这个深度首次到达 就把这个点加进去
        if(res.size() == depth){
            res.add(root.val);
        }
        dfs(root.right, depth + 1);
        dfs(root.left, depth + 1);
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;二叉树展开为链表&#34;&gt;二叉树展开为链表&lt;/h2&gt;
&lt;p&gt;直观的做法可以先先序遍历一遍，把节点存List里面，然后第二次迭代再维护。但是这种情况，会有额外的空间需求，如果要O1空间复杂度的话，要用循环迭代，规则不好找，但是满好理解：&lt;/p&gt;
&lt;ol class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    遍历找到当前根R左子树的最右节点A
  &lt;/li&gt;
  &lt;li&gt;
    将节点A的右子树设置为根节点R的右子树
  &lt;/li&gt;
  &lt;li&gt;
    节点A变成根节点R的右子树
  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;画图：&lt;/p&gt;
&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code&gt;    R
   / \
  2   5
 / \   \
3   A   6

//将节点A的右子树设置为根节点R的右子树
    A
     \
      5        
       \        
        6              
//将原来的右子树接到左子树的最右边节点
    R
     \
      2          
     / \          
    3   A 
         \
          5
           \
            6
            
 //将 2 的左子树插入到右子树的地方
    R
     \
      2          
       \          
        3       A  
                 \
                  5
                   \
                    6   
        
 //将原来的右子树接到左子树的最右边节点
    R
     \
      2          
       \          
        3      
         \
          A  
           \
            5
             \
              6     &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public void flatten(TreeNode root) {
        TreeNode head = root;
        while(root != null){
            if(root.left != null){
                TreeNode pre = root.left;
                while(pre.right != null){
                    pre = pre.right;
                }
                // 接上去
                pre.right = root.right;
                root.right = root.left;
                root.left = null;
            }
            root = root.right;
        }
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;中序遍历和前序遍历还原二叉树&#34;&gt;中序遍历和前序遍历还原二叉树&lt;/h2&gt;
&lt;p&gt;挺难的，不好理解。前序遍历是根-左-右，中序遍历是左-根-右。&lt;br&gt;
递归函数需要维护两个序列的窗口。设置前序遍历的窗口为l1、r1、中序遍历的为l2、r2。&lt;br&gt;
对于每一次递归：&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    前序遍历的l1就是这次递归的根节点，基于前序遍历，找出根节点在中序遍历的位置in_root。
  &lt;/li&gt;
  &lt;li&gt;
    那么就可以得到，当前迭代的根节点，左侧的节点数目为：in_root &amp;#8211; l2 = size_left_subtree;
  &lt;/li&gt;
  &lt;li&gt;
    那么就可以开始维护递归节点了。当前节点的左子树root.left将等于：&lt;br /&gt;handler(preorder, inorder, l1+1, l1 + size_left_subtree, l2, in_root-1); &lt;br /&gt;即先序遍历的4个窗口为：&lt;strong&gt;l1+1&lt;/strong&gt;（意思是l1的下一个节点，因为l1节点就是当前迭代维护完毕的根节点）、&lt;strong&gt;l1+size_left_subtree&lt;/strong&gt;（意思是当前左子树需要维护的所有节点数）、&lt;strong&gt;l2&lt;/strong&gt;（中序遍历的左侧窗口起点）、&lt;strong&gt;in_root-1&lt;/strong&gt;（中序遍历的右侧窗口，因为维护的是左子树，根节点是in_root，所以左子树的右侧窗口是in_root-1）
  &lt;/li&gt;
  &lt;li&gt;
    同理可以得出右子树的维护方式。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    Map&amp;lt;Integer, Integer&gt; map = new HashMap&amp;lt;&gt;();
    int n;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        n = preorder.length;
        return handler(preorder, inorder, 0, n-1, 0, n-1);
    }
    // 参数为两个遍历序列和他们各自的序列边界
    public TreeNode handler(int[] preorder, int[] inorder, int l1, int r1, int l2, int r2){
        if(l1 &gt; r1){
            return null;
        }
        // 前序遍历的第一个节点就是根节点 
        int pre_root = l1;
        // 找出根节点在中序遍历中的位置
        int in_root = findInLocation(l1, preorder, inorder);

        TreeNode root = new TreeNode(preorder[pre_root]);
        // 左子树的节点数目 = 中序遍历的根节点位置-中序遍历左侧边界
        int size_left_subtree = in_root - l2;
        // 递归构造
        // 递归参数的含义为：
        // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素
        root.left = handler(preorder, inorder, l1+1, l1 + size_left_subtree, l2, in_root-1);
        root.right = handler(preorder, inorder, l1 + 1 + size_left_subtree, r1, in_root + 1, r2);
        return root;
    }

    public int findInLocation(int pre_left, int[] preorder, int[] inorder){
        for(int i = 0; i &amp;lt; n; i++){
            if(preorder[pre_left] == inorder[i]) return i;
        }
        return -1;
    }
    
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;路径总和&#34;&gt;路径总和Ⅲ&lt;/h2&gt;
&lt;p&gt;这题用DFS的话，关键点在于**路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。**递归不能直接返回结果。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public int pathSum(TreeNode root, int targetSum) {
        if(root == null) return 0;
        int ret = 0;
        ret = dfs(root, targetSum);
        ret += pathSum(root.left, targetSum);
        ret += pathSum(root.right, targetSum);
        return ret;
        
    }
    public int dfs(TreeNode root, long targetSum){
        if(root == null) return 0;
        int ret = 0;
        if(root.val == targetSum){
            ret++;
        }
        ret += dfs(root.left, targetSum - root.val);
        ret += dfs(root.right, targetSum - root.val);
        return ret;
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;二叉树的最近公共祖先&#34;&gt;二叉树的最近公共祖先&lt;/h2&gt;
&lt;p&gt;定义root如果是p、q的最近公共祖先，则有三种情况：&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    p、q在root的子树中，且p、q分别属于root的不同侧子树，
  &lt;/li&gt;
  &lt;li&gt;
    p是root，q在p的子树中
  &lt;/li&gt;
  &lt;li&gt;
    q是root，p在q的子树中
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;递归的逻辑就是，判断p和q是否分列左右子树，如果是说明当前点就是祖先，如果不说说明他们其中有一个是另一个的祖先。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 如果root是p或者q 直接返回就是结果 如果是空也返回
        if(root == null || root == p || root == q) return root;

        // 递归找左右子树 看看左右子树里面有没有p和q
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);

        // 如果left和righ都不为null 说明root就是最近公共祖先
        if(left!= null &amp;&amp; right != null) return root;

        // 如果有一个为null 说明p和q在不同侧子树 且非null的那个就是祖先(非null的那个先遇到 导致之后的那个永远遇不到)
        if(left != null) return left;
        return right;

    }
}&lt;/pre&gt;
&lt;p&gt;二叉树中的最大路径和，&lt;/p&gt;
&lt;p&gt;递归，显然，对于当前节点有四个选择：&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    我自己就是一条路径
  &lt;/li&gt;
  &lt;li&gt;
    只跟左子节点合并成一条路径
  &lt;/li&gt;
  &lt;li&gt;
    只跟右子节点合并成一条路径
  &lt;/li&gt;
  &lt;li&gt;
    以自己为桥梁，跟左、右子节点合并成一条路径
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了方便维护最大路径，直接定义一个非局部的pathSum&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {

    int pathSum = Integer.MIN_VALUE;

    public int dfs(TreeNode node){
        if(node == null) return 0;
        int left = dfs(node.left);
        int right = dfs(node.right);
        // 当前节点的情况 有4种选择 判断出最大的那种
        // 三种情况比最大的：仅本节点，本节点+左子节点，本节点+右子节点
        int res = Math.max(node.val, node.val + Math.max(left, right));
        // 一种特殊情况 即以本节点为桥 连接左右子节点（不考虑本节点的父节点）
        int bridge = node.val + left + right;
        // 维护出最大的 要么是pathSum本身 要么是特殊情况 要么是前三种情况中最大的
        pathSum = Math.max(pathSum, Math.max(res, bridge));
        return res;
    }

    public int maxPathSum(TreeNode root) {
        dfs(root);
        return pathSum;
    }

}&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/10/12/%E5%8A%9B%E6%89%A3hot100-%E4%BA%8C%E5%8F%89%E6%A0%9115%E9%A2%98/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/10/12/%E5%8A%9B%E6%89%A3hot100-%E4%BA%8C%E5%8F%89%E6%A0%9115%E9%A2%98/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%8A%9B%E6%89%A3hot100/" term="力扣Hot100" label="力扣Hot100" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A0%91/" term="树" label="树" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
力扣hot100—LinkedHashMap实现LRU缓存</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/10/10/%E5%8A%9B%E6%89%A3hot100-linkedhashmap%E5%AE%9E%E7%8E%B0lru%E7%BC%93%E5%AD%98/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/10/10/%E5%8A%9B%E6%89%A3hot100-linkedhashmap%E5%AE%9E%E7%8E%B0lru%E7%BC%93%E5%AD%98/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-10-10T11:37:13&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;可以用LinkedHashMap的数据结构实现；要自己手写的话，就需要维护一个哈希+双向链表的数据结构，使用双链表来维护缓存项的访问顺序。&lt;strong&gt;最近访问&lt;/strong&gt;的项位于链表的&lt;strong&gt;头部&lt;/strong&gt;，而&lt;strong&gt;最久未访问&lt;/strong&gt;的项位于链表的&lt;strong&gt;尾部&lt;/strong&gt;。 &lt;code&gt;Map&amp;lt;Integer,MyNodes&amp;gt;&lt;/code&gt;，底层就是&lt;strong&gt;数组+双向链表&lt;/strong&gt;。&lt;br&gt;
put操作，找出来修改值，放到最前面，找不到就新增，节点放最前面&lt;br&gt;
get操作就把找到的node节点放最前面，找不到就返回-1&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/10/10/%E5%8A%9B%E6%89%A3hot100-linkedhashmap%E5%AE%9E%E7%8E%B0lru%E7%BC%93%E5%AD%98/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/10/10/%E5%8A%9B%E6%89%A3hot100-linkedhashmap%E5%AE%9E%E7%8E%B0lru%E7%BC%93%E5%AD%98/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;可以用LinkedHashMap的数据结构实现；要自己手写的话，就需要维护一个哈希+双向链表的数据结构，使用双链表来维护缓存项的访问顺序。&lt;strong&gt;最近访问&lt;/strong&gt;的项位于链表的&lt;strong&gt;头部&lt;/strong&gt;，而&lt;strong&gt;最久未访问&lt;/strong&gt;的项位于链表的&lt;strong&gt;尾部&lt;/strong&gt;。 &lt;code&gt;Map&amp;lt;Integer,MyNodes&amp;gt;&lt;/code&gt;，底层就是&lt;strong&gt;数组+双向链表&lt;/strong&gt;。&lt;br&gt;
put操作，找出来修改值，放到最前面，找不到就新增，节点放最前面&lt;br&gt;
get操作就把找到的node节点放最前面，找不到就返回-1&lt;/p&gt;
&lt;p&gt;解题代码：构造的head和tail 是两个dummy节点 只是为了方便维护链表的哨兵，没有赋值。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class LRUCache {
    class LinkedNode{
        int key;
        int value;
        LinkedNode prev;
        LinkedNode next;
        public LinkedNode(){}
        public LinkedNode(int k1, int v1){
            key = k1;
            value = v1;
        }
    }
    int size;
    int capacity;
    LinkedNode head, tail;
    // 用哈希表存储键值 值是node node有前后节点
    Map&amp;lt;Integer, LinkedNode&gt; cache = new HashMap&amp;lt;&gt;();

    public LRUCache(int capacity) {
        this.size = 0;
        this.capacity = capacity;
        head = new LinkedNode();
        tail = new LinkedNode();
        head.next = tail;
        tail.prev = head;
    }
    
    public int get(int key) {
        LinkedNode n =  cache.get(key);
        if(n == null){
            return -1;
        }
        // 否则说明存在 要更新 将节点的移到链表的头部
        moveToHead(n);
        return n.value;
    }
    
    public void put(int key, int value) {
        LinkedNode node = cache.get(key);
        if (node != null) {
            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
            node.value = value;
            moveToHead(node);
        }
        else {
            // 如果 key 不存在，创建一个新的节点
            LinkedNode newNode = new LinkedNode(key, value);
            // 添加进哈希表
            cache.put(key, newNode);
            // 添加至双向链表的头部
            addToHead(newNode);
            ++size;
            if (size &gt; capacity) {
                // 如果超出容量，删除双向链表的尾部节点
                LinkedNode tail = removeTail();
                // 删除哈希表中对应的项
                cache.remove(tail.key);
                --size;
            }
        }
    }

    // 双向链表维护
    private void addToHead(LinkedNode node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }

    // 双向链表维护
    private void removeNode(LinkedNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    private void moveToHead(LinkedNode node) {
        // 移动到头节点 即去除原来的节点 并在头节点加一个
        removeNode(node);
        addToHead(node);
    }

    private LinkedNode removeTail() {
        LinkedNode res = tail.prev;
        removeNode(res);
        return res;
    }

}

&lt;/pre&gt;
&lt;p&gt;用语言伪代码描述一遍：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class LRUCache {

	构造一个node{
	int key;
	int value;
	node prev;
	node next;
	}
	
	构造一个哈希表用来存key node
	cache = HashMap&amp;lt;Integer, node&gt;();
	统计长度
	size, capacity;
	前后节点
	head tail
    public LRUCache(int capacity) {
    初始化size、capacity、head、tail    
    }
    
    public int get(int key) {
        node = cache.get(key) 
        如果node存在，就得把他移动到链表头
        moveTohead(node)
    }
    
    public void put(int key, int value) {
         node = cache.get(key)
         如果node存在 同get操作
         
         如果node不存在 需要添加新的在表头，并且判断长度
         size++;
         cache.put(key);
         moveTohead(node);
         if(size &gt; capacity){
         获得最后的节点 并去除
         lastNode = getTail();
         cache.remove(lastNode);
         size--
         }
    }
    moveTohead(node) 有两步骤 第一步先将node的前驱后继相连 第二步把node添加到head上
    getTail(); 直接返回tail.prev即可
    
}&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/10/10/%E5%8A%9B%E6%89%A3hot100-linkedhashmap%E5%AE%9E%E7%8E%B0lru%E7%BC%93%E5%AD%98/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/10/10/%E5%8A%9B%E6%89%A3hot100-linkedhashmap%E5%AE%9E%E7%8E%B0lru%E7%BC%93%E5%AD%98/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%8A%9B%E6%89%A3hot100/" term="力扣Hot100" label="力扣Hot100" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%93%88%E5%B8%8C/" term="哈希" label="哈希" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A8%A1%E6%8B%9F/" term="模拟" label="模拟" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E9%93%BE%E8%A1%A8/" term="链表" label="链表" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
力扣hot100—链表14题</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/10/09/%E5%8A%9B%E6%89%A3hot100-%E9%93%BE%E8%A1%A8/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/10/09/%E5%8A%9B%E6%89%A3hot100-%E9%93%BE%E8%A1%A8/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-10-09T07:50:59&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;h2 class=&#34;wp-block-heading&#34; id=&#34;相交链表&#34;&gt;相交链表&lt;/h2&gt;
&lt;p&gt;找两个链表的相同节点，思想：求出两个链表长度，再让长的先走到和短的长度一样，之后一起走。&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/10/09/%E5%8A%9B%E6%89%A3hot100-%E9%93%BE%E8%A1%A8/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/10/09/%E5%8A%9B%E6%89%A3hot100-%E9%93%BE%E8%A1%A8/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;相交链表&#34;&gt;相交链表&lt;/h2&gt;
&lt;p&gt;找两个链表的相同节点，思想：求出两个链表长度，再让长的先走到和短的长度一样，之后一起走。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        int len1 = 0;
        int len2 = 0;
        ListNode curA = headA;
        ListNode curB = headB;
        while(headA != null){
            len1++;
            headA = headA.next;
        }
        while(headB != null){
            len2++;
            headB = headB.next;
        }
        if(len1 &amp;lt; len2){
            int gap = len2 - len1;
            while(gap != 0){
                gap--;
                curB = curB.next;
            }
        }else{
            int gap = len1 - len2;
            while(gap != 0){
                gap--;
                curA = curA.next;
            }
        }
        while(curA != null &amp;&amp; curB != null){
            if(curA == curB) return curA;
            curA = curA.next;
            curB = curB.next;
        }
        return null;
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;反转链表&#34;&gt;反转链表&lt;/h2&gt;
&lt;p&gt;三指针迭代，pre、cur、next，pre作为一个dummy节点。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        while(cur != null){
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;回文链表&#34;&gt;回文链表&lt;/h2&gt;
&lt;p&gt;如果允许空间复杂度为O(n)，可以将其值复制到数组或栈中进行处理，很直观。&lt;br&gt;
没有用额外空间的方法，是将链表后半段反转，就可以用快慢指针一一对比出来。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while(fast != null &amp;&amp; fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        // slow 的位置就是要反转的位置
        ListNode pre = null;
        while(slow != null){
            ListNode next = slow.next;
            slow.next = pre;
            pre = slow;
            slow = next;
        }
        // 不需要特判奇偶
        ListNode cur = head;
        while(pre != null){
            if(pre.val != cur.val) return false;
            pre = pre.next;
            cur = cur.next;
        }
        return true;
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;环形链表&#34;&gt;环形链表&lt;/h2&gt;
&lt;p&gt;快慢指针。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        // 如果有环 快慢指针必定相遇
        ListNode slow = head;
        ListNode fast = head;
        while(fast != null &amp;&amp; fast.next != null){
            fast = fast.next.next;
            slow = slow.next;
            if(slow == fast) return true;
        }
        return false;
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;环形链表2&#34;&gt;环形链表2&lt;/h2&gt;
&lt;p&gt;快慢指针相遇的地方，不一定就是入口节点。 用数学方式计算，可以得到结论：&lt;strong&gt;slow和head同时移动，相遇点是入口&lt;/strong&gt;。&lt;br&gt;
如下图，慢指针走了 &lt;em&gt;a + b&lt;/em&gt; 的距离，快指针此时走了 &lt;em&gt;a + b + n(b + c)&lt;/em&gt; 距离，并且快指针的速度是2倍的慢指针，所以能够得出 &lt;em&gt;a = c+(n−1)(b+c)&lt;/em&gt; ， 即让slow和head同时移动，相遇点就是入口。&lt;figure class=&#34;wp-block-image size-large&#34;&gt;&lt;/p&gt;
&lt;div class=&#39;fancybox-wrapper lazyload-container-unload&#39; data-fancybox=&#39;post-images&#39; href=&#39;https://www.yuyuyuyi1.xyz/wp-content/uploads/2025/10/image-1024x576.png&#39;&gt;
  &lt;img class=&#34;lazyload lazyload-style-1&#34; src=&#34;data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+&#34;  loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1024&#34; height=&#34;576&#34; data-original=&#34;https://www.yuyuyuyi1.xyz/wp-content/uploads/2025/10/image-1024x576.png&#34; src=&#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC&#34; alt=&#34;&#34; class=&#34;wp-image-597&#34;  sizes=&#34;auto, (max-width: 1024px) 100vw, 1024px&#34; /&gt;
&lt;/div&gt;&lt;/figure&gt; 
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while(fast != null &amp;&amp; fast.next != null){
            fast = fast.next.next;
            slow = slow.next;
            if(slow == fast){
                ListNode cur = head;
                while(cur != slow){
                    cur = cur.next;
                    slow = slow.next;
                }
                return cur;
            }
        }
        return null;
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;合并两个有序链表&#34;&gt;合并两个有序链表&lt;/h2&gt;
&lt;p&gt;用一个新的节点引出来就比较简单了。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummy = new ListNode(-1);
        ListNode pre = dummy;
        while(list1 != null &amp;&amp; list2 != null){
            if(list1.val &amp;lt;= list2.val){
                pre.next = list1;
                list1 = list1.next;
            }else{
                pre.next = list2;
                list2 = list2.next;
            }
            pre = pre.next;
        }
        if(list1 == null){
            pre.next = list2;
        }else{
            pre.next = list1;
        }
        return dummy.next;
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;两数相加&#34;&gt;两数相加&lt;/h2&gt;
&lt;p&gt;模拟题&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode cur1 = l1;
        ListNode cur2 = l2;
        ListNode cur3 = new ListNode(-1);
        ListNode cur = cur3;
        int preV = 0;
        while(cur1 != null &amp;&amp; cur2 != null){
            int sum = cur1.val + cur2.val + preV;
            preV = 0;
            if(sum &gt;= 10){
                preV = 1;
                sum = sum - 10;
            }
            ListNode node =new ListNode(sum);
            cur.next = node;
            cur = cur.next;
            cur1 = cur1.next;
            cur2 = cur2.next;
        }
        while(cur1 != null){
            int sum = cur1.val + preV;
            preV = 0;
            if(sum == 10){
                preV = 1;
                sum = sum - 10;
            }
            ListNode node =new ListNode(sum);
            cur.next = node;
            cur = cur.next;
            cur1 = cur1.next;
        }
        while(cur2 != null){
            int sum = cur2.val + preV;
            preV = 0;
            if(sum == 10){
                preV = 1;
                sum = sum - 10;
            }
            ListNode node =new ListNode(sum);
            cur.next = node;
            cur = cur.next;
            cur2 = cur2.next;
        }
        if(preV == 1){
            ListNode node =new ListNode(1);
            cur.next = node;
        }
        return cur3.next;
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;删除链表的倒数第n个节点&#34;&gt;删除链表的倒数第N个节点&lt;/h2&gt;
&lt;p&gt;最直观的方式，就是遍历出长度，然后找到倒数第N个节点的前驱，后继。然后更改即可。&lt;br&gt;
如果要一边扫描的话，就要用双指针，右指针先走，当右指针到边界的时候，左指针的下一个就是要删除的点。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;public class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0, head);
        ListNode l = dummy;
        ListNode r = dummy; 

        // 右指针先前进 n 次
        for (int i = 0; i &amp;lt; n; i++) {
            r = r.next;
        }
        while (r.next != null) {
            r = r.next;
            l = l.next;
        }

        l.next = l.next.next; 
        return dummy.next; 
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;两两交换链表中的节点&#34;&gt;两两交换链表中的节点&lt;/h2&gt;
&lt;p&gt;要用三指针。得画图理解， 光看代码有点抽象。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head == null) return head;
        if(head.next == null) return head;
        ListNode dummy = new ListNode(0);        
        ListNode temp = dummy;
        ListNode cur1 = head;
        temp.next = cur1;
        ListNode cur2 = head.next;
        while(cur1 != null &amp;&amp; cur2 != null){
            cur1.next = cur2.next;
            cur2.next = cur1;
            temp.next = cur2;
            temp = cur1;
            cur1 = temp.next;
            if(cur1 != null) cur2 = cur1.next;
        }
        return dummy.next;
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;k个一组反转链表&#34;&gt;K个一组反转链表&lt;/h2&gt;
&lt;p&gt;像模拟题，主要是裁出来要反转的部分+细节处理。有点难。&lt;br&gt;
贴一个题解。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;public ListNode reverseKGroup(ListNode head, int k) {

    ListNode dummy = new ListNode(0);
    dummy.next = head;

    ListNode pre = dummy;       // 上一段的最后一个节点
    ListNode end = dummy;       // 本段最后一个节点 刚好最后一个节点

    while (end.next != null) {
        for(int i = 0 ; i &amp;lt; k &amp;&amp; end != null; i++){
            end = end.next;
        }

        if(end == null){// 如果直接到头了，那就说明没有满足 k 个
            break;
        }
        ListNode start = pre.next;// 此处是为记录原始未反转段的起始节点
        ListNode nextStart = end.next;// 记录下一个阶段  起始点

        end.next = null;// 此处是为了进行后面的反转操作，断开此处链接,让后面反转操作知道截断点在哪里
        pre.next = reverse(start);      // 反转操作

        start.next = nextStart;// 反转之后，start节点实际是已经最后一个节点了，为了和后面的划分段链接，让他的下一个节点连接上下一段的起始点即可
        pre = start;                    // pre再次来到下一段的上一个节点，也就是本段的结尾点
        end = pre;                      // 结束点，准备开始下一段的循环找 k 长度的段操作
        
    }

    return dummy.next;           // 返回最开始的哨兵
}

private ListNode reverse(ListNode head){
    ListNode pre = null;
    ListNode curr = head;

    while(curr != null){        // 交换操作
        ListNode next = curr.next;
        curr.next = pre;
        pre = curr;
        curr = next;
    }

    return pre;     // 返回哨兵，此处是新的翻转序列的起始节点
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;随机链表的复制&#34;&gt;随机链表的复制&lt;/h2&gt;
&lt;p&gt;用hashMap存旧节点和新节点的映射，两次遍历&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public Node copyRandomList(Node head) {
        // 构造hashmap映射 旧-新
        if(head == null) return null;
        Map&amp;lt;Node, Node&gt; mp = new HashMap&amp;lt;&gt;();
        Node dummy = new Node(-1);
        Node cur = head;
        Node newcur = dummy;
        while(cur != null){
            Node n = new Node(cur.val);
            mp.put(cur, n);
            newcur.next = n;
            newcur = n;
            cur = cur.next;
        }
        // 接下来维护random
        newcur = dummy.next;
        cur = head;
        while(newcur != null){
            // 要维护newcur的random 只需要找到cur.random映射的新节点
            newcur.random = mp.get(cur.random);
            newcur = newcur.next;
            cur = cur.next;
        }
        return dummy.next;
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;排序链表&#34;&gt;排序链表&lt;/h2&gt;
&lt;p&gt;如果要实现O1空间复杂度，很麻烦，需要使用迭代的方式自底向上归并排序，此处只记录归并排序的递归版本（自顶向下）。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public ListNode sortList(ListNode head) {
        // 递归终止条件：空链表或单节点链表
        if (head == null || head.next == null) {
            return head;
        }
        
        // 找到链表中点
        ListNode mid = findMiddle(head);
        
        // 分割链表
        ListNode rightHead = mid.next;
        mid.next = null; // 切断链表
        
        // 递归排序左右两部分
        ListNode left = sortList(head);
        ListNode right = sortList(rightHead);
        
        // 合并两个有序链表
        return merge(left, right);
    }
    
    // 使用快慢指针找到链表中点
    private ListNode findMiddle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head.next; 
        
        while (fast != null &amp;&amp; fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
    
    // 合并两个有序链表
    private ListNode merge(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(-1);
        ListNode curr = dummy;
        
        while (l1 != null &amp;&amp; l2 != null) {
            if (l1.val &amp;lt; l2.val) {
                curr.next = l1;
                l1 = l1.next;
            } else {
                curr.next = l2;
                l2 = l2.next;
            }
            curr = curr.next;
        }
        
        // 连接剩余部分
        curr.next = (l1 != null) ? l1 : l2;
        
        return dummy.next;
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;合并k个升序链表&#34;&gt;合并K个升序链表&lt;/h2&gt;
&lt;p&gt;用优先队列来做是最直观的，优先队列能自动组织队列的元素，复杂度为logn级别。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    // 用优先队列来存节点 优先队列的排序复杂度是logn的
    class priorityNode implements Comparable&amp;lt;priorityNode&gt;{
        int val;
        ListNode ptr;
        public priorityNode(int _val, ListNode _ptr){
            this.val = _val;
            this.ptr = _ptr;
        }
        public int compareTo(priorityNode n){
            return this.val - n.val;
        }
    }

    public ListNode mergeKLists(ListNode[] lists) {
        PriorityQueue&amp;lt;priorityNode&gt; pq = new PriorityQueue&amp;lt;&gt;();
        for(ListNode n:lists){
            if(n != null) pq.offer(new priorityNode(n.val, n));
        }
        ListNode dummy = new ListNode(-1);
        ListNode cur = dummy;
        while(!pq.isEmpty()){
            // 优先队列取出来的 一定是最小的
           priorityNode p =  pq.poll();
            cur.next = p.ptr;
            cur = cur.next;
            if(p.ptr.next != null){
                // 把取出来的点的next 加入队列
                pq.offer(new priorityNode(p.ptr.next.val, p.ptr.next));
            }
        }
        return dummy.next;
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;lru缓存&#34;&gt;LRU缓存&lt;/h2&gt;
&lt;p&gt;见&lt;a href=&#34;https://www.yuyuyuyi1.xyz/2025/10/10/%e5%8a%9b%e6%89%a3hot100-linkedhashmap%e5%ae%9e%e7%8e%b0lru%e7%bc%93%e5%ad%98/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;力扣hot100—LinkedHashMap实现LRU缓存 – yuyuyuyi1’s Blog&lt;/a&gt;&lt;/p&gt;

                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/10/09/%E5%8A%9B%E6%89%A3hot100-%E9%93%BE%E8%A1%A8/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/10/09/%E5%8A%9B%E6%89%A3hot100-%E9%93%BE%E8%A1%A8/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%8A%9B%E6%89%A3hot100/" term="力扣Hot100" label="力扣Hot100" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E9%93%BE%E8%A1%A8/" term="链表" label="链表" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
SpringBoot&#43;Vue&#43;Redis: 黑马点评学习</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/25/springbootvue%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/25/springbootvue%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-09-25T07:24:36&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;项目来自黑马程序员的黑马点评，个人认为是很好的SpringBoot+Redis教程项目。不过疑似有点烂大街了。&lt;br&gt;
视频教程：&lt;a href=&#34;https://www.bilibili.com/video/BV1NV411u7GE/?spm_id_from=333.337.search-card.all.click&#34;&gt;黑马点评项目实战，掌握企业实战项目真实应用场景，一套精通redis缓存技术_哔哩哔哩_bilibili&lt;/a&gt;&lt;br&gt;
我的实现：&lt;a href=&#34;https://gitee.com/wkling/Dianping&#34;&gt;gitee.com/wkling/Dianping&lt;/a&gt;&lt;br&gt;
CSDN上优质的文字教程：&lt;a href=&#34;https://blog.csdn.net/qq_66345100/article/details/131986713&#34;&gt;黑马点评项目学习笔记（15w字详解，堪称史上最详细，欢迎收藏）-CSDN博客&lt;/a&gt;&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/25/springbootvue%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/25/springbootvue%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;项目来自黑马程序员的黑马点评，个人认为是很好的SpringBoot+Redis教程项目。不过疑似有点烂大街了。&lt;br&gt;
视频教程：&lt;a href=&#34;https://www.bilibili.com/video/BV1NV411u7GE/?spm_id_from=333.337.search-card.all.click&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;黑马点评项目实战，掌握企业实战项目真实应用场景，一套精通redis缓存技术_哔哩哔哩_bilibili&lt;/a&gt;&lt;br&gt;
我的实现：&lt;a href=&#34;https://gitee.com/wkling/Dianping&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gitee.com/wkling/Dianping&lt;/a&gt;&lt;br&gt;
CSDN上优质的文字教程：&lt;a href=&#34;https://blog.csdn.net/qq_66345100/article/details/131986713&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;黑马点评项目学习笔记（15w字详解，堪称史上最详细，欢迎收藏）-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;项目技术栈&#34;&gt;项目技术栈&lt;/h2&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    spring boot
  &lt;/li&gt;
  &lt;li&gt;
    Redis
  &lt;/li&gt;
  &lt;li&gt;
    MySQL
  &lt;/li&gt;
  &lt;li&gt;
    vue
  &lt;/li&gt;
  &lt;li&gt;
    ngnix
  &lt;/li&gt;
  &lt;li&gt;
    mybatis-plus
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;技术点&#34;&gt;技术点&lt;/h2&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    Redis缓存
  &lt;/li&gt;
  &lt;li&gt;
    缓存刷新机制（基于interceptor实现）
  &lt;/li&gt;
  &lt;li&gt;
    缓存一致性（缓存更新策略，超时剔除与主动更新）
  &lt;/li&gt;
  &lt;li&gt;
    Redis全局唯一自增
  &lt;/li&gt;
  &lt;li&gt;
    缓存击穿与缓存穿透解决方法（逻辑过期或互斥锁、缓存空字符串）
  &lt;/li&gt;
  &lt;li&gt;
    超卖问题-添加乐观锁
  &lt;/li&gt;
  &lt;li&gt;
    一人一单—spring事务注解、代理对象、方法加锁
  &lt;/li&gt;
  &lt;li&gt;
    Redis基于&lt;code&gt;setnx&lt;/code&gt;实现分布式锁，锁误删问题、锁原子性操作问题
  &lt;/li&gt;
  &lt;li&gt;
    Redssion分布式锁框架
  &lt;/li&gt;
  &lt;li&gt;
    Redis消息队列
  &lt;/li&gt;
  &lt;li&gt;
    Lua脚本实现事务原子化
  &lt;/li&gt;
  &lt;li&gt;
    Redis SortedSet实现点赞用户排名
  &lt;/li&gt;
  &lt;li&gt;
    Feed流的滚动查询方式，基于SortedSet
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;踩过的坑&#34;&gt;踩过的坑&lt;/h2&gt;
&lt;p&gt;2025年08月15日 12:11:42：&lt;br&gt;
问题：前端跑在8080端口，后端跑在8081端口，前端请求的URL也是8080端口的。 ​&lt;br&gt;
原因：nginx配置了前端代理，把所有8080/api的请求转发到8081，通过这种方式解决了跨域问题。&lt;/p&gt;
&lt;p&gt;2025年08月15日 21:34:08：&lt;br&gt;
问题：执行 &lt;code&gt;LambdaQueryWrapper.eq(User::getPhone, phone)&lt;/code&gt;时报错&lt;code&gt;Caused by: java.lang.reflect.InaccessibleObjectException&lt;/code&gt;&lt;br&gt;
原因：Java 17的模块系统限制了反射访问 &lt;code&gt;java.lang.invoke&lt;/code&gt;包，而 MyBatis-Plus 的 Lambda 表达式解析依赖此&lt;strong&gt;反射&lt;/strong&gt;机制。降级java8解决。&lt;/p&gt;
&lt;p&gt;2025年08月16日 12:13:56：&lt;br&gt;
判空逻辑优化：&lt;code&gt;shopJson.isEmpty()&lt;/code&gt;不能这样用，因为如果shopJson是空就会有异常，用&lt;code&gt;StrUtil.isBlank(shopJson)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2025年08月16日 12:17:54：&lt;br&gt;
手动new拦截器会导致自动注入失效：&lt;br&gt;
interceptorRegistry.addInterceptor(new LoginInterceptor());&lt;br&gt;
interceptorRegistry.addInterceptor(new RefreshTokenInterceptor());&lt;br&gt;
后果：拦截器内部的&lt;code&gt;@Autowired&lt;/code&gt;注解（如 &lt;code&gt;StringRedisTemplate&lt;/code&gt;）&lt;strong&gt;不会生效&lt;/strong&gt;，导致 &lt;code&gt;NullPointerException&lt;/code&gt;&lt;figure class=&#34;wp-block-table&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;table-container&#34;&gt;&lt;table class=&#34;has-fixed-layout&#34;&gt;
  &lt;tr&gt;
    &lt;th class=&#34;has-text-align-center&#34; data-align=&#34;center&#34;&gt;
      &lt;strong&gt;操作&lt;/strong&gt;
    &lt;/th&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;th class=&amp;quot;has-text-align-center&amp;quot; data-align=&amp;quot;center&amp;quot;&amp;gt;
  &amp;lt;strong&amp;gt;结果&amp;lt;/strong&amp;gt;
&amp;lt;/th&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&#34;has-text-align-center&#34; data-align=&#34;center&#34;&gt;
      &lt;code&gt;new LoginInterceptor()&lt;/code&gt;
    &lt;/td&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;td class=&amp;quot;has-text-align-center&amp;quot; data-align=&amp;quot;center&amp;quot;&amp;gt;
  绕过Spring容器，导致： 1. &amp;lt;code&amp;gt;@Autowired&amp;lt;/code&amp;gt;失效 2. AOP代理失效 3. 生命周期不受控
&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class=&#34;has-text-align-center&#34; data-align=&#34;center&#34;&gt;
      &lt;code&gt;@Autowired&lt;/code&gt;注入
    &lt;/td&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;td class=&amp;quot;has-text-align-center&amp;quot; data-align=&amp;quot;center&amp;quot;&amp;gt;
  Spring自动处理依赖，保证： 1. 依赖注入有效 2. 单例管理 3. 代理增强
&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/tr&gt;
&lt;/table&gt;&lt;/div&gt;&lt;/figure&gt; 
&lt;h1 class=&#34;wp-block-heading&#34; id=&#34;功能实现&#34;&gt;功能实现&lt;/h1&gt;
&lt;div class=&#34;wp-block-image&#34;&gt;
  &lt;figure class=&#34;aligncenter size-full&#34;&gt;
  &lt;div class=&#39;fancybox-wrapper lazyload-container-unload&#39; data-fancybox=&#39;post-images&#39; href=&#39;https://www.yuyuyuyi1.xyz/wp-content/uploads/2025/09/image-20250814184600315.png&#39;&gt;
    &lt;img class=&#34;lazyload lazyload-style-1&#34; src=&#34;data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+&#34;  loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;479&#34; height=&#34;445&#34; data-original=&#34;https://www.yuyuyuyi1.xyz/wp-content/uploads/2025/09/image-20250814184600315.png&#34; src=&#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC&#34; alt=&#34;&#34; class=&#34;wp-image-448&#34;  sizes=&#34;auto, (max-width: 479px) 100vw, 479px&#34; /&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/div&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;短信登录&#34;&gt;短信登录&lt;/h2&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    基于Session实现登录
  &lt;/li&gt;
  &lt;li&gt;
    集群的session共享问题
  &lt;/li&gt;
  &lt;li&gt;
    基于Redis实现共享session登录
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;流程如下：&lt;/p&gt;
&lt;ol class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    提交手机号—前端校验—点击发送验证码
  &lt;/li&gt;
  &lt;li&gt;
    后端生成验证码，保存验证码到Session/Redis中
  &lt;/li&gt;
  &lt;li&gt;
    前端点击登录，发送请求，在实现的demo中 直接打印在后端控制台上模拟短信验证码功能
  &lt;/li&gt;
  &lt;li&gt;
    后端校验前端的验证码，前端通过cookie/url字段捎带上验证码，后端在session/Redis中基于token检验用户的验证码
  &lt;/li&gt;
  &lt;li&gt;
    验证码通过后，如果不存在用户就创建，存在就将用户信息存到Session/Redis里（Redis中，结构为{phone: code}）
  &lt;/li&gt;
  &lt;li&gt;
    全程有一个拦截器&lt;code&gt;LoginInterceptor&lt;/code&gt;，拦截器默认排除/user/login请求，当访问其他url请求的时候，拦截器启动，并判断用户的登录状态（同样基于Session或Redis）
  &lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;public Result sendCode(String phone, HttpSession session) {
        if (RegexUtils.isPhoneInvalid(phone)) {
            return Result.fail(&#34;手机号格式不正确&#34;);
        }
        // 手机号合法，生成验证码，并保存到Redis中
        String code = RandomUtil.randomNumbers(6);
        stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone, code, RedisConstants.LOGIN_CODE_TTL, TimeUnit.MINUTES);

        // 发送验证码 此处用后端控制台模拟验证码的短信发送
        log.info(&#34;验证码:{}&#34;, code);
        return Result.ok();
    }&lt;/pre&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;用redis解决session集群共享问题&#34;&gt;用Redis解决Session集群共享问题&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;集群的session共享问题&lt;/strong&gt;&lt;br&gt;
多台Tomcat并不共享session存储空间，当请求切换到不同tomcat服务时导致数据丢失的问题。 所以需要用&lt;strong&gt;一台新的服务器跑Redis，存缓存，用Redis缓存来解决Session共享问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;需要注意的点：&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    代码实现中，stringRedisTemplate需要保证K-V都是string类型（数据结构用的Redis Hash）
  &lt;/li&gt;
  &lt;li&gt;
    radis需要设置有效期，&lt;strong&gt;有效期刷新可以在拦截器中实现&lt;/strong&gt;
  &lt;/li&gt;
  &lt;li&gt;
    Redis的数据结构采用HashMap，因为短信验证涉及多个字段（phone、验证码、用户id等）如果用String，String的value需要Json化，更麻烦
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;验证流程：&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    收到前端发的验证码，结构为{phone: code}
  &lt;/li&gt;
  &lt;li&gt;
    先验证code与服务端Redis存着的一致与否
  &lt;/li&gt;
  &lt;li&gt;
    再验证phone是否存在数据库中，不存在就在数据库中注册一个账号
  &lt;/li&gt;
  &lt;li&gt;
    之后，封装一个token返回给前端，token包括用户的id等数据
  &lt;/li&gt;
  &lt;li&gt;
    这个token同时也是服务端缓存用户数据的Redis数据的Key
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;public Result login(LoginFormDTO loginForm, HttpSession session) {
        String phone = loginForm.getPhone();
        String code = loginForm.getCode();
        // 1、判断手机号是否合法
        if (RegexUtils.isPhoneInvalid(phone)) {
            return Result.fail(&#34;手机号格式不正确&#34;);
        }
        // 2、判断验证码是否正确
        // 从redis中拿到缓存的验证码
        String redisCode = stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);
        if (code == null || !code.equals(redisCode)) {
            return Result.fail(&#34;验证码不正确&#34;);
        }
        // 3、判断手机号是否是已存在的用户
        LambdaQueryWrapper&amp;lt;User&gt; lambdaQueryWrapper = new LambdaQueryWrapper&amp;lt;&gt;();
        lambdaQueryWrapper.eq(User::getPhone, phone);
        User user = this.getOne(lambdaQueryWrapper);

        if (Objects.isNull(user)) {
            // 用户不存在，需要注册
            user = createUserWithPhone(phone);
        }
        // 4、保存用户信息到Redis中，便于后面逻辑的判断（比如登录判断、随时取用户信息，减少对数据库的查询）
        UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);
        // stringRedisTemplate要求key与value都为string类型 如果用原生的k-v结构: token-userMap, 会导致userDTO中的long类型字段id
        // 由于不是string类型而报错, 需要修改userMap的映射对 使类型全为string
        // 下面这段代码实现的就是把userDTO的三个字段类型都改成string封装成string
        Map&amp;lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, new HashMap&amp;lt;&gt;(),
                CopyOptions.create().setIgnoreNullValue(true).
                        setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));

        String token = UUID.randomUUID().toString(true);
        String tokenKey = LOGIN_USER_KEY + token;
        stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);
        log.info(&#34;用户tokenKey:&#34; + tokenKey);

        // 设置redis有效期
        stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);

        return Result.ok(token);
    }&lt;/pre&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;双层登录拦截器&#34;&gt;双层登录拦截器&lt;/h3&gt;
&lt;p&gt;登录拦截器（Login Interceptor）的核心作用是 ​&lt;strong&gt;​在用户访问需要身份验证的接口时，自动检查登录状态&lt;/strong&gt;。避免出现直接通过URL就能访问一些需要身份鉴权的页面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么需要双层拦截器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单拦截器的问题在于，单login拦截器会不拦截一些页面（如首页，登录页等），如果用户一直在这些页面停留，不会触发redis缓存刷新，那用户用着用着就发现Redis过期了。用第二个拦截器专门实现Redis刷新。&lt;figure class=&#34;wp-block-image size-large&#34;&gt;&lt;/p&gt;
&lt;div class=&#39;fancybox-wrapper lazyload-container-unload&#39; data-fancybox=&#39;post-images&#39; href=&#39;https://www.yuyuyuyi1.xyz/wp-content/uploads/2025/09/image-20250816003620649-1024x481.png&#39;&gt;
  &lt;img class=&#34;lazyload lazyload-style-1&#34; src=&#34;data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+&#34;  loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1024&#34; height=&#34;481&#34; data-original=&#34;https://www.yuyuyuyi1.xyz/wp-content/uploads/2025/09/image-20250816003620649-1024x481.png&#34; src=&#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC&#34; alt=&#34;&#34; class=&#34;wp-image-465&#34;  sizes=&#34;auto, (max-width: 1024px) 100vw, 1024px&#34; /&gt;
&lt;/div&gt;&lt;/figure&gt; 
&lt;p&gt;&lt;strong&gt;springboot中如何实现拦截器&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    写拦截器类，类需要实现&lt;code&gt;HandlerInterceptor&lt;/code&gt;接口，在类上要带上@Component注解，把他注册为Bean； 拦截器有3个生命周期： &lt;ul class=&#34;wp-block-list&#34;&gt;
      &lt;li&gt;
        &lt;strong&gt;&lt;code&gt;preHandle&lt;/code&gt;，在 控制器方法执行前被调用（路由匹配成功后）&lt;/strong&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;strong&gt;&lt;code&gt;postHandle&lt;/code&gt;，在 控制器方法执行后调用&lt;/strong&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;strong&gt;&lt;code&gt;afterCompletion&lt;/code&gt;&lt;/strong&gt;，在 &lt;strong&gt;整个请求处理完成后&lt;/strong&gt;（包括视图渲染或异常处理）调用，&lt;strong&gt;必定执行&lt;/strong&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    在mvcConfig（实现Spring的&lt;code&gt;WebMvcConfigurer&lt;/code&gt;）中，重写&lt;code&gt;addInterceptors&lt;/code&gt;接口，添加先前实现的拦截器类。&lt;br /&gt;具体实现：
  &lt;/li&gt;
&lt;/ul&gt;
&lt;ol class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    第一层是刷新拦截器，获取token，用&lt;code&gt;String token = request.getHeader(&#34;authorization&#34;);&lt;/code&gt;常见的身份验证Token会通过 &lt;code&gt;Authorization&lt;/code&gt;头部传递。
  &lt;/li&gt;
  &lt;li&gt;
    Redis里面找一下这个token有value吗，找不到说明没有，直接response(401)。
  &lt;/li&gt;
  &lt;li&gt;
    找的到说明存在，把信息存在&lt;strong&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;&lt;/strong&gt;中，并且刷新token的有效期。
  &lt;/li&gt;
  &lt;li&gt;
    第二层拦截器较为简单，只需要拦截URL+二次鉴权就行了。
  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;拦截器执行顺序&lt;/strong&gt;&lt;figure class=&#34;wp-block-table&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;table-container&#34;&gt;&lt;table class=&#34;has-fixed-layout&#34;&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;strong&gt;preHandle​&lt;/strong&gt;​
    &lt;/td&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;td&amp;gt;
  按注册顺序执行（先Refresh后Login）
&amp;lt;/td&amp;gt;

&amp;lt;td&amp;gt;
  &amp;lt;code&amp;gt;preHandle()&amp;lt;/code&amp;gt;
&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
      ​&lt;strong&gt;​postHandle​&lt;/strong&gt;​
    &lt;/td&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;td&amp;gt;
  按注册逆序执行（先Login后Refresh）
&amp;lt;/td&amp;gt;

&amp;lt;td&amp;gt;
  &amp;lt;code&amp;gt;postHandle()&amp;lt;/code&amp;gt;
&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
      ​&lt;strong&gt;​afterCompletion​&lt;/strong&gt;​
    &lt;/td&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;td&amp;gt;
  按注册逆序执行（先Login后Refresh）
&amp;lt;/td&amp;gt;

&amp;lt;td&amp;gt;
  &amp;lt;code&amp;gt;afterCompletion()&amp;lt;/code&amp;gt;
&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/tr&gt;
&lt;/table&gt;&lt;/div&gt;&lt;/figure&gt; &lt;figure class=&#34;wp-block-image size-large&#34;&gt;
&lt;div class=&#39;fancybox-wrapper lazyload-container-unload&#39; data-fancybox=&#39;post-images&#39; href=&#39;https://www.yuyuyuyi1.xyz/wp-content/uploads/2025/09/image-1-1024x720.png&#39;&gt;
  &lt;img class=&#34;lazyload lazyload-style-1&#34; src=&#34;data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+&#34;  loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1024&#34; height=&#34;720&#34; data-original=&#34;https://www.yuyuyuyi1.xyz/wp-content/uploads/2025/09/image-1-1024x720.png&#34; src=&#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC&#34; alt=&#34;&#34; class=&#34;wp-image-466&#34;  sizes=&#34;auto, (max-width: 1024px) 100vw, 1024px&#34; /&gt;
&lt;/div&gt;&lt;/figure&gt; 
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;threadlocal应用与实现&#34;&gt;ThreadLocal应用与实现&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ThreadLocal&lt;/strong&gt; 提供了线程局部的变量，&lt;strong&gt;每个线程都有自己独立的变量副本&lt;/strong&gt;，互不干扰。它实现了&lt;strong&gt;线程隔离&lt;/strong&gt;，避免了多线程环境下的共享变量竞争问题。项目中，封装成UserHolder来使用。&lt;/p&gt;
&lt;p&gt;ThreadLocal底层其实是一个Map，Key是ThreadLocal对象本身，Value就是set的值。Key是弱引用的，当没会被GC自动回收，Value是强引用的，无法被GC自动回收，所以需要自己手动remove不用的ThreadLocal值。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;public class UserHolder {
    private static final ThreadLocal&amp;lt;UserDTO&gt; tl = new ThreadLocal&amp;lt;&gt;();

    public static void saveUser(UserDTO user){
        tl.set(user);
    }

    public static UserDTO getUser(){
        return tl.get();
    }

    // 移除线程绑定的对象而非线程本身
    public static void removeUser(){
        tl.remove();
    }
}
&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;数据查询缓存&#34;&gt;数据查询缓存&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;缓存更新策略（为了解决数据一致性问题）&lt;/strong&gt;&lt;br&gt;
在修改数据库的同时，更新缓存。&lt;br&gt;
缓存更新的实现一般是删掉缓存，然后再添加一个新的，比用更新命令更新缓存更高效&lt;br&gt;
缓存与数据库的操作更新顺序，优先执行数据库更新（原则是优先执行速度慢的）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么要先更新数据库再删除缓存&lt;/strong&gt;？&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    先删除缓存，再更新数据库，如果这个时候有请求，会出现缓存穿透，全部去访问数据库了。
  &lt;/li&gt;
  &lt;li&gt;
    先更新数据库可能存在脏读，例如线程1更新数据库，更新缓存的这一刻，有线程2也更新了数据库，这样线程读的数据就是脏的，这种情况的概率特别低，因为需要满足线程1正在更新缓存且线程2更新数据库，更新缓存的操作是特别快的。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;常用缓存读写策略&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    &lt;strong&gt;旁路缓存读写，&lt;/strong&gt;写（更新）的时候先更新数据库，再删缓存；读的时候先读缓存，读不到再读数据库，读到了再把内容写到缓存里。最常用的策略，较适用于读多写少的场景。
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;读写穿透，&lt;/strong&gt;把cache当主要对象。写的时候，先更新cache，之后再更新数据库；当读的时候，缓存里读的到就返回，读不到就请求给数据库，数据库返回给cache，cache再返回，较适用数据实时性要求较高、对一致性要求严格的场景
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;异步缓存写入，&lt;/strong&gt;和读写穿透差不多，区别在于数据库同步的方式，读写穿透是同步的，异步缓存写入是异步的
  &lt;/li&gt;
  &lt;li&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;缓存穿透问题-wp-block-heading&#34;&gt;&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/25/springbootvue%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/#缓存穿透问题-wp-block-heading&#34; class=&#34;anchor-link&#34; aria-label=&#34;缓存穿透问题-wp-block-heading&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;0 0 512 512&#34; class=&#34;icon anchor-icon&#34;&gt;&lt;path d=&#34;M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z&#34;/&gt;&lt;/svg&gt;&lt;/a&gt;缓存穿透问题 {.wp-block-heading}&lt;figure class=&#34;wp-block-image size-large&#34;&gt;&lt;/h3&gt;
&lt;div class=&#39;fancybox-wrapper lazyload-container-unload&#39; data-fancybox=&#39;post-images&#39; href=&#39;https://www.yuyuyuyi1.xyz/wp-content/uploads/2025/09/image-20250817120727735-1024x490.png&#39;&gt;
  &lt;img class=&#34;lazyload lazyload-style-1&#34; src=&#34;data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+&#34;  loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1024&#34; height=&#34;490&#34; data-original=&#34;https://www.yuyuyuyi1.xyz/wp-content/uploads/2025/09/image-20250817120727735-1024x490.png&#34; src=&#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC&#34; alt=&#34;&#34; class=&#34;wp-image-485&#34;  sizes=&#34;auto, (max-width: 1024px) 100vw, 1024px&#34; /&gt;
&lt;/div&gt;&lt;/figure&gt; 
&lt;p&gt;&lt;strong&gt;缓存穿透&lt;/strong&gt;是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库，造成数据库压力巨大。&lt;br&gt;
解决方法一般采用&lt;strong&gt;缓存空值。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;if(shopJson != null &amp;&amp; shopJson.equals(&#34;&#34;)){
            // 说明 返回的shopJson是一个用以解决缓存穿透的&#34;&#34;字符串
            return null;
        }&lt;/pre&gt;
&lt;p&gt;还有一种方法是&lt;strong&gt;布隆过滤器：&lt;/strong&gt;&lt;br&gt;
布隆过滤器是一种​&lt;strong&gt;​空间效率极高（使用位数组bit array存储）的概率型数据结构​&lt;/strong&gt;​，用于​&lt;strong&gt;​快速判断一个元素是否存在于某个集合中​&lt;/strong&gt;​。&lt;br&gt;
优点是空间占用小，缺点是其基于概率，仍有误判的风险（布隆过滤器说存在数据，实际上不一定存在）。&lt;/p&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;缓存击穿问题&#34;&gt;缓存击穿问题&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;缓存击穿问题&lt;/strong&gt;也叫热点Key问题，就是一个被&lt;strong&gt;高并发访问&lt;/strong&gt;并且&lt;strong&gt;缓存重建业务较复杂&lt;/strong&gt;的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常见的解决方案有两种：&lt;/strong&gt; 逻辑过期（设置缓存TTL永不过期，缓存数据里面加个逻辑TTL，拿数据的时候判断逻辑TTL有没有过期，优点是性能高，缺点是内存占用大） 互斥锁（加锁访问数据库，性能差，容易出现死锁，但是内存占用小）&lt;/p&gt;
&lt;p&gt;**互斥锁方案，**基于Redis的setnx指令实现，setnx指令能够实现：当且仅当 &lt;code&gt;key&lt;/code&gt;不存在时，将 &lt;code&gt;key&lt;/code&gt;的值设为 &lt;code&gt;value&lt;/code&gt;，设置成功返回1，否则返回0，相关代码如下:&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;// 当有访问数据库的请求需要处理时 自旋锁尝试拿锁
            while (!tryLock(mutexKey)) {
                if (++spinCount &gt; maxSpins) {
                    log.warn(&#34;获取锁失败，已达到最大自旋次数: {}&#34;, maxSpins);
                    return null; // 或者可以返回旧数据/降级处理
                }
                Thread.sleep(spinInterval); // 短暂休眠后继续尝试
            }

            private boolean tryLock(String key){
                // 基于Redis的setnex实现互斥锁
                Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, &#34;1&#34;, 10, TimeUnit.SECONDS);
                return BooleanUtil.isTrue(flag);
            }
    
            private boolean unlock(String key){
                Boolean flag = stringRedisTemplate.delete(key);
                return BooleanUtil.isTrue(flag);
            }&lt;/pre&gt;
&lt;p&gt;测试一下，自己的PC上（AMD R7-7730U）QPS（query per second）400的时候，接口吞吐能达到339。&lt;figure class=&#34;wp-block-image size-large&#34;&gt;&lt;/p&gt;
&lt;div class=&#39;fancybox-wrapper lazyload-container-unload&#39; data-fancybox=&#39;post-images&#39; href=&#39;https://www.yuyuyuyi1.xyz/wp-content/uploads/2025/09/image-2-1024x80.png&#39;&gt;
  &lt;img class=&#34;lazyload lazyload-style-1&#34; src=&#34;data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+&#34;  loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1024&#34; height=&#34;80&#34; data-original=&#34;https://www.yuyuyuyi1.xyz/wp-content/uploads/2025/09/image-2-1024x80.png&#34; src=&#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC&#34; alt=&#34;&#34; class=&#34;wp-image-511&#34;  sizes=&#34;auto, (max-width: 1024px) 100vw, 1024px&#34; /&gt;
&lt;/div&gt;&lt;/figure&gt; 
&lt;p&gt;&lt;strong&gt;逻辑过期方案&lt;/strong&gt;，要注意&lt;strong&gt;一定要先进行数据预热&lt;/strong&gt;。就不压测了，因为自己的实现上也加了一层互斥锁访问数据库，效果肯定是没上一个方案好的。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;// 通过自己的逻辑TTL判断是否过期 如果过期 需要缓存重建
        RedisData redisData = JSONUtil.toBean(shopJson, RedisData.class);
        JSONObject data = (JSONObject)redisData.getData();
        Shop shop = JSONUtil.toBean(data, Shop.class);
        LocalDateTime expireTime = redisData.getExpireTime();

        // 判断是否过期
        if(expireTime.isAfter(LocalDateTime.now())){
            // 未过期 返回
             return shop;
        }
        
        // 拿锁访问数据库
        try {
            // 自旋锁尝试拿锁
            while (!tryLock(mutexKey)) {
                if (++spinCount &gt; maxSpins) {
                    log.warn(&#34;获取锁失败，已达到最大自旋次数: {}&#34;, maxSpins);
                    return null; // 或者可以返回旧数据/降级处理
                }
                Thread.sleep(spinInterval); // 短暂休眠后继续尝试
            }
            // 拿锁成功 使用线程进行缓存重建
            CACHE_REBUILD_POOL.submit(() -&gt; {
                this.saveShop2Redis(id, 30L);
            });
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } finally {
            unlock(mutexKey);
        }

    // 数据预热、重建缓存
    public void saveShop2Redis(Long id, Long expireSeconds){
        Shop shop = this.getById(id);
        log.info(&#34;查询到shop&#34;);
        RedisData redisData = new RedisData();
        redisData.setData(shop);
        redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));
        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(redisData));
    }&lt;/pre&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;缓存雪崩问题&#34;&gt;缓存雪崩问题&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;缓存雪崩&lt;/strong&gt;是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力&lt;br&gt;
一般解决方法：&lt;strong&gt;给不同的Key的TTL添加随机值&lt;/strong&gt;、&lt;strong&gt;给业务添加多级缓存&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;本项目没有对预防缓存雪崩进行实现。&lt;/p&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;秒杀场景&#34;&gt;秒杀场景&lt;/h2&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;分布式id&#34;&gt;分布式ID&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;为什么要实现全局唯一ID？&lt;/strong&gt;&lt;br&gt;
自增ID有些局限性：安全隐私问题，自增太规律的话，可能会被人推测出一些敏感信息；不方便分布式储存，一般来说，数据库的表，超过500万行就要考虑分表分库了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分布式ID的实现方式&lt;/strong&gt;&lt;br&gt;
一般有：数据库自增、UUID、Redis自增。本项目，采用的实现方式是&lt;strong&gt;时间戳&lt;/strong&gt;+&lt;strong&gt;Redis自增的序列号&lt;/strong&gt;。&lt;br&gt;
本项目的ID是64位的，timestamp基于标准时间gap确定，之后将timestamp左移32位后接上Redis缓存返回的自增序列号。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;public long nextId(String keyPrefix){
        // 1、生成时间戳
        LocalDateTime now = LocalDateTime.now();
        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);
        long timestamp = nowSecond - BEGIN_TIMESTAMP;
        // 2、生成序列号
        // 以当天的时间戳为key，防止一直自增下去导致超时，这样每天的极限都是 2^{31}
        String date = now.format(DateTimeFormatter.ofPattern(&#34;yyyyMMdd&#34;));
        Long count = stringRedisTemplate.opsForValue().increment(ID_PREFIX + keyPrefix + &#34;:&#34; + date);


        // 3、拼接并返回 位运算
        // key是不变的 订单号是基于timestamp和Redis自增拼接的
        return timestamp &amp;lt;&amp;lt; COUNT_BITS | count;
    }&lt;/pre&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;乐观锁解决单体架构下的库存超卖问题&#34;&gt;&lt;strong&gt;乐观锁解决单体架构下的库存超卖问题&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;高并发场景下，如果什么也不做，会出现库存&lt;strong&gt;超卖问题&lt;/strong&gt;。例子如下，线程1和线程2都查订单，都觉得库存还够，然后就都对订单进行了扣减。问题的本质是因为查库存-扣减订单的&lt;strong&gt;过程是非原子化导致的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;超卖问题的常见解决方案：&lt;/strong&gt;&lt;br&gt;
**悲观锁，**认为线程安全问题一定会发生，因此操作数据库之前都需要先获取锁，确保线程串行执行。常见的悲观锁有：synchronized、lock&lt;br&gt;
**乐观锁，**认为线程安全问题不一定发生，因此不加锁，只会在更新数据库的时候去判断有没有其它线程对数据进行修改，如果没有修改则认为是安全的，直接更新数据库中的数据即可，如果修改了则说明不安全，直接抛异常或者等待重试。常见的实现方式有：&lt;strong&gt;版本号法（读取的时候看一眼版本号，要修改的时候再看一眼版本号， 版本号相同说明没被改过）、CAS操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用CAS方法，解决乐观锁的超卖问题：&lt;/strong&gt;&lt;br&gt;
CAS法不加版本号，在set数据库的时候，再查一次数据，看看是否有变化，不变就说明没人改过，修改即可。下面代码的实现CAS方法的核心就是&lt;code&gt;eq(&amp;quot;stock&amp;quot;, voucher.getStock())&lt;/code&gt;，不过这样会导致数据已修改就终止操作了，所以可以改进为：&lt;code&gt;gt(SeckillVoucher::getStock, 0)&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;// 添加乐观锁 CAS法 gt(SeckillVoucher::getStock, 0)是eq(&#34;stock&#34;, voucher.getStock())的优化版
        boolean success = seckillVoucherService.update().setSql(&#34;stock = stock - 1&#34;)
                .eq(&#34;stock&#34;, voucher.getStock()).gt(SeckillVoucher::getStock, 0).update();
        if(!success){
            return Result.fail(&#34;更新数据库失败&#34;);
        }&lt;/pre&gt;
&lt;p&gt;&lt;mark style=&#34;background-color:rgba(0, 0, 0, 0)&#34; class=&#34;has-inline-color has-luminous-vivid-amber-color&#34;&gt;注意&lt;/mark&gt;：这种方案，能够保证库存不低于0，但是&lt;strong&gt;不能保证一人一单。&lt;/strong&gt;&lt;br&gt;
要想实现&lt;strong&gt;单机统架构下的一人一单，直接考虑悲观锁。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;分布式锁解决集群架构下的一人一单问题&#34;&gt;分布式锁解决集群架构下的一人一单问题&lt;/h3&gt;
&lt;p&gt;通过加悲观锁，能够解决单机架构下的一人一单问题，但是在集群下就行不通了。在集群模式下，加锁只是对该JVM给当前这台服务器的请求的加锁，而集群是多台服务器，所以要使用分布式锁，满足&lt;strong&gt;集群模式下多进程可见&lt;/strong&gt;并且互斥的锁。&lt;/p&gt;
&lt;p&gt;简单的Redis分布式锁实现方式，基于&lt;code&gt;SETNX&lt;/code&gt;指令，key为锁名称，value为每个线程自己的threadID。代码如下：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;@Override
    public boolean tryLock(long timeoutSec) {
        String threadId = ID_PREFIX + Thread.currentThread().getId() + &#34;&#34;;
        // SET KEY_PREFIX:name  name为锁名称
        Boolean result = stringRedisTemplate.opsForValue()
                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);
        return Boolean.TRUE.equals(result);
    }
    @Override
    public void unlock() {
        stringRedisTemplate.delete(KEY_PREFIX + name);
    }&lt;/pre&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;分布式锁的优化&#34;&gt;分布式锁的优化&lt;/h3&gt;
&lt;h4 class=&#34;wp-block-heading&#34; id=&#34;锁误删问题&#34;&gt;锁误删问题&lt;/h4&gt;
&lt;p&gt;为了避免长时间持有锁导致的效率低下等问题，为Redis的锁添加了一个持有时间。但是假如某线程在持有锁的时候，进行了IO等耗时操作，然后Redis到期释放锁了，线程2拿到了锁执行任务，等线程1IO完毕之后，其以为自己还持有锁，就执行了放锁操作，结果实际上这个锁已经是线程二正在使用了。&lt;/p&gt;
&lt;p&gt;最简单的优化方式就是，放锁的时候，判断一下是不是自己的锁。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;@Override
    public void unlock() {
        // 判断锁的线程标识是否与当前线程一致
        String currentThreadFlag = ID_PREFIX + Thread.currentThread().getId();
        String redisThreadFlag = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);
        if (currentThreadFlag != null || currentThreadFlag.equals(redisThreadFlag)) {
            // 一致，说明当前的锁就是当前线程的锁，可以直接释放
            stringRedisTemplate.delete(KEY_PREFIX + name);
        }
    }&lt;/pre&gt;&lt;figure class=&#34;wp-block-image size-large&#34;&gt;
&lt;div class=&#39;fancybox-wrapper lazyload-container-unload&#39; data-fancybox=&#39;post-images&#39; href=&#39;https://www.yuyuyuyi1.xyz/wp-content/uploads/2025/09/image-20250819231415772-1024x513.png&#39;&gt;
  &lt;img class=&#34;lazyload lazyload-style-1&#34; src=&#34;data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+&#34;  loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1024&#34; height=&#34;513&#34; data-original=&#34;https://www.yuyuyuyi1.xyz/wp-content/uploads/2025/09/image-20250819231415772-1024x513.png&#34; src=&#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC&#34; alt=&#34;&#34; class=&#34;wp-image-540&#34;  sizes=&#34;auto, (max-width: 1024px) 100vw, 1024px&#34; /&gt;
&lt;/div&gt;&lt;/figure&gt; 
&lt;h4 class=&#34;wp-block-heading&#34; id=&#34;lua脚本解决分布式锁误删问题实现原子化锁释放&#34;&gt;Lua脚本解决分布式锁误删问题、实现原子化锁释放&lt;/h4&gt;
&lt;p&gt;判断锁是否是自己的到释放锁这一过程并不是原子性的，可能会出现判断完了后刚好JVM跑去执行GC 把线程阻塞住了，导致超时释放锁，同样会导致锁误删问题。解决方法是需要确保判断到释放的过程是原子性。使用Lua脚本。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;// static包裹的静态代码块 作用是在类初始化的时候调用一次
    private static final DefaultRedisScript&amp;lt;Long&gt; UNLOCK_SCRIPT;

    static {
        UNLOCK_SCRIPT = new DefaultRedisScript&amp;lt;&gt;();
        UNLOCK_SCRIPT.setLocation(new ClassPathResource(&#34;lua/unlock.lua&#34;));
        UNLOCK_SCRIPT.setResultType(Long.class);
    }
    
    
    // 放锁 放锁利用Lua脚本原子化操作
    public void unlock() {
        // 执行lua脚本
        // stringRedisTemplate.execute第二个参数是一个集合
        stringRedisTemplate.execute(
                UNLOCK_SCRIPT,
                Collections.singletonList(KEY_PREFIX + name),
                ID_PREFIX + Thread.currentThread().getId()
        );
    }&lt;/pre&gt;
&lt;p&gt;Lua脚本的流程：&lt;/p&gt;
&lt;ol class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    获取锁中的线程标示
  &lt;/li&gt;
  &lt;li&gt;
    判断是否与指定的标示（当前线程标示）一致
  &lt;/li&gt;
  &lt;li&gt;
    如果一致则释放锁（删除）
  &lt;/li&gt;
  &lt;li&gt;
    如果不一致则什么都不做
  &lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;-- 先获取线程标识 get key[1]
local id = redis.call(&#39;get&#39;, KEYS[1])

-- 比较缓存中的线程标识与当前线程标识是否一致
if (id == ARGV[1]) then
    -- 一致，直接删除
    return redis.call(&#39;del&#39;, KEYS[1])
end
-- 不一致，返回0
return 0&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;实现异步秒杀优化&#34;&gt;实现异步秒杀优化&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;为什么用异步秒杀?&lt;/strong&gt;&lt;br&gt;
串行执行的实现方法并发能力弱。&lt;/p&gt;
&lt;p&gt;分成两个线程，将耗时较短的逻辑判断放到Redis中，实际上，只要满足库存充足且一人一单，一定是可以下单成功的，完全可以直接返回给用户成功的信息，然后后台开一个线程，后台线程去慢慢执行队列里的任务（操作数据库），这样能够提供系统的并发能力。&lt;figure class=&#34;wp-block-image size-large&#34;&gt;&lt;/p&gt;
&lt;div class=&#39;fancybox-wrapper lazyload-container-unload&#39; data-fancybox=&#39;post-images&#39; href=&#39;https://www.yuyuyuyi1.xyz/wp-content/uploads/2025/09/image-4-1024x469.png&#39;&gt;
  &lt;img class=&#34;lazyload lazyload-style-1&#34; src=&#34;data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+&#34;  loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1024&#34; height=&#34;469&#34; data-original=&#34;https://www.yuyuyuyi1.xyz/wp-content/uploads/2025/09/image-4-1024x469.png&#34; src=&#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC&#34; alt=&#34;&#34; class=&#34;wp-image-565&#34;  sizes=&#34;auto, (max-width: 1024px) 100vw, 1024px&#34; /&gt;
&lt;/div&gt;&lt;/figure&gt; 
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;基于jvm阻塞队列实现&#34;&gt;基于JVM阻塞队列实现&lt;/h3&gt;
&lt;p&gt;基于JVM自己的阻塞队列来实现异步操作，即新开的线程将任务放入JVM自己的阻塞队列中。实现细节如下：&lt;/p&gt;
&lt;p&gt;Java的阻塞队列为：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;private BlockingQueue&amp;lt;VoucherOrder&gt; ordersTask = new ArrayBlockingQueue&amp;lt;&gt;(1024 * 1024);&lt;/pre&gt;
&lt;p&gt;并且，需要在一开始，就注册一个线程处理任务。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;// Spring Bean 初始化完成后
	@PostConstruct
    private void init(){
         SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler());
    }
    /**
     * 线程任务: 不断从阻塞队列中获取订单
     */
    private class VoucherOrderHandler implements Runnable {

        @Override
        public void run() {
            while (true){
                try {
                    // 取任务
                    log.info(&#34;get task&#34;);
                    VoucherOrder voucherOrder = ordersTask.take();
                    // 执行任务
                    handleVoucherOrder(voucherOrder);
                } catch (InterruptedException e) {
                    log.error(&#34;异常&#34;, e);
                    throw new RuntimeException(e);
                }
            }
        }
    }
    // 任务为将数据持久化到数据库中。
    private void handleVoucherOrder(VoucherOrder voucherOrder){
        //创建订单 不能再userHoder了 因为现在是多线程 ThradLocal下取不到主线程的东西
        // Long userId = UserHolder.getUser().getId();
        Long userId = voucherOrder.getUserId();
        // 自己创建分布式锁对象
        SimpleRedisLock lock = new SimpleRedisLock(stringRedisTemplate,&#34;order:&#34; + userId);
        boolean isLocked = lock.tryLock(1200);
        if(!isLocked){
            log.info(&#34;获取锁失败&#34;);
        }
        try{
            log.info(&#34;threadProxy.createVoucherOrder_v2(voucherOrder);&#34;);
            // 具体的持久化任务 交由createVoucherOrder_v2执行
            threadProxy.createVoucherOrder_v2(voucherOrder);
        }finally {
            lock.unlock();
        }
    }
&lt;/pre&gt;
&lt;p&gt;此处有个关键点，关于&lt;code&gt;threadProxy&lt;/code&gt;的使用。&lt;br&gt;
&lt;strong&gt;&lt;code&gt;AopContext.currentProxy()&lt;/code&gt;的作用&lt;/strong&gt;是获取当前类的 Spring AOP 代理对象。&lt;strong&gt;具体来说，为什么子线程的任务&lt;code&gt;handleVoucherOrder&lt;/code&gt;需要用&lt;code&gt;threadProxy.createVoucherOrder_v2(voucherOrder)&lt;/code&gt;，通过主线程的代理来调用处理方法，而不直接用this.来访问？&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;核心就在于&lt;/strong&gt;：&lt;br&gt;
&lt;strong&gt;Spring 事务的本质​&lt;/strong&gt;​：当在方法上添加 &lt;code&gt;@Transactional&lt;/code&gt;时，Spring 会为该 Bean 创建一个代理对象，在目标方法执行前后插入事务管理逻辑（如开启事务、提交/回滚）。如果直接用&lt;code&gt;this.createVoucherOrder_v2&lt;/code&gt;来执行添加操作，会导致&lt;code&gt;createVoucherOrder_v2&lt;/code&gt;函数的@Transactional失效，既事务失效。因为直接用&lt;code&gt;this.createVoucherOrder_v2&lt;/code&gt;，&lt;code&gt;this&lt;/code&gt;指向的是​&lt;strong&gt;​原始对象​&lt;/strong&gt;​（&lt;code&gt;VoucherOrderServiceImpl&lt;/code&gt;），而非 Spring 生成的代理对象。&lt;/p&gt;
&lt;p&gt;最后，controller直接指向的serviceimpl如下，Lua脚本主要完成了库存检查与用户是否有购买资格的判断。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;// 查优惠券等操作 放到lua脚本里面写
        Long orderId = redisIDWorker.nextId(&#34;order&#34;);
        Long userId = UserHolder.getUser().getId();

        // 1、执行Lua脚本，判断用户是否具有秒杀资格
        log.info(&#34;执行lua脚本 添加到redis消息队列&#34;);
        Long result = stringRedisTemplate.execute(
                SECKILL_SCRIPT_v2,
                Collections.emptyList(),
                voucherId.toString(), userId.toString(), orderId.toString());
        int r = result.intValue();
        // 如果r = 0 说明有购买资格 待处理事件已放入消息队列
        if(r != 0){
            // 脚本执行结果不为0 无购买资格
            return Result.fail(r == 2 ? &#34;不能重复下单&#34; : &#34;库存不足&#34;);
        }

        VoucherOrder voucherOrder = new VoucherOrder();
        voucherOrder.setVoucherId(voucherId);
        voucherOrder.setUserId(userId);
        // 作为类的成员变量赋值，方便子线程使用主线程获得的完整代理对象
        threadProxy = (IVoucherOrderService)AopContext.currentProxy();&lt;/pre&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;基于redis-stream实现&#34;&gt;基于Redis-Stream实现&lt;/h3&gt;
&lt;p&gt;JVM阻塞队列是基于内存的，掉电的话阻塞队列里的任务全消失了，而且jvm有JVM自己的内存限制。用Redis自带的队列来实现消息队列更合适。&lt;/p&gt;
&lt;p&gt;Redis中能够实现MQ效果的主要由以下三种方式：&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;/p&gt;
&lt;div class=&#39;fancybox-wrapper lazyload-container-unload&#39; data-fancybox=&#39;post-images&#39; href=&#39;https://www.yuyuyuyi1.xyz/wp-content/uploads/2025/09/image-7.png&#39;&gt;
  &lt;img class=&#34;lazyload lazyload-style-1&#34; src=&#34;data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+&#34;  loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;968&#34; height=&#34;426&#34; data-original=&#34;https://www.yuyuyuyi1.xyz/wp-content/uploads/2025/09/image-7.png&#34; src=&#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC&#34; alt=&#34;&#34; class=&#34;wp-image-581&#34;  sizes=&#34;auto, (max-width: 968px) 100vw, 968px&#34; /&gt;
&lt;/div&gt;&lt;/figure&gt; 
&lt;p&gt;stream类型消息队列，使用的是消费者组模式（Consumer Group）&lt;br&gt;
&lt;strong&gt;消费者组(Consumer Group)：将多个消费者划分到一个组中，监听同一个队列，具备以下特点&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    &lt;strong&gt;消息分流&lt;/strong&gt;：队列中的消息会分留给组内的不同消费者，而不是重复消费者，从而加快消息处理的速度
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;消息标识&lt;/strong&gt;：消费者会维护一个标识，记录最后一个被处理的消息，哪怕消费者宕机重启，还会从标识之后读取消息，确保每一个消息都会被消费
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;消息确认&lt;/strong&gt;：消费者获取消息后，消息处于pending状态，并存入一个pending-list，当处理完成后，需要通过XACK来确认消息，标记消息为已处理，才会从pending-list中移除
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码实现和基于JVM的架构差不多，只是需要添加lua脚本：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;-- 如果能够执行添加库存的操作，就将添加消息
redis.call(&#39;XADD&#39;, &#39;stream.orders&#39;, &#39;*&#39;, &#39;userId&#39;, userId, &#39;voucherId&#39;, voucherId, &#39;id&#39;, orderId);&lt;/pre&gt;
&lt;p&gt;线程中执行任务的代码为：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;// 获取消息队列中的订单信息
                    List&amp;lt;MapRecord&amp;lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(
                            Consumer.from(&#34;g1&#34;, &#34;c1&#34;),
                            StreamReadOptions.empty().count(1).block(Duration.ofSeconds(2)),
                            StreamOffset.create(&#34;stream.orders&#34;, ReadOffset.lastConsumed())
                    );
                    // 2、判断消息获取是否成功
                    if (list == null || list.isEmpty()) {
                        // 2.1 消息获取失败，说明没有消息，进入下一次循环获取消息
                        continue;
                    }
                    // 获取成功可以下单&lt;/pre&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;压力测试对比&#34;&gt;压力测试对比&lt;/h3&gt;
&lt;p&gt;压测对比三种情况（普通乐观锁实现的并发访问、基于JVM阻塞队列的异步优化、基于Redis-Stream实现的异步优化）&lt;/p&gt;
&lt;div class=&#34;wp-block-image&#34;&gt;
  &lt;figure class=&#34;aligncenter size-large&#34;&gt;
  &lt;div class=&#39;fancybox-wrapper lazyload-container-unload&#39; data-fancybox=&#39;post-images&#39; href=&#39;https://www.yuyuyuyi1.xyz/wp-content/uploads/2025/09/image-5-1024x249.png&#39;&gt;
    &lt;img class=&#34;lazyload lazyload-style-1&#34; src=&#34;data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+&#34;  loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1024&#34; height=&#34;249&#34; data-original=&#34;https://www.yuyuyuyi1.xyz/wp-content/uploads/2025/09/image-5-1024x249.png&#34; src=&#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC&#34; alt=&#34;&#34; class=&#34;wp-image-571&#34;  sizes=&#34;auto, (max-width: 1024px) 100vw, 1024px&#34; /&gt;
  &lt;/div&gt;&lt;figcaption class=&#34;wp-element-caption&#34;&gt;乐观锁实现的串行版本 qps1000, 吞吐189.9&lt;/figcaption&gt;&lt;/figure&gt;
&lt;/div&gt;
&lt;div class=&#34;wp-block-image&#34;&gt;
  &lt;figure class=&#34;aligncenter size-large&#34;&gt;
  &lt;div class=&#39;fancybox-wrapper lazyload-container-unload&#39; data-fancybox=&#39;post-images&#39; href=&#39;https://www.yuyuyuyi1.xyz/wp-content/uploads/2025/09/image-6-1024x259.png&#39;&gt;
    &lt;img class=&#34;lazyload lazyload-style-1&#34; src=&#34;data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+&#34;  loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1024&#34; height=&#34;259&#34; data-original=&#34;https://www.yuyuyuyi1.xyz/wp-content/uploads/2025/09/image-6-1024x259.png&#34; src=&#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC&#34; alt=&#34;&#34; class=&#34;wp-image-578&#34;  sizes=&#34;auto, (max-width: 1024px) 100vw, 1024px&#34; /&gt;
  &lt;/div&gt;&lt;figcaption class=&#34;wp-element-caption&#34;&gt;基于JVM阻塞队列的异步优化版本 qps1000，吞吐量暴涨到799&lt;/figcaption&gt;&lt;/figure&gt;
&lt;/div&gt;
&lt;div class=&#34;wp-block-image&#34;&gt;
  &lt;figure class=&#34;aligncenter size-large&#34;&gt;
  &lt;div class=&#39;fancybox-wrapper lazyload-container-unload&#39; data-fancybox=&#39;post-images&#39; href=&#39;https://www.yuyuyuyi1.xyz/wp-content/uploads/2025/09/image-8-1024x258.png&#39;&gt;
    &lt;img class=&#34;lazyload lazyload-style-1&#34; src=&#34;data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+&#34;  loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1024&#34; height=&#34;258&#34; data-original=&#34;https://www.yuyuyuyi1.xyz/wp-content/uploads/2025/09/image-8-1024x258.png&#34; src=&#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC&#34; alt=&#34;&#34; class=&#34;wp-image-584&#34;  sizes=&#34;auto, (max-width: 1024px) 100vw, 1024px&#34; /&gt;
  &lt;/div&gt;&lt;figcaption class=&#34;wp-element-caption&#34;&gt;基于Redis_Stream的异步优化版本 qps1000，吞吐量能达到999&lt;/figcaption&gt;&lt;/figure&gt;
&lt;/div&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;点赞排名用户签到与uv统计&#34;&gt;点赞排名、用户签到与UV统计&lt;/h2&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;使用zset实现点赞排名&#34;&gt;使用ZSet实现点赞排名&lt;/h3&gt;
&lt;p&gt;基于Redis的&lt;strong&gt;SortedSet&lt;/strong&gt;结构实现。ZSet 有两种不同的实现，分别是 ziplist 和 skiplist。当有序集合对象同时满足以下两个条件时，使用 ziplist（所有数据（包括元素值、长度信息）存储在&lt;strong&gt;一块连续的内存空间​&lt;/strong&gt;​中，​&lt;strong&gt;​省去了指针​&lt;/strong&gt;​，直接通过&lt;strong&gt;偏移量​&lt;/strong&gt;​访问相邻元素。）：&lt;br&gt;
&lt;strong&gt;ZSet 保存的键值对数量少于 128 个；&lt;br&gt;
每个元素的长度小于 64 字节。&lt;/strong&gt;&lt;br&gt;
如果不满足上述两个条件，那么使用 skiplist 。&lt;/p&gt;
&lt;p&gt;常用的命令：&lt;br&gt;
&lt;code&gt;zadd key value score&lt;/code&gt;，添加value的score&lt;br&gt;
&lt;code&gt;zscore key value&lt;/code&gt;，获取value的score，没有就返回不存在&lt;/p&gt;
&lt;p&gt;默认排序规则：&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    &lt;code&gt;ZRANGE key 0 -1&lt;/code&gt; → 返回所有元素，按&amp;nbsp;&lt;code&gt;score&lt;/code&gt;从小到大排序。升序
  &lt;/li&gt;
  &lt;li&gt;
    &lt;code&gt;ZREVRANGE key 0 -1&lt;/code&gt; → 返回所有元素，按&amp;nbsp;&lt;code&gt;score&lt;/code&gt;从大到小排序。降序
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了实现点赞排名（优先显示最近的点赞用户，类似朋友圈），需要将时间戳作为score（score默认为升序）实现逻辑分为：点赞博客功能与查询点赞功能&lt;/p&gt;
&lt;p&gt;点赞功能：判断用户是否点赞，如果没点赞就zadd，否则就remove.&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;Double score = stringRedisTemplate.opsForZSet().score(key, userId.toString());
        boolean result;
        if (score == null) {
            // 1.1 用户未点赞，点赞数+1
            result = this.update(new LambdaUpdateWrapper&amp;lt;Blog&gt;()
                    .eq(Blog::getId, id)
                    .setSql(&#34;liked = liked + 1&#34;));
            if (result) {
                // 数据库更新成功，更新缓存 zadd key value score
                stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());
            }
        } else {
            // 1.2 用户已点赞，点赞数-1
            result = this.update(new LambdaUpdateWrapper&amp;lt;Blog&gt;()
                    .eq(Blog::getId, id)
                    .setSql(&#34;liked = liked - 1&#34;));
            if (result) {
                // 数据更新成功，更新缓存 zremove key value
                stringRedisTemplate.opsForZSet().remove(key, userId.toString());
            }
        }&lt;/pre&gt;
&lt;p&gt;点赞展示功能：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;// 查询Top5的点赞用户 zrange key 0 4
        String key = BLOG_LIKED_KEY + id;
        Set&amp;lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, 0, 4);&lt;/pre&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;用户签到&#34;&gt;用户签到&lt;/h3&gt;
&lt;p&gt;用户签到功能，用bitmap来实现。Redis中有一种特殊的数据结构，叫Bitmap。&lt;/p&gt;
&lt;p&gt;BitMap的操作命令有：&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    SETBIT：向指定位置（offset）存入一个0或1
  &lt;/li&gt;
  &lt;li&gt;
    GETBIT ：获取指定位置（offset）的bit值
  &lt;/li&gt;
  &lt;li&gt;
    BITCOUNT ：统计BitMap中值为1的bit位的数量
  &lt;/li&gt;
  &lt;li&gt;
    BITFIELD &lt;em&gt;key &lt;/em&gt;GET &lt;em&gt;type offset &lt;/em&gt;：读取指定位数的bit位
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;在 Redis 中，一个 Bitmap 的寻址上限是 2³²（约 42.9 亿）个位，这恰好需要 512MB 的内存来存储，可以说Bitmap最大上限叫啥512MB&lt;/strong&gt;&lt;br&gt;
原因：当使用 &lt;code&gt;SETBIT&lt;/code&gt;命令时，实际上是在操作一个 String 值。下面的 &lt;code&gt;offset&lt;/code&gt;（偏移量）参数的类型是 &lt;strong&gt;整数&lt;/strong&gt;，在Redis的实现中，这个 &lt;code&gt;offset&lt;/code&gt;被定义为 &lt;strong&gt;无符号 32 位整数&lt;/strong&gt;。因此只能寻址 2³²&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;SETBIT key offset value&lt;/pre&gt;
&lt;p&gt;实现代码：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;// 获取当前登录用户
        Long userId = UserHolder.getUser().getId();
        // 获取日期
        LocalDateTime now = LocalDateTime.now();
        // 拼接key
        String keySuffix = now.format(DateTimeFormatter.ofPattern(&#34;:yyyyMM&#34;));
        String key = USER_SIGN_KEY + userId + keySuffix;
        // 获取今天是本月的第几天
        int dayOfMonth = now.getDayOfMonth();
        // 获取本月截止今天为止的所有的签到记录，返回的是一个List, result.get(0)获取到一个十进制的数字
        List&amp;lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(
                key,
                BitFieldSubCommands.create()
                        .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(0)
        );&lt;/pre&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;uv统计&#34;&gt;UV统计&lt;/h3&gt;
&lt;p&gt;UV：全称Unique Visitor，&lt;strong&gt;独立访客量&lt;/strong&gt;。1天内同一个用户多次访问该网站，只记录1次。&lt;br&gt;
PV：全称Page View，&lt;strong&gt;页面访问量或点击量&lt;/strong&gt;，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UV统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到Redis中，数据量会非常恐怖。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Hyperloglog(HLL)是从Loglog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。Redis中的HLL是基于string结构实现的，单个HLL的内存永远小于16kb，内存占用低的令人发指！作为代价，其测量结果是概率性的，有小于**0.81％**的误差。不过对于UV统计来说，这完全可以忽略。&lt;/p&gt;
&lt;p&gt;代码实现如下，保存100W条记录，内存占用增加几乎为0：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;/**
     * 测试 HyperLogLog 实现 UV 统计的误差
     */
    @Test
    public void testHyperLogLog() {
        String[] values = new String[1000];
        // 批量保存100w条用户记录，每一批1个记录
        int j = 0;
        for (int i = 0; i &amp;lt; 1000000; i++) {
            j = i % 1000;
            values[j] = &#34;user_&#34; + i;
            if (j == 999) {
                // 发送到Redis
                stringRedisTemplate.opsForHyperLogLog().add(&#34;hl2&#34;, values);
            }
        }
        // 统计数量
        Long count = stringRedisTemplate.opsForHyperLogLog().size(&#34;hl2&#34;);
        System.out.println(&#34;count = &#34; + count);
    }&lt;/pre&gt;
&lt;h1 class=&#34;wp-block-heading&#34; id=&#34;项目部署&#34;&gt;项目部署&lt;/h1&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    前端：localhost:8080
  &lt;/li&gt;
  &lt;li&gt;
    后端：localhost:8081
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Windows下启动：&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    启动前端：&lt;code&gt;start nginx&lt;/code&gt;，重新加载：&lt;code&gt;nginx -s reload&lt;/code&gt;
  &lt;/li&gt;
  &lt;li&gt;
    启动Redis：启动Redis目录下的&lt;code&gt;start.bat&lt;/code&gt;
  &lt;/li&gt;
  &lt;li&gt;
    启动MySQL
  &lt;/li&gt;
  &lt;li&gt;
    启动后端：Idea直接启动项目
  &lt;/li&gt;
&lt;/ul&gt;

                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/25/springbootvue%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/25/springbootvue%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/" term="项目学习" label="项目学习" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E9%A1%B9%E7%9B%AE/" term="项目" label="项目" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
力扣hot100—子串 3题</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/15/%E5%8A%9B%E6%89%A3hot100-%E5%AD%90%E4%B8%B2-3%E9%A2%98/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/15/%E5%8A%9B%E6%89%A3hot100-%E5%AD%90%E4%B8%B2-3%E9%A2%98/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-09-15T13:25:56&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;h2 class=&#34;wp-block-heading&#34; id=&#34;和为k的子数组&#34;&gt;和为k的子数组&lt;/h2&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;法1暴力&#34;&gt;法1：暴力&lt;/h3&gt;
&lt;p&gt;暴力方法，可以过所有用例，复杂度是O(n²)。&lt;br&gt;
遍历两轮，外层循环的r是右侧区间，内层循环是从r到0，不断的加和并判断。&lt;br&gt;
本质上是遍历从[r-1, r]到[r-2, r]到[r-2, r]这样的区间。&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/15/%E5%8A%9B%E6%89%A3hot100-%E5%AD%90%E4%B8%B2-3%E9%A2%98/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/15/%E5%8A%9B%E6%89%A3hot100-%E5%AD%90%E4%B8%B2-3%E9%A2%98/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;和为k的子数组&#34;&gt;和为k的子数组&lt;/h2&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;法1暴力&#34;&gt;法1：暴力&lt;/h3&gt;
&lt;p&gt;暴力方法，可以过所有用例，复杂度是O(n²)。&lt;br&gt;
遍历两轮，外层循环的r是右侧区间，内层循环是从r到0，不断的加和并判断。&lt;br&gt;
本质上是遍历从[r-1, r]到[r-2, r]到[r-2, r]这样的区间。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;public class Solution {
    public int subarraySum(int[] nums, int k) {
        int count = 0;
        int len = nums.length;
        for(int r = 0; r &amp;lt; len; r++){
            int sum = 0;
            for(int l = r; l&gt;=0; l--){
                sum += nums[l];
                if(sum == k) count++;
            }
        }
        return count;
    }
}
&lt;/pre&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;法2前缀和&#34;&gt;法2：前缀和&lt;/h3&gt;
&lt;p&gt;来自力扣：&lt;/p&gt;
&lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;
  &lt;p&gt;
    一般来说，看到连续子数组元素相关的，基本就是滑动窗口或者前缀和。
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前缀和满足如下操作：&lt;br&gt;
&lt;em&gt;sum[n + 1] = nums[0] + nums[1] + … + nums[n]&lt;/em&gt;&lt;br&gt;
&lt;em&gt;nums[n] = sum[n + 1] – sum[n]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;用一个哈希表 &lt;em&gt;map&lt;/em&gt; 统计 &lt;em&gt;sum&lt;/em&gt;[&lt;em&gt;j&lt;/em&gt;] 的个数。哈希表的 key 是 &lt;em&gt;sum&lt;/em&gt;[&lt;em&gt;j&lt;/em&gt;]，value 是值为 &lt;em&gt;sum&lt;/em&gt;[&lt;em&gt;j&lt;/em&gt;] 的前缀和的个数。&lt;br&gt;
算法的过程即从小到大遍历前缀和数组，遍历的过程维护哈希表，通过判断_target_存在的个数，即可加和出结果。&lt;/p&gt;
&lt;p&gt;引用牛客的题解，注明为什么这样可以不重不漏：&lt;/p&gt;
&lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;
  &lt;p&gt;
    问：为什么这样做可以不重不漏地计算？&lt;br /&gt;答：暴力做法是，外层循环枚举 j，内层循环枚举 i，如果 s[j]−s[i]=k，那么答案加一。我们保留了「外层循环枚举 j」这个过程，把内层循环用哈希表优化成了 O(1)，所以本质是对暴力算法的哈希表优化。既然暴力算法是不重不漏地计算，那么优化做法也是不重不漏地计算。&lt;br /&gt;作者：灵茶山艾府&lt;br /&gt;
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;public class Solution {
    public int subarraySum(int[] nums, int k) {
        // 先维护出前缀和数组
        int[] preSum = new int[nums.length + 1];
        for(int i = 0; i &amp;lt; nums.length; i++){
            preSum[i+1] = nums[i] + preSum[i];
        }
        
        // 题目要求的目标 可以转化为求s[j] - s[i] = k 满足的解个数
        // 可以借助哈希表存储已经遍历过的元素，即出现过的 preSum[i]
        // 当我们遍历到 preSum[j] 的时候，我们就是要找在这之前，有多少个 preSum[i]满足等于preSum[j] - k
        int res = 0;
        HashMap&amp;lt;Integer, Integer&gt; map = new HashMap&amp;lt;&gt;();
        for(int sj:preSum){
            int target = sj - k; // 要找的目标是这个
            if(map.containsKey(target)){ //如果存在
                res+= map.get(target);
            }
            // 将当前前缀和存入map（如果已存在则次数+1，否则初始化为1）
            map.put(sj, map.getOrDefault(sj, 0) + 1);
        }
        return res;
    }
}
&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;滑动窗口的最大值&#34;&gt;滑动窗口的最大值&lt;/h2&gt;
&lt;p&gt;使用单调队列，摘自牛客：&lt;/p&gt;
&lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;
  &lt;p&gt;
    窗口对应的数据结构为 双端队列 ，本题使用 单调队列 即可解决以上问题。遍历数组时，每轮保证单调队列 &lt;em&gt;deque &lt;/em&gt;：&lt;br /&gt;&lt;em&gt;deque &lt;/em&gt;内仅包含窗口内的元素 ⇒ 每轮窗口滑动移除了元素 &lt;em&gt;nums[i−1]&lt;/em&gt; ，需将 &lt;em&gt;deque &lt;/em&gt;内的对应元素一起删除。&lt;br /&gt;&lt;em&gt;deque&lt;/em&gt; 内的元素非严格递减 ⇒ 每轮窗口滑动添加了元素 &lt;em&gt;nums[j+1]&lt;/em&gt; ，需将 deque 内所有 &lt;em&gt;&lt;nums[j+1]&lt;/em&gt; 的元素删除。
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if(nums == null || nums.length &amp;lt; 2) return nums;
        Deque&amp;lt;Integer&gt; deq = new LinkedList&amp;lt;&gt;();
        int[] res = new int[nums.length - k + 1];
        for(int i = 0; i &amp;lt; nums.length; i++){
            // 如果队尾的数 小于当前数 那就让队尾的数出队 保持住队列所有数字都≥当前数
            while(!deq.isEmpty() &amp;&amp; nums[deq.peekLast()] &amp;lt; nums[i]){
                deq.pollLast();
            }
            // 处理之后 队头的下标一定会是最大值
            deq.addLast(i);

            // 如果队头已经不在窗口内了 要去掉
            if(deq.peekFirst() &amp;lt; i - k + 1){
                deq.pollFirst();
            }
            if(i - k + 1 &gt;= 0){
                res[i-k + 1] = nums[deq.peekFirst()];
            }
        }
        return res;
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;最小覆盖子串&#34;&gt;最小覆盖子串&lt;/h2&gt;
&lt;p&gt;滑动窗口问题。我们要用一个窗口 [l, r] 扫描 s，在窗口内维护 t 的字符需求情况。滑动窗口方法：&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    先统计 t 中每个字符的数量，存入数组/哈希表 cnt。
  &lt;/li&gt;
  &lt;li&gt;
    用变量 k 表示当前还需要多少字符。
  &lt;/li&gt;
  &lt;li&gt;
    先扩展右边界，循环迭代k&amp;#8211;，和cnt&amp;#8211;，直到k=0，说明窗口扩大完毕，开始考虑缩小。
  &lt;/li&gt;
  &lt;li&gt;
    k=0，先判断bestleft和bestlen的情况（当前窗口是否比上一个窗口更好）。
  &lt;/li&gt;
  &lt;li&gt;
    l++，对应的cnt需要++，同时需要维护是否k需要++。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public String minWindow(String s, String t) {
        // 如果s和t相等，直接返回s
        if (s.equals(t)) return s;
        
        int n = s.length();
        int k = t.length(); // k表示还需要匹配的字符总数
        
        // 使用数组记录t中每个字符的需求量
        int[] cnt = new int[128];
        
        // 统计t中每个字符的出现次数
        for (char x : t.toCharArray()) {
            cnt[x]++;
        }
        
        int left = 0, right = 0; // 滑动窗口的左右指针
        int bestLen = Integer.MAX_VALUE; // 记录最小窗口长度
        int bestStart = -1; // 记录最小窗口的起始位置
        
        // 开始滑动窗口遍历
        while (right &amp;lt; n) {
            char rightChar = s.charAt(right);
            
            // 减少当前字符的需求量
            cnt[rightChar]--;
            
            // 如果减少后需求量仍大于等于0，说明这个字符是t中需要的
            // 成功匹配了一个字符，k减1
            if (cnt[rightChar] &gt;= 0) {
                k--;
            }
            
            // 当k==0时，说明当前窗口[l, r]已经包含了t的所有字符
            // 尝试收缩左边界来寻找更小的窗口
            while (k == 0) {
                // 计算当前窗口长度
                int currentLen = right - left + 1;
                
                // 如果当前窗口更小，更新最优解
                if (currentLen &amp;lt; bestLen) {
                    bestLen = currentLen;
                    bestStart = left;
                }
                
                char leftChar = s.charAt(left);
                
                // 恢复左边界字符的需求量
                cnt[leftChar]++;
                
                // 如果恢复后需求量大于0，说明移走了一个关键字符
                // 窗口不再满足包含t的所有字符，k加1
                if (cnt[leftChar] &gt; 0) {
                    k++;
                }
                
                // 左指针右移，收缩窗口
                left++;
            }
            
            // 右指针右移，扩展窗口
            right++;
        }
        
        // 如果找到了符合条件的窗口，返回子串；否则返回空字符串
        return bestStart == -1 ? &#34;&#34; : s.substring(bestStart, bestStart + bestLen);
    }
}&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/15/%E5%8A%9B%E6%89%A3hot100-%E5%AD%90%E4%B8%B2-3%E9%A2%98/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/15/%E5%8A%9B%E6%89%A3hot100-%E5%AD%90%E4%B8%B2-3%E9%A2%98/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%8A%9B%E6%89%A3hot100/" term="力扣Hot100" label="力扣Hot100" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" term="字符串" label="字符串" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A8%A1%E6%8B%9F/" term="模拟" label="模拟" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E9%98%9F%E5%88%97/" term="队列" label="队列" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
力扣hot100—滑动窗口 2题</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/12/%E5%8A%9B%E6%89%A3hot100-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-2%E9%A2%98/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/12/%E5%8A%9B%E6%89%A3hot100-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-2%E9%A2%98/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-09-12T13:46:34&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;h2 class=&#34;wp-block-heading&#34; id=&#34;无重复字符的最长子串&#34;&gt;无重复字符的最长子串&lt;/h2&gt;
&lt;p&gt;用集合Set存已存在的数字，移动l与r指针。每次移动右指针，判断字符是否存在，如果存在就必须一直移动左指针，并弹出左指针指着的字符，直到没有重复，再移动右指针。&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/12/%E5%8A%9B%E6%89%A3hot100-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-2%E9%A2%98/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/12/%E5%8A%9B%E6%89%A3hot100-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-2%E9%A2%98/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;无重复字符的最长子串&#34;&gt;无重复字符的最长子串&lt;/h2&gt;
&lt;p&gt;用集合Set存已存在的数字，移动l与r指针。每次移动右指针，判断字符是否存在，如果存在就必须一直移动左指针，并弹出左指针指着的字符，直到没有重复，再移动右指针。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public int lengthOfLongestSubstring(String s) {
        if(s.length() &amp;lt;= 1) return s.length();
        HashSet&amp;lt;Character&gt; set = new HashSet&amp;lt;&gt;();
        //用指针滑动窗口 放到map里 并不断判断
        int sum = 1;
        set.add(s.charAt(0));
        int l = 0;
        int r = 1;
        int temp = 1;
        while(r &amp;lt; s.length() &amp;&amp; l &amp;lt; r){
            char c = s.charAt(r);
            while(set.contains(c)){ // 如果字符存在 需要一直移动左指针直到删掉重复的
                set.remove(s.charAt(l));
                l++;
            }
            // 直到字符不存在 
            set.add(c);
            sum = Math.max(sum, set.size());
            r++;
        }
        return sum;
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;找到字符串中所有字母异位词&#34;&gt;找到字符串中所有字母异位词&lt;/h2&gt;
&lt;p&gt;没想出来，参考力扣题解。&lt;/p&gt;
&lt;p&gt;在字符串 &lt;em&gt;s&lt;/em&gt; 中构造一个长度为与字符串 &lt;em&gt;p&lt;/em&gt; 的长度相同的滑动窗口，并在滑动中维护窗口中每种字母的数量。可以使用数组来存储字符串 &lt;em&gt;p&lt;/em&gt; 和滑动窗口中每种字母的数量。&lt;/p&gt;
&lt;p&gt;其实一开始的想法也是这样，滑动窗口并比较窗口和p是否相同，难点在于比较如果是遍历比较的话，应该会超时，题解使用了数组计数进行比较，很巧妙。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public List&amp;lt;Integer&gt; findAnagrams(String s, String p) {
        int slen = s.length();
        int plen = p.length();
        if(slen &amp;lt; plen) return new ArrayList&amp;lt;Integer&gt;();
        
        List&amp;lt;Integer&gt; res = new ArrayList&amp;lt;&gt;();
        int[] scount = new int[26];
        int[] pcount = new int[26];

        for(int i = 0; i &amp;lt; plen; i++){
            scount[s.charAt(i) - &#39;a&#39;]++;
            pcount[p.charAt(i) - &#39;a&#39;]++;
        }

        if(Arrays.equals(scount, pcount)) res.add(0);

        for(int i = 0; i &amp;lt; slen - plen; i++){
            // 对每个窗口 维护字母
            scount[s.charAt(i) - &#39;a&#39;]--;
            scount[s.charAt(i+plen) - &#39;a&#39;]++;
            if(Arrays.equals(scount, pcount)){
                res.add(i+1);
            }
        }
        return res;
    }
}&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/12/%E5%8A%9B%E6%89%A3hot100-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-2%E9%A2%98/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/12/%E5%8A%9B%E6%89%A3hot100-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-2%E9%A2%98/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%8A%9B%E6%89%A3hot100/" term="力扣Hot100" label="力扣Hot100" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/" term="双指针算法" label="双指针算法" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" term="滑动窗口" label="滑动窗口" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
力扣hot100—双指针 接雨水</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/10/%E5%8A%9B%E6%89%A3hot100-%E5%8F%8C%E6%8C%87%E9%92%88-%E6%8E%A5%E9%9B%A8%E6%B0%B4/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/10/%E5%8A%9B%E6%89%A3hot100-%E5%8F%8C%E6%8C%87%E9%92%88-%E6%8E%A5%E9%9B%A8%E6%B0%B4/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-09-10T05:19:10&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;h2 class=&#34;wp-block-heading&#34; id=&#34;模拟法&#34;&gt;模拟法&lt;/h2&gt;
&lt;p&gt;最简单的方式，模拟，如果面试遇到原题完全可以使用这种方法，leetcode只有4个用例过不了。&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/10/%E5%8A%9B%E6%89%A3hot100-%E5%8F%8C%E6%8C%87%E9%92%88-%E6%8E%A5%E9%9B%A8%E6%B0%B4/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/10/%E5%8A%9B%E6%89%A3hot100-%E5%8F%8C%E6%8C%87%E9%92%88-%E6%8E%A5%E9%9B%A8%E6%B0%B4/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;模拟法&#34;&gt;模拟法&lt;/h2&gt;
&lt;p&gt;最简单的方式，模拟，如果面试遇到原题完全可以使用这种方法，leetcode只有4个用例过不了。&lt;/p&gt;
&lt;p&gt;模拟的求水方式是一层一层求，遍历每个位置，如果当前的高度小于 i，并且两边有高度大于等于 i 的，说明这个地方一定有水，水就可以加1。&lt;/p&gt;
&lt;p&gt;如果求高度为 i 的水，首先用一个变量 temp 保存当前累积的水，初始化为0。从左到右遍历墙的高度，&lt;strong&gt;遇到高度低于i的，说明可以存水&lt;/strong&gt;，&lt;strong&gt;遇到高度大于等于 i 的时候，就需要把记录的temp加到总和sum中，并重置temp，表示这一个小凹槽的水更新完毕了&lt;/strong&gt;。然后继续循环。时间复杂度为O(n*m)。&lt;/p&gt;
&lt;p&gt;代码的关键就是 &lt;code&gt;isStart;&lt;/code&gt; 用它可以巧妙处理height[0]为0的影响，只有第一次遇到height[j]大于高度i的情况，才能将isStart置为true 开始用temp记录积累的水量。&lt;/p&gt;
&lt;div class=&#34;wp-block-image&#34;&gt;
  &lt;figure class=&#34;aligncenter size-full&#34;&gt;
  &lt;div class=&#39;fancybox-wrapper lazyload-container-unload&#39; data-fancybox=&#39;post-images&#39; href=&#39;http://117.72.66.48/wp-content/uploads/2025/09/image.png&#39;&gt;
    &lt;img class=&#34;lazyload lazyload-style-1&#34; src=&#34;data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+&#34;  loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;661&#34; height=&#34;284&#34; data-original=&#34;http://117.72.66.48/wp-content/uploads/2025/09/image.png&#34; src=&#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC&#34; alt=&#34;&#34; class=&#34;wp-image-404&#34;  sizes=&#34;auto, (max-width: 661px) 100vw, 661px&#34; /&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/div&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public int trap(int[] height) {
    int sum = 0;
    int max = getMax(height);//找到最大的高度，以便遍历。
    for (int i = 1; i &amp;lt;= max; i++) { // 从第i层开始遍历
        boolean isStart = false; //标记是否能够开始更新 temp
        int temp_sum = 0;
        for (int j = 0; j &amp;lt; height.length; j++) {
            if (isStart &amp;&amp; height[j] &amp;lt; i) {
                temp_sum++;
            }
            if (height[j] &gt;= i) {
                // 第一次遇到&gt;=i的区块时 就将isStart置true 表示墙壁封闭了 temp从此开始可以更新了
                isStart = true;
                sum += temp_sum;
                temp_sum = 0;  // 封闭了 需要将temp_sum置为0 重新开始计数
            }
        }
    }
    return sum;
}
private int getMax(int[] height) {
		int max = 0;
		for (int i = 0; i &amp;lt; height.length; i++) {
			if (height[i] &gt; max) {
				max = height[i];
			}
		}
		return max;
}

}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;最直接且简单的方式&#34;&gt;最直接且简单的方式&lt;/h2&gt;
&lt;p&gt;参考自力扣题解：&lt;a href=&#34;https://leetcode.cn/problems/trapping-rain-water/solutions/3732547/shuang-onfu-za-du-wu-xu-shuang-zhi-zhen-hkrbi&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://leetcode.cn/problems/trapping-rain-water/solutions/3732547/shuang-onfu-za-du-wu-xu-shuang-zhi-zhen-hkrbi&lt;/a&gt;，是最清晰且最简单的做法。&lt;br&gt;
视频解析：【毒瘤面试题：接雨水】 &lt;a href=&#34;https://www.bilibili.com/video/BV1TSPeeGEHC/?share_source=copy_web&amp;amp;vd_source=678f52c7135e8109c9d58a20f6e13fbc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.bilibili.com/video/BV1TSPeeGEHC/?share_source=copy_web&amp;amp;vd_source=678f52c7135e8109c9d58a20f6e13fbc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有点类似前缀和算法。&lt;/p&gt;
&lt;p&gt;对于每个位置i（不包含最左和最右），该位置能接住的雨水量取决于其左侧最高柱子和右侧最高柱子中的较小值，减去当前位置的高度。 &lt;em&gt;&lt;strong&gt;即：雨水量=min(左侧最高,右侧最高)−当前高度&lt;/strong&gt;&lt;/em&gt;。&lt;br&gt;
只需要维护两个数组，分别存&lt;strong&gt;对于位置i左侧最高的和右侧最高的值即可。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public int trap(int[] height) {
        int len = height.length;
        if(len &amp;lt;= 2) return 0;

        int[] leftH = new int[len];
        int[] rightH = new int[len];

        // 需要初始化
        leftH[0] = height[0]; 
        rightH[len-1] = height[len-1];

        for(int i = 1; i &amp;lt; len; i++){
            leftH[i] = Math.max(leftH[i-1], height[i]); //左边的最大值
        }
        for(int i = len - 2; i &gt;= 0; i--){
            rightH[i] = Math.max(rightH[i+1], height[i]);  //求出右边的最大值
        }
        int sum = 0;
        for(int i = 1; i &amp;lt; len -1; i++){
            // 每一列的雨水数 = max(0, 左右侧的最小高度-自己的高度)
            sum += Math.max(0, Math.min(leftH[i], rightH[i]) -height[i]);
        }
        return sum;
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;双指针方法&#34;&gt;双指针方法&lt;/h2&gt;
&lt;p&gt;感觉像是上一中算法的改进版本，复杂度可以到0n级别。一遍遍历，用两个变量维护当前位置的左侧最大值和右侧最大值。&lt;/p&gt;
&lt;p&gt;left指针与right指针，分别关注左侧区域与右侧区域。&lt;br&gt;
例如，如果 &lt;code&gt;leftMax &amp;lt; rightMax&lt;/code&gt;，说明：&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    左边的最大高度是限制因素（短板在左边）
  &lt;/li&gt;
  &lt;li&gt;
    右边已经有足够高的&amp;#8221;墙&amp;#8221;来拦住水
  &lt;/li&gt;
  &lt;li&gt;
    所以可以安全地计算​&lt;strong&gt;​左边​&lt;/strong&gt;​当前位置的积水量
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;反之亦然：如果 &lt;code&gt;rightMax &amp;lt;= leftMax&lt;/code&gt;，说明右边的最大高度是限制因素，可以安全计算​&lt;strong&gt;​右边​&lt;/strong&gt;​的积水量。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public int trap(int[] height) {
        int ans = 0;
        int preMax = 0; // 前缀最大值，随着左指针 left 的移动而更新
        int sufMax = 0; // 后缀最大值，随着右指针 right 的移动而更新
        int left = 0;
        int right = height.length - 1;

        while (left &amp;lt; right) {
            preMax = Math.max(preMax, height[left]);
            sufMax = Math.max(sufMax, height[right]);
            if (preMax &amp;lt; sufMax) {
                ans += preMax - height[left];
                left++;
            } else {
                ans += sufMax - height[right];
                right--;
            }
        }

        return ans;
    }
}&lt;/pre&gt;

                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/10/%E5%8A%9B%E6%89%A3hot100-%E5%8F%8C%E6%8C%87%E9%92%88-%E6%8E%A5%E9%9B%A8%E6%B0%B4/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/10/%E5%8A%9B%E6%89%A3hot100-%E5%8F%8C%E6%8C%87%E9%92%88-%E6%8E%A5%E9%9B%A8%E6%B0%B4/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%8A%9B%E6%89%A3hot100/" term="力扣Hot100" label="力扣Hot100" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/" term="双指针算法" label="双指针算法" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A8%A1%E6%8B%9F/" term="模拟" label="模拟" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
力扣hot100—双指针 4题</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/08/%E5%8A%9B%E6%89%A3hot100-%E5%8F%8C%E6%8C%87%E9%92%88-4%E9%A2%98/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/08/%E5%8A%9B%E6%89%A3hot100-%E5%8F%8C%E6%8C%87%E9%92%88-4%E9%A2%98/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-09-08T11:29:32&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;h2 class=&#34;wp-block-heading&#34; id=&#34;移动0&#34;&gt;移动0&lt;/h2&gt;
&lt;p&gt;感觉算是简单题，但是一时没想出来。&lt;br&gt;
思路其实就是两步：第一步把非0的数字全挤到左边，同时要记录序列的末尾（用第二个指针），第二步把序列末尾到数组结尾的这一区间全部填。&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/08/%E5%8A%9B%E6%89%A3hot100-%E5%8F%8C%E6%8C%87%E9%92%88-4%E9%A2%98/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/08/%E5%8A%9B%E6%89%A3hot100-%E5%8F%8C%E6%8C%87%E9%92%88-4%E9%A2%98/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;移动0&#34;&gt;移动0&lt;/h2&gt;
&lt;p&gt;感觉算是简单题，但是一时没想出来。&lt;br&gt;
思路其实就是两步：第一步把非0的数字全挤到左边，同时要记录序列的末尾（用第二个指针），第二步把序列末尾到数组结尾的这一区间全部填。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public void moveZeroes(int[] nums) {
        if(nums.length &amp;lt;= 1) return;
        int cur = 0;
        for(int i = 0; i &amp;lt; nums.length; i++){
            if(nums[i] != 0){ // 不等于0就填左边
                nums[cur] = nums[i];
                cur++;
            }
        }
        for(; cur &amp;lt; nums.length; cur++){
            nums[cur] = 0;
        }
        return;
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;盛水最多的容器&#34;&gt;盛水最多的容器&lt;/h2&gt;
&lt;p&gt;感觉有一点点思路，但是不清晰。看题解：&lt;br&gt;
&lt;strong&gt;在初始时，左右指针分别指向数组的左右两端，每次迭代移动一个高度较小的指针。&lt;/strong&gt;&lt;br&gt;
感觉思路挺简单的，一开始想不出来不应该。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public int maxArea(int[] height) {
        int res = 0;
        int left = 0;
        int right = height.length - 1;
        while(left &amp;lt; right){
            int h = Math.min(height[left], height[right]);
            res = Math.max(res, h * (right - left));
            // 三目运算符 需要赋值
            int dummy = height[left] &gt; height[right] ? right-- : left++;
        }
        return res;
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;三数之和&#34;&gt;三数之和&lt;/h2&gt;
&lt;p&gt;第一个版本，错误，只过了几个用例就超出时间限制，二分写的不对。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public List&amp;lt;List&amp;lt;Integer&gt;&gt; threeSum(int[] nums) {
        Arrays.sort(nums);
        Set&amp;lt;List&amp;lt;Integer&gt;&gt; s = new HashSet&amp;lt;&gt;();
        for(int i = 0; i &amp;lt; nums.length; i++){
            for(int j = nums.length - 1; j &gt; i; j--){
                int k = (i + j) / 2;
                while(k != i &amp;&amp; k != j){
                    int sum = nums[k] + nums[i] + nums[j];
                    if(sum == 0){
                        s.add(Arrays.asList(nums[i], nums[j], nums[k]));
                        break;
                    }
                    else if(sum &gt; 0){ // 说明k偏大了
                        k--;
                    }else{
                        k++;
                    }
                }
            }
        }
        return new ArrayList&amp;lt;&gt;(s);
    }
}&lt;/pre&gt;
&lt;p&gt;GPT4o的二分法，过了100%用例&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public List&amp;lt;List&amp;lt;Integer&gt;&gt; threeSum(int[] nums) {
        Arrays.sort(nums);
        Set&amp;lt;List&amp;lt;Integer&gt;&gt; s = new HashSet&amp;lt;&gt;();
        for (int i = 0; i &amp;lt; nums.length - 2; i++) {
            // 跳过重复的元素
            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {
                continue;
            }
            // 在剩余数组中进行二分查找
            for (int j = i + 1; j &amp;lt; nums.length - 1; j++) {
                int target = -(nums[i] + nums[j]);
                // 使用二分查找来查找合适的k
                int left = j + 1, right = nums.length - 1;
                while (left &amp;lt;= right) {
                    int mid = left + (right - left) / 2;
                    if (nums[mid] == target) {
                        s.add(Arrays.asList(nums[i], nums[j], nums[mid]));
                        break;
                    } else if (nums[mid] &amp;lt; target) {
                        left = mid + 1;
                    } else {
                        right = mid - 1;
                    }
                }
            }
        }
        return new ArrayList&amp;lt;&gt;(s);
    }
}
&lt;/pre&gt;
&lt;p&gt;真正的官方做法应该是排序+双指针。&lt;br&gt;
因为题解容忍的时间复杂度能够达到On²，首先将数组排序，便于处理。&lt;br&gt;
之后，可以从左往右移动i，并且在“i到nums.length“区间内，寻找另外两个数，记为l与r，l与r相向移动，过程中仍然需要注意去重。这个的解法时间复杂度更低。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public List&amp;lt;List&amp;lt;Integer&gt;&gt; threeSum(int[] nums) {
        List&amp;lt;List&amp;lt;Integer&gt;&gt; res = new ArrayList&amp;lt;&gt;();
        int len = nums.length;
        if(nums == null || len &amp;lt; 3) return res;
        // 排序
        Arrays.sort(nums);
        for(int i = 0; i &amp;lt; len; i++){
            // 数组排序了 如果i也大于0 就没必要考虑后面的了
            if(nums[i] &gt; 0) break;
            
            //去重
            if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;
            int l = i + 1;
            int r = len - 1;
            // 比较的就是 i, l, r三数 i需要固定 l和r可以变动
            while(l &amp;lt; r){
                int sum = nums[i] + nums[l] + nums[r];
                if(sum == 0){
                    res.add(Arrays.asList(nums[i], nums[l], nums[r]));
                    // 继续去重
                    while(l &amp;lt; r &amp;&amp; nums[l] == nums[l + 1]) l++;
                    while(l &amp;lt; r &amp;&amp; nums[r] == nums[r - 1]) r--;
                    l++;
                    r--;
                }else if(sum &amp;lt; 0){
                    l++;
                }else if(sum &gt; 0){
                    r--;
                }
            }
        }
        return res;
    }
}
&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/08/%E5%8A%9B%E6%89%A3hot100-%E5%8F%8C%E6%8C%87%E9%92%88-4%E9%A2%98/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/08/%E5%8A%9B%E6%89%A3hot100-%E5%8F%8C%E6%8C%87%E9%92%88-4%E9%A2%98/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%8A%9B%E6%89%A3hot100/" term="力扣Hot100" label="力扣Hot100" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/" term="双指针算法" label="双指针算法" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
力扣hot100—哈希 3题</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/07/1/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/07/1/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-09-07T13:19:04&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;h2 class=&#34;wp-block-heading&#34; id=&#34;两数之和&#34;&gt;两数之和&lt;/h2&gt;
&lt;p&gt;常规方法，遍历两次，复杂度是0n²的，无法接受。用哈希表， &lt;code&gt;Map&amp;lt;Integer, Integer&amp;gt; hash = new HashMap&amp;lt;&amp;gt;()&lt;/code&gt;，HashMap可以做到O(1)复杂度查数字。&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/07/1/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/07/1/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;两数之和&#34;&gt;两数之和&lt;/h2&gt;
&lt;p&gt;常规方法，遍历两次，复杂度是0n²的，无法接受。用哈希表， &lt;code&gt;Map&amp;lt;Integer, Integer&amp;gt; hash = new HashMap&amp;lt;&amp;gt;()&lt;/code&gt;，HashMap可以做到O(1)复杂度查数字。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;java&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;// 常规方法 遍历两次
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for(int i = 0; i &amp;lt; nums.length; i++){
            for(int j = 0; j &amp;lt; nums.length; j++){
                if(i == j) continue;
                if(nums[i] + nums[j] == target){
                    return new int[]{i, j};
                }
            }
        }
        return new int[0];
    }
}&lt;/pre&gt;
&lt;p&gt;注意，&lt;strong&gt;先检查后存入​&lt;/strong&gt;​：确保不会匹配到自己。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;java&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;// 哈希表解法
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map&amp;lt;Integer,Integer&gt; hash = new HashMap&amp;lt;&gt;();
        for(int i = 0; i &amp;lt; nums.length; i++){
            int needed = target - nums[i];
            if(hash.get(needed) != null &amp;&amp; hash.get(needed) != i){
                return new int[]{hash.get(needed), i};
            }
            hash.put(nums[i], i);  // 先检查 再放入hash 确保不会匹配到自己
        }
        return new int[0];
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;字母异位词分组&#34;&gt;字母异位词分组&lt;/h2&gt;
&lt;p&gt;用字符串排序+哈希，字符串排序要转换成字符数组。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;java&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public List&amp;lt;List&amp;lt;String&gt;&gt; groupAnagrams(String[] strs) {
        List&amp;lt;List&amp;lt;String&gt;&gt; list = new ArrayList&amp;lt;&gt;();
        HashMap&amp;lt;String, List&amp;lt;String&gt;&gt; hash = new HashMap&amp;lt;&gt;();  // key为sort后的字符串 value为异位词的list
        // 直观思路 字符串排序对比
        for(int i = 0; i &amp;lt; strs.length; ++i){
            String temp = strs[i];
            char[] s = temp.toCharArray();
            Arrays.sort(s); // 转化成char才能sort
            String stemp = new String(s); // 转化回String

            if(hash.containsKey(stemp) == false){ // 为空 创建
                List&amp;lt;String&gt; keyString = new ArrayList&amp;lt;&gt;();
                keyString.add(temp);
                hash.put(stemp, keyString);
            }else{
                List&amp;lt;String&gt; keyString = hash.get(stemp);
                keyString.add(temp);
                hash.put(stemp, keyString);
            }
        }
        // 最后把hash中所有的元素取出来放到list里
        for(List&amp;lt;String&gt; value : hash.values()){
            list.add(value);
        }
        return list;
    }
}&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;最长连续序列&#34;&gt;最长连续序列&lt;/h2&gt;
&lt;p&gt;用HashSet，所有的数装入set，然后一个个遍历，如果当前数n，set中存在n-1就continue，否则就循环判断是否存在n+1，n+2…&lt;/p&gt;
&lt;p&gt;版本1，超时，10个用例没过：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;//  版本1 有10个用例超时 最坏情况下会On²
class Solution {
    public int longestConsecutive(int[] nums) {
        if(nums.length == 0) return 0;
        HashSet&amp;lt;Integer&gt; set = new HashSet&amp;lt;&gt;();
        int res = 0;
        for(int i = 0; i &amp;lt; nums.length; i++){
            set.add(nums[i]);
        }
        for(int i = 0; i &amp;lt; nums.length; i++){
            int cnt = 1;
            int temp = nums[i];
            while(set.contains(temp + 1)){
                cnt++;
                temp++;
            }
            res = Math.max(res, cnt);
        }
        return res;
    }
}&lt;/pre&gt;
&lt;p&gt;上述代码对&lt;strong&gt;每个数字&lt;/strong&gt;都尝试向后查找连续序列，有很多重复查找。需要剪掉一些无用的计算，加一句**&lt;code&gt;if (!set.contains(num - 1))&lt;/code&gt;** ，保证序列从最小值开始技术。&lt;/p&gt;
&lt;p&gt;版本2， 还是有4个用例没过，需要再优化。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public int longestConsecutive(int[] nums) {
        if(nums.length == 0) return 0;
        HashSet&amp;lt;Integer&gt; set = new HashSet&amp;lt;&gt;();
        int res = 0;
        for(int i = 0; i &amp;lt; nums.length; i++){
            set.add(nums[i]);
        }
        for(int i = 0; i &amp;lt; nums.length; i++){
            int cnt = 1;
            int temp = nums[i];
            if(!set.contains(temp - 1)){
                while(set.contains(temp + 1)){
                    cnt++;
                    temp++;
                }
                res = Math.max(res, cnt);
            }
        }
        return res;
    }
}&lt;/pre&gt;
&lt;p&gt;版本3，不遍历nums数组而是遍历哈希集合（已去重），这样可以避免重复元素遍历！&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
    public int longestConsecutive(int[] nums) {
        if(nums.length == 0) return 0;
        HashSet&amp;lt;Integer&gt; set = new HashSet&amp;lt;&gt;();
        int res = 0;
        for(int i = 0; i &amp;lt; nums.length; i++){
            set.add(nums[i]);
        }
        for(int v : set){ //遍历哈希集合而非数组！
            if(set.contains(v - 1)){
                continue;
            }
            int temp = v;
            int cnt = 1;
            while(set.contains(temp + 1)){
                cnt++;
                temp++;
            }
            res = Math.max(cnt, res);
        }
        return res;
    }
}&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/07/1/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/09/07/1/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%8A%9B%E6%89%A3hot100/" term="力扣Hot100" label="力扣Hot100" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%93%88%E5%B8%8C/" term="哈希" label="哈希" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No67.剪绳子</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no67-%E5%89%AA%E7%BB%B3%E5%AD%90/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no67-%E5%89%AA%E7%BB%B3%E5%AD%90/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-06-19T06:58:16&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;&lt;strong&gt;法1：动态规划&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先贴个递归版本:&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;int cutRope(int n) {
    // write code here
    if(n &amp;lt;= 4) return n;
    int res = 0;
    for(int i = 1; i &amp;lt; n; i++){
        // 从i=1开始 表示第一刀剪下的长度
        res = max(res, max(cutRope(n-i)*i, i *(n-i)));
    }
    return res;
}&lt;/pre&gt;
&lt;p&gt;递归的化，用&lt;code&gt;dp[i]&lt;/code&gt;表示&lt;strong&gt;长度为i的绳子可以被剪出来的最大乘积&lt;/strong&gt;。 遍历维护从5到n的dp数组，用j来表示减下来的长度。&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no67-%E5%89%AA%E7%BB%B3%E5%AD%90/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no67-%E5%89%AA%E7%BB%B3%E5%AD%90/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;&lt;strong&gt;法1：动态规划&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先贴个递归版本:&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;int cutRope(int n) {
    // write code here
    if(n &amp;lt;= 4) return n;
    int res = 0;
    for(int i = 1; i &amp;lt; n; i++){
        // 从i=1开始 表示第一刀剪下的长度
        res = max(res, max(cutRope(n-i)*i, i *(n-i)));
    }
    return res;
}&lt;/pre&gt;
&lt;p&gt;递归的化，用&lt;code&gt;dp[i]&lt;/code&gt;表示&lt;strong&gt;长度为i的绳子可以被剪出来的最大乘积&lt;/strong&gt;。 遍历维护从5到n的dp数组，用j来表示减下来的长度。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;int cutRope(int n) {
        // write code here
        if(n &amp;lt;= 4) return n;
        vector&amp;lt;int&gt; dp(n+10);
        dp[1] = 1;
        dp[2] = 2;
        dp[3] = 3;
        dp[4] = 4;
        for(int i = 5; i&amp;lt;=n; i++){
            //i维护绳子长度
            for(int j = 1; j &amp;lt; i; j++){
                //j表示剪掉的长度
                dp[i] = max(dp[i], max(dp[i-j] * j, j *(i-j)));
            }
        }
        return dp[n];

    }&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;法2：数学结论&lt;/strong&gt;&lt;br&gt;
不断将绳子拆成每段长度为3，最后的结果就是最大的。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    int cutRope(int number) {
        //不超过3直接计算
        if(number &amp;lt;= 3) 
            return number - 1;
        int res = 1;
        while(number &gt; 4){
            //连续乘3
            res *= 3; 
            number -= 3; 
        }
        return res * number;
    }
};&lt;/pre&gt;
&lt;p class=&#34;has-text-align-center&#34;&gt;
  &lt;strong&gt;2025年06月19日 14:50:53：完结&lt;/strong&gt;
&lt;/p&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no67-%E5%89%AA%E7%BB%B3%E5%AD%90/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no67-%E5%89%AA%E7%BB%B3%E5%AD%90/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/dp/" term="DP" label="DP" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No66.机器人的运动范围</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no66-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no66-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-06-19T06:57:02&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;和NO65差不多，dfs即可。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;#include &amp;lt;vector&gt;
using namespace std;

class Solution {
public:
    int dx[4] = {1,0,-1,0};
    int dy[4] = {0,1,0,-1};
    int row;
    int col;
    int count; 
    int t;

    int movingCount(int threshold, int rows, int cols) {
        if(rows &amp;lt;=0 || cols &amp;lt;=0) return 0;
        row = rows;
        col = cols;
        t = threshold;
        count = 0; 
        vector&amp;lt;vector&amp;lt;bool&gt;&gt; visited(row, vector&amp;lt;bool&gt;(col, false));
        dfs(0, 0, visited);
        return count;
    }

    void dfs(int i, int j, vector&amp;lt;vector&amp;lt;bool&gt;&gt;&amp; v){
        // 检查坐标合法性、是否已访问及数位和条件
        if(i &amp;lt; 0 || i &gt;= row || j &amp;lt; 0 || j &gt;= col || v[i][j] || cal(i, j) &gt; t)
            return;
        
        v[i][j] = true;  // 标记当前格子为已访问
        count++;         // 增加可达格子数
        
        // 向四个方向继续搜索
        for(int l = 0; l &amp;lt; 4; l++){
            int curx = dx[l] + i;
            int cury = dy[l] + j;
            dfs(curx, cury, v);
        }
    }

    int cal(int x, int y){
        int res = 0;
        while(x != 0){
            res += x % 10;
            x /= 10;
        }
        while(y != 0){
            res += y % 10;
            y /= 10;
        }
        return res;
    }
};&lt;/pre&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no66-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no66-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;和NO65差不多，dfs即可。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;#include &amp;lt;vector&gt;
using namespace std;

class Solution {
public:
    int dx[4] = {1,0,-1,0};
    int dy[4] = {0,1,0,-1};
    int row;
    int col;
    int count; 
    int t;

    int movingCount(int threshold, int rows, int cols) {
        if(rows &amp;lt;=0 || cols &amp;lt;=0) return 0;
        row = rows;
        col = cols;
        t = threshold;
        count = 0; 
        vector&amp;lt;vector&amp;lt;bool&gt;&gt; visited(row, vector&amp;lt;bool&gt;(col, false));
        dfs(0, 0, visited);
        return count;
    }

    void dfs(int i, int j, vector&amp;lt;vector&amp;lt;bool&gt;&gt;&amp; v){
        // 检查坐标合法性、是否已访问及数位和条件
        if(i &amp;lt; 0 || i &gt;= row || j &amp;lt; 0 || j &gt;= col || v[i][j] || cal(i, j) &gt; t)
            return;
        
        v[i][j] = true;  // 标记当前格子为已访问
        count++;         // 增加可达格子数
        
        // 向四个方向继续搜索
        for(int l = 0; l &amp;lt; 4; l++){
            int curx = dx[l] + i;
            int cury = dy[l] + j;
            dfs(curx, cury, v);
        }
    }

    int cal(int x, int y){
        int res = 0;
        while(x != 0){
            res += x % 10;
            x /= 10;
        }
        while(y != 0){
            res += y % 10;
            y /= 10;
        }
        return res;
    }
};&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no66-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no66-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E9%80%92%E5%BD%92/" term="递归" label="递归" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No65.矩阵中的路径</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no65-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no65-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-06-19T06:56:14&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;感觉类似BFS，可以参考acwing出现的题目：&lt;a href=&#34;https://www.acwing.com/activity/content/problem/content/907/&#34;&gt;AcWing 844. 走迷宫 – AcWing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;贴上上面这道题的BFS暴力模板：&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no65-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no65-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;感觉类似BFS，可以参考acwing出现的题目：&lt;a href=&#34;https://www.acwing.com/activity/content/problem/content/907/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AcWing 844. 走迷宫 – AcWing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;贴上上面这道题的BFS暴力模板：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;#include &amp;lt;iostream&gt;
#include &amp;lt;string&gt;
#include &amp;lt;queue&gt;
using namespace std;
const int N = 105;
int g[N][N];
int dist[N][N];
int n, m;
typedef pair&amp;lt;int, int&gt; PII;
int dx[4] = {0, 1, 0, -1};
int dy[4] = {1, 0, -1, 0};
void bfs(int x, int y) //起点
{
	queue&amp;lt;PII&gt;Q;
	Q.push({x, y});
	while (!Q.empty())
	{
		auto t = Q.front();
		Q.pop();
		for (int i = 0; i &amp;lt; 4; i++)
		{
			int curx = t.first + dx[i];
			int cury = t.second + dy[i];
			if (curx &amp;lt;= 0 || curx &gt; n || cury &amp;lt;= 0 || cury &gt; m)
			{
				continue;
			}
			else
			{
				if (g[curx][cury] == 0)
				{
					Q.push({curx, cury});
					dist[curx][cury] = dist[t.first][t.second] + 1;
					g[curx][cury]++;
				}
			}
		}
	}

}
int main()
{
	cin &gt;&gt; n &gt;&gt; m;
	for (int i = 1; i &amp;lt;= n; i++)
	{
		for (int j = 1; j &amp;lt;= m; j++)
		{
			cin &gt;&gt; g[i][j];
		}
	}
	bfs(1, 1);
	cout &amp;lt;&amp;lt; dist[n][m];
	return 0;
}&lt;/pre&gt;
&lt;p&gt;这题用BFS求解会比较慢，力扣上过了87/89个用例，代码如下：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    int row;
    int col;
    int dx[4] = {0, 1, 0, -1};
    int dy[4] = {1, 0, -1, 0};

    bool wordPuzzle(vector&amp;lt;vector&amp;lt;char&gt;&gt;&amp; grid, string target) {
        row = grid.size();
        if(row == 0) return false;
        col = grid[0].size();
        if(target.empty()) return true;

        for(int i = 0; i &amp;lt; row; i++) {
            for(int j = 0; j &amp;lt; col; j++) {
                // bfs入口是第一个字符匹配的地方
                if(grid[i][j] == target[0]) {
                    if(bfs(grid, target, i, j)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    bool bfs(vector&amp;lt;vector&amp;lt;char&gt;&gt;&amp; grid, string target, int x, int y) {
        queue&amp;lt;tuple&amp;lt;int, int, int, vector&amp;lt;vector&amp;lt;bool&gt;&gt;&gt;&gt; q;
        vector&amp;lt;vector&amp;lt;bool&gt;&gt; visited(row, vector&amp;lt;bool&gt;(col, false));
        visited[x][y] = true;
        q.push({x, y, 1, visited});

        while(!q.empty()) {
            auto [i, j, pos, vis] = q.front();
            q.pop();

            // 如果pos==target.size 说明找到了匹配项
            if(pos == target.size()) {
                return true;
            }

            for(int k = 0; k &amp;lt; 4; k++) {
                int ni = i + dx[k];
                int nj = j + dy[k];
                if(ni &gt;= 0 &amp;&amp; ni &amp;lt; row &amp;&amp; nj &gt;= 0 &amp;&amp; nj &amp;lt; col &amp;&amp; !vis[ni][nj] &amp;&amp; grid[ni][nj] == target[pos]) {
                    auto newVis = vis;
                    newVis[ni][nj] = true;
                    q.push({ni, nj, pos + 1, newVis});
                }
            }
        }
        return false;
    }
};&lt;/pre&gt;
&lt;p&gt;用DFS是更正确的解法：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    int row;
    int col;
    vector&amp;lt;vector&amp;lt;bool&gt;&gt; visited;
    int dx[4] = {0, 1, 0, -1};
    int dy[4] = {1, 0, -1, 0};

    bool wordPuzzle(vector&amp;lt;vector&amp;lt;char&gt;&gt;&amp; grid, string target) {
        if(grid.empty() || grid[0].empty()) return false; 
        row = grid.size();
        col = grid[0].size();

        visited.resize(row);
        for(auto&amp; perrow: visited){
            perrow.resize(col, false);
        }

        for(int i = 0; i &amp;lt; row; i++){
            for(int j = 0; j &amp;lt; col; j++){
                if(dfs(grid, i, j, target, 0)){
                    return true;
                }
            }
        }
        return false;
    }

    bool dfs(vector&amp;lt;vector&amp;lt;char&gt;&gt;&amp; grid, int i, int j, string&amp; s, int k){
        // 两个判断顺序不能换
        if(s[k] != grid[i][j]){
            return false;
        }
        if(k == s.size() - 1) return true;
        

        // 进到这里 说明s[k] == grid[i][j] 并且还没完全全字匹配
        visited[i][j] = true;
        bool result = false;

        for(int l = 0; l &amp;lt; 4; l++){
            int curx = dx[l] + i;
            int cury = dy[l] + j;
            if(curx &amp;lt; 0 || curx &gt;= row || cury &amp;lt; 0 || cury &gt;=col){
                continue;
            }
            if(!visited[curx][cury]){
                // dfs下一层
                if(dfs(grid, curx, cury, s, k+1)){
                    result = true;
                    break;
                }
            }
        }
        //最后记得还原现场
        visited[i][j] = false;
        return result;
    }
};&lt;/pre&gt;

                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no65-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no65-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/bfs/" term="BFS" label="BFS" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E9%80%92%E5%BD%92/" term="递归" label="递归" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No64.滑动窗口的最大值</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no64-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no64-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-06-19T06:54:31&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;超级重点题，感觉很经常考。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;法1：优先队列&lt;/strong&gt;&lt;br&gt;
用一个存储值和数组索引的pair放在优先队列里，当索引超出窗口范围，就把优先队列里的值删掉。&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no64-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no64-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;超级重点题，感觉很经常考。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;法1：优先队列&lt;/strong&gt;&lt;br&gt;
用一个存储值和数组索引的pair放在优先队列里，当索引超出窗口范围，就把优先队列里的值删掉。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    vector&amp;lt;int&gt; maxSlidingWindow(vector&amp;lt;int&gt;&amp; nums, int k) {
        priority_queue&amp;lt;pair&amp;lt;int, int&gt;&gt; q;
        for(int i = 0; i &amp;lt; k; i++){
            q.push({nums[i], i});
        }
        vector&amp;lt;int&gt; res;
        res.emplace_back(q.top().first);

        for(int i = k; i &amp;lt; nums.size(); i++){
            q.push({nums[i], i});
            // 我们只关心滑动窗口的最大值 因此只需要保证q.top中的值满足在窗口中就行了
            while(q.top().second &amp;lt;= i - k){
                q.pop();
            }
            res.emplace_back(q.top().first);
        }
        return res;
    }
};&lt;/pre&gt;
&lt;p&gt;时间复杂度：O(nlogn)，其中 n 是数组 nums 的长度。在最坏情况下，数组 nums 中的元素单调递增，那么最终优先队列中包含了所有元素，没有元素被移除。由于将一个元素放入优先队列的时间复杂度为 O(logn)，因此总时间复杂度为 O(nlogn)。&lt;/p&gt;
&lt;p&gt;空间复杂度：O(n)，即为优先队列需要使用的空间。这里所有的空间复杂度分析都不考虑返回的答案需要的 O(n) 空间，只计算额外的空间使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;法2：单调队列&lt;/strong&gt;&lt;br&gt;
使用一个双端队列来维护滑动窗口内的&lt;strong&gt;元素索引&lt;/strong&gt;，&lt;strong&gt;使得队列的首元素始终是当前窗口的最大值的索引&lt;/strong&gt;。 单调队列的核心是&lt;strong&gt;维护一个严格递减的队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;具体来说，对每个元素进行以下操作：&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    移除队列中不在当前窗口范围内的元素（即索引过期的元素）。
  &lt;/li&gt;
  &lt;li&gt;
    移除队列中所有比当前元素小的元素，因为它们不可能再成为最大值。
  &lt;/li&gt;
  &lt;li&gt;
    将当前元素的索引添加到队列中。
  &lt;/li&gt;
  &lt;li&gt;
    队列的首元素即为当前窗口的最大值，将其添加到结果数组中。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    vector&amp;lt;int&gt; maxSlidingWindow(vector&amp;lt;int&gt;&amp; nums, int k) {
        deque&amp;lt;int&gt; dq;
        for(int i = 0; i &amp;lt; k; ++i){
            // 维护严格递减的队列 如果当前的值比队尾的大 就把队尾扔了 注意维护的是下标
            while(!dq.empty() &amp;&amp; nums[i] &gt;= nums[dq.back()]){
                dq.pop_back();
            }
            dq.push_back(i);
        }
        // 维护后的队列 一定是队首的值代表这个窗口的最大值
        vector&amp;lt;int&gt; res;
        res.push_back(nums[dq.front()]);
        for(int i = k; i &amp;lt; nums.size(); ++i){
            while(!dq.empty() &amp;&amp; nums[i] &gt;= nums[dq.back()]){
                dq.pop_back();
            }
            dq.push_back(i);
            // 判断最大的值 是否还在窗口内 不在就要pop掉
            while(dq.front() &amp;lt;= i - k){
                dq.pop_front();
            }
            res.push_back(nums[dq.front()]);
        }
        return res;
    }
};&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no64-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no64-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/" term="双指针算法" label="双指针算法" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E9%98%9F%E5%88%97/" term="队列" label="队列" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No63.数据流中的中位数</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no63-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no63-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-06-19T06:53:03&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;&lt;strong&gt;法1：暴力&lt;/strong&gt;&lt;br&gt;
用&lt;code&gt;vector arr&lt;/code&gt;来存取。如果对&lt;code&gt;vector&lt;/code&gt;排好序，则很容易求出中位数&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    #define SCD static_cast&amp;lt;double&gt;
    vector&amp;lt;int&gt; v;
    void Insert(int num)
    {
        v.push_back(num);

    }

    double GetMedian()
    { 
        sort(v.begin(), v.end());
        int sz = v.size();
        if (sz &amp; 1) {
            return SCD(v[sz &gt;&gt; 1]);
        }
        else {
            return SCD(v[sz &gt;&gt; 1] + v[(sz - 1) &gt;&gt; 1]) / 2;
        }
    }

};&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;法2：堆排序&lt;/strong&gt;&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no63-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no63-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;&lt;strong&gt;法1：暴力&lt;/strong&gt;&lt;br&gt;
用&lt;code&gt;vector arr&lt;/code&gt;来存取。如果对&lt;code&gt;vector&lt;/code&gt;排好序，则很容易求出中位数&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    #define SCD static_cast&amp;lt;double&gt;
    vector&amp;lt;int&gt; v;
    void Insert(int num)
    {
        v.push_back(num);

    }

    double GetMedian()
    { 
        sort(v.begin(), v.end());
        int sz = v.size();
        if (sz &amp; 1) {
            return SCD(v[sz &gt;&gt; 1]);
        }
        else {
            return SCD(v[sz &gt;&gt; 1] + v[(sz - 1) &gt;&gt; 1]) / 2;
        }
    }

};&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;法2：堆排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以参考：&lt;a href=&#34;https://blog.algomooc.com/offer/041.html#%E4%BA%8C%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;剑指 Offer 41. 数据流中的中位数 | 吴师兄学算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;则根据中位数可以把数组分为如下三段: &lt;code&gt;[0 ... median - 1], [median], [median + 1 ... arr.size() - 1]&lt;/code&gt;，即&lt;code&gt;[中位数的左边，中位数，中位数的右边]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;用两个堆，一个大根一个小根堆，那么很明显，求中位数可以是：&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    大根堆或者小根堆的第一个（奇数个数），&lt;strong&gt;此处规定小根堆的堆顶。&lt;/strong&gt;
  &lt;/li&gt;
  &lt;li&gt;
    大根堆或者小根堆加和/2（偶数个数）
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;PS：可以参考NO29的关于堆的介绍。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;堆维护的细节：&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    要保证数据平均分配到两个堆中，因此两个堆中数据的数目之差不能超过1
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;要保证最大堆中里的所有数据都要小于最小堆中的数据&lt;/strong&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了让每次新增一个数据到两个堆之后，都能使得从大顶堆到小顶堆是一个递增有序的数组，我们可以采取如下的操作：&lt;/p&gt;
&lt;ol class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    如果两堆长度相等，即长度都为 n 时，新数据先加入到&lt;strong&gt;大顶堆&lt;/strong&gt;中，然后再把&lt;strong&gt;大顶堆&lt;/strong&gt;的堆顶元素取出，放入到&lt;strong&gt;小顶堆&lt;/strong&gt;中。
  &lt;/li&gt;
  &lt;li&gt;
    当两堆长度不相等，即小顶堆长度为 n，大顶堆长度为 n &amp;#8211; 1，新数据先加入到&lt;strong&gt;小顶堆&lt;/strong&gt;中，然后再把&lt;strong&gt;小顶堆&lt;/strong&gt;的堆顶元素取出，放入到&lt;strong&gt;大顶堆&lt;/strong&gt;中。
  &lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;#include &amp;lt;queue&gt;
#include &amp;lt;vector&gt;
class Solution {
public:
    std::priority_queue&amp;lt;int&gt; max_q; 
    std::priority_queue&amp;lt;int, vector&amp;lt;int&gt;, greater&amp;lt;&gt;&gt; min_q; // 小顶堆 维护右边区间
    int cnt = 0;

    void Insert(int num) {
        cnt++;
        if(max_q.size() == min_q.size()){
            max_q.push(num);
            min_q.push(max_q.top());
            max_q.pop();
        }else{
            min_q.push(num);
            max_q.push(min_q.top());
            min_q.pop();
        }
    }

    double GetMedian() { 
        if(cnt % 2 == 0){
            return double(max_q.top() + min_q.top()) / 2.0;
        }else{
            return double(min_q.top());
        }
    }

};&lt;/pre&gt;

                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no63-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no63-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/" term="堆排序" label="堆排序" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No62.二叉搜索树中的第K个节点</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/16/%E5%89%91%E6%8C%87offer67%E9%A2%98-no62-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/16/%E5%89%91%E6%8C%87offer67%E9%A2%98-no62-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-06-16T08:08:43&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;
  &lt;p&gt;
    给定一棵二叉搜索树，请找出其中第k大的节点。
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;二叉搜索树的中序遍历，是满足从小到大的排序性质的，因此要找第k大，直接中序遍历翻转（右根左），找出第k个就行了。&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/16/%E5%89%91%E6%8C%87offer67%E9%A2%98-no62-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/16/%E5%89%91%E6%8C%87offer67%E9%A2%98-no62-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;
  &lt;p&gt;
    给定一棵二叉搜索树，请找出其中第k大的节点。
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;二叉搜索树的中序遍历，是满足从小到大的排序性质的，因此要找第k大，直接中序遍历翻转（右根左），找出第k个就行了。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    int k = 0;
    int res = 0;
    void dfs(TreeNode* root){

        if(root == nullptr || k == 0) return;
        dfs(root-&gt;right);
        k--;
        if(k == 0){ 
            res = root-&gt;val; 
            return;
        }
        dfs(root-&gt;left);
        return;
    }
    int findTargetNode(TreeNode* root, int cnt) {
        k = cnt;
        dfs(root);
        return res;
    }
};&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/16/%E5%89%91%E6%8C%87offer67%E9%A2%98-no62-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/16/%E5%89%91%E6%8C%87offer67%E9%A2%98-no62-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A0%91/" term="树" label="树" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No61.序列化二叉树</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/16/%E5%89%91%E6%8C%87offer67%E9%A2%98-no61-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/16/%E5%89%91%E6%8C%87offer67%E9%A2%98-no61-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-06-16T08:07:27&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    序列化二叉树即找一种顺序存储二叉树的节点，并以相同的方式能够读取序列重新构建。
  &lt;/li&gt;
  &lt;li&gt;
    换种说法，就是遍历二叉树，记录每个节点，再以同样的方式遍历就可以还原二叉树。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;PS：能基于序列化字符串单独还原树的情况&lt;/strong&gt;：&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/16/%E5%89%91%E6%8C%87offer67%E9%A2%98-no61-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/16/%E5%89%91%E6%8C%87offer67%E9%A2%98-no61-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    序列化二叉树即找一种顺序存储二叉树的节点，并以相同的方式能够读取序列重新构建。
  &lt;/li&gt;
  &lt;li&gt;
    换种说法，就是遍历二叉树，记录每个节点，再以同样的方式遍历就可以还原二叉树。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;PS：能基于序列化字符串单独还原树的情况&lt;/strong&gt;：&lt;/p&gt;
&lt;ol class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    &lt;strong&gt;层次遍历序列&lt;/strong&gt;（需标记空节点）。
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;前序或后序遍历序列&lt;/strong&gt;（需结合中序，或显式标记空节点，如 &lt;code&gt;[1,2,null,null,3]&lt;/code&gt;）。若序列化时未标记空节点，则&lt;strong&gt;只有层次遍历或前序+中序/后序+中序的组合能唯一还原&lt;/strong&gt;。
  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本题，可以参考牛客做法，用前序遍历来实现序列化与反序列化。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    string dfs(TreeNode* root){
        if(root == nullptr) return &#34;#&#34;;
        string str;
        str += to_string(root-&gt;val) + &#34;!&#34;; // 用！分割数字 以免出现13和1、3混淆这种情况
        str += dfs(root-&gt;left);
        str += dfs(root-&gt;right);
        return str;
    }
    TreeNode* deserialHandle(char* &amp;str){
        if(*str == &#39;#&#39;){
            // 如果是# 忽略 找下一个
            return nullptr; 
        }
        int num = 0;
        while(*str != &#39;!&#39;){
            num = num * 10 + (*str) - &#39;0&#39;;
            str++;
        }
        TreeNode* node = new TreeNode(num);
        node-&gt;left = deserialHandle(++str);
        node-&gt;right = deserialHandle(++str);
        return node;
    }
    char* Serialize(TreeNode *root) {    
        string str = dfs(root);
        char *res = new char[str.size() + 10];
        for(int i = 0; i &amp;lt; str.size(); ++i){
            res[i] = str[i];
        }
        return res;
    }
    TreeNode* Deserialize(char *str) {
        return deserialHandle(str);
    }
};&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/16/%E5%89%91%E6%8C%87offer67%E9%A2%98-no61-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/16/%E5%89%91%E6%8C%87offer67%E9%A2%98-no61-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" term="字符串" label="字符串" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A0%91/" term="树" label="树" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No60.把二叉树打印成多行</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/16/%E5%89%91%E6%8C%87offer67%E9%A2%98-no60-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/16/%E5%89%91%E6%8C%87offer67%E9%A2%98-no60-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-06-16T08:06:19&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;层序遍历&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;vector&amp;lt;vector&amp;lt;int&gt; &gt; Print(TreeNode* pRoot) {
        // write code here
        if(pRoot == nullptr) return {};
        vector&amp;lt;vector&amp;lt;int&gt;&gt; res;
        queue&amp;lt;TreeNode*&gt; Q;
        Q.push(pRoot);
        vector&amp;lt;int&gt; tmp;
        while(!Q.empty()){
            tmp.clear();
            int len = Q.size();

            for(int i = 0; i &amp;lt; len; ++i){
                TreeNode* cur = Q.front();
                Q.pop();
                if(cur != nullptr){
                    tmp.emplace_back(cur-&gt;val);
                    if(cur-&gt;left) Q.push(cur-&gt;left);
                    if(cur-&gt;right) Q.push(cur-&gt;right);
                }
            }
            res.emplace_back(tmp);
        }
        return res;
    }&lt;/pre&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/16/%E5%89%91%E6%8C%87offer67%E9%A2%98-no60-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/16/%E5%89%91%E6%8C%87offer67%E9%A2%98-no60-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;层序遍历&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;vector&amp;lt;vector&amp;lt;int&gt; &gt; Print(TreeNode* pRoot) {
        // write code here
        if(pRoot == nullptr) return {};
        vector&amp;lt;vector&amp;lt;int&gt;&gt; res;
        queue&amp;lt;TreeNode*&gt; Q;
        Q.push(pRoot);
        vector&amp;lt;int&gt; tmp;
        while(!Q.empty()){
            tmp.clear();
            int len = Q.size();

            for(int i = 0; i &amp;lt; len; ++i){
                TreeNode* cur = Q.front();
                Q.pop();
                if(cur != nullptr){
                    tmp.emplace_back(cur-&gt;val);
                    if(cur-&gt;left) Q.push(cur-&gt;left);
                    if(cur-&gt;right) Q.push(cur-&gt;right);
                }
            }
            res.emplace_back(tmp);
        }
        return res;
    }&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/16/%E5%89%91%E6%8C%87offer67%E9%A2%98-no60-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/16/%E5%89%91%E6%8C%87offer67%E9%A2%98-no60-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A0%91/" term="树" label="树" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No59.按之字形顺序打印二叉树</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/16/%E5%89%91%E6%8C%87offer67%E9%A2%98-no59-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/16/%E5%89%91%E6%8C%87offer67%E9%A2%98-no59-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-06-16T08:05:21&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;二叉树的层序遍历，特判版。&lt;br&gt;
特判还是比较难的，主要是需要用到&lt;code&gt;tmp.insert(tmp.begin(), x-&amp;gt;val);&lt;/code&gt;实现从右到左打印&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/16/%E5%89%91%E6%8C%87offer67%E9%A2%98-no59-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/16/%E5%89%91%E6%8C%87offer67%E9%A2%98-no59-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;二叉树的层序遍历，特判版。&lt;br&gt;
特判还是比较难的，主要是需要用到&lt;code&gt;tmp.insert(tmp.begin(), x-&amp;gt;val);&lt;/code&gt;实现从右到左打印&lt;/p&gt;
&lt;p&gt;class Solution {&lt;br&gt;
public:&lt;br&gt;
vector &amp;gt; Print(TreeNode* pRoot) {&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;if (pRoot == nullptr) return {};

    vector&amp;lt;vector&amp;lt;int&gt;&gt; res;
    queue&amp;lt;TreeNode*&gt; Q;
    Q.push(pRoot);
    int odd = 0;
    vector&amp;lt;int&gt; tmp;

    while (!Q.empty()) {
        tmp.clear();
        int len = Q.size();
        for(int i = 0; i &amp;lt; len; ++i){
            TreeNode* x = Q.front();
            Q.pop();

            if(x == nullptr) continue;
            Q.push(x-&gt;left);
            Q.push(x-&gt;right);
            // 保持左右孩子入队不变，打印的时候需要特判
            if(odd % 2 == 0){
                // 第一行 从左到右打印
                tmp.push_back(x-&gt;val);
            }else{
                // 这样可以实现从右向左打印
                tmp.insert(tmp.begin(), x-&gt;val);
            }
        }
        odd++;
        if(!tmp.empty()) res.push_back(tmp);
    }
    return res;
}
};&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/16/%E5%89%91%E6%8C%87offer67%E9%A2%98-no59-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/16/%E5%89%91%E6%8C%87offer67%E9%A2%98-no59-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A0%91/" term="树" label="树" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No58.对称的二叉树</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/16/%E5%89%91%E6%8C%87offer67%E9%A2%98-no58-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/16/%E5%89%91%E6%8C%87offer67%E9%A2%98-no58-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-06-16T08:04:07&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;
  &lt;p&gt;
    给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;bool dfs(TreeNode* p1, TreeNode* p2){
        // 都为nullptr 必对称
        if(p1 == nullptr &amp;&amp; p2 == nullptr) return true;
        // 不对称
        if(p1 == nullptr || p2 == nullptr || p1-&gt;val != p2-&gt;val) return false;
        return dfs(p1-&gt;left, p2-&gt;right) &amp;&amp; dfs(p1-&gt;right, p2-&gt;left);

     }
    bool isSymmetrical(TreeNode* pRoot) {
        // write code here
        if(pRoot == nullptr) return true;
        
        return dfs(pRoot-&gt;left, pRoot-&gt;right);
    }&lt;/pre&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/16/%E5%89%91%E6%8C%87offer67%E9%A2%98-no58-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/16/%E5%89%91%E6%8C%87offer67%E9%A2%98-no58-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;
  &lt;p&gt;
    给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;bool dfs(TreeNode* p1, TreeNode* p2){
        // 都为nullptr 必对称
        if(p1 == nullptr &amp;&amp; p2 == nullptr) return true;
        // 不对称
        if(p1 == nullptr || p2 == nullptr || p1-&gt;val != p2-&gt;val) return false;
        return dfs(p1-&gt;left, p2-&gt;right) &amp;&amp; dfs(p1-&gt;right, p2-&gt;left);

     }
    bool isSymmetrical(TreeNode* pRoot) {
        // write code here
        if(pRoot == nullptr) return true;
        
        return dfs(pRoot-&gt;left, pRoot-&gt;right);
    }&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/16/%E5%89%91%E6%8C%87offer67%E9%A2%98-no58-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/16/%E5%89%91%E6%8C%87offer67%E9%A2%98-no58-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A0%91/" term="树" label="树" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No57.二叉树的下一个节点</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/06/%E5%89%91%E6%8C%87offer67%E9%A2%98-no57-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/06/%E5%89%91%E6%8C%87offer67%E9%A2%98-no57-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-06-06T08:53:55&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;简单的思路就是递归中序遍历一遍，存在vector里，然后输出。&lt;/p&gt;
&lt;p&gt;通常情况下，中序遍历不可能有O1空间复杂度方法，非递归算法也要用栈来辅助。 三种遍历树的非递归算法总结，可以参考blog：&lt;a href=&#34;https://www.cnblogs.com/zhulmz/p/11861058.html&#34;&gt;二叉树遍历-非递归算法 – 翁德彪 – 博客园&lt;/a&gt;&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/06/%E5%89%91%E6%8C%87offer67%E9%A2%98-no57-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/06/%E5%89%91%E6%8C%87offer67%E9%A2%98-no57-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;简单的思路就是递归中序遍历一遍，存在vector里，然后输出。&lt;/p&gt;
&lt;p&gt;通常情况下，中序遍历不可能有O1空间复杂度方法，非递归算法也要用栈来辅助。 三种遍历树的非递归算法总结，可以参考blog：&lt;a href=&#34;https://www.cnblogs.com/zhulmz/p/11861058.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;二叉树遍历-非递归算法 – 翁德彪 – 博客园&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此处贴一个借助栈的中序遍历非递归算法：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;void InorderTraverse(BiTree T,Stack *s)
{
    BiTree P=T;
    // 依次访问二叉树的左子树，并将指向结点的指针存入栈中，当指针为空时，表示左子树访问完毕，此时应退栈输出结点数据，然后访问右子树
    while(P||s-&gt;stacksize!=0)
    {
        if(P)
        {
            Push(s, P);
            P=P-&gt;lchild;
        }
        else
        {
            P=Pop(s);
            printf(&#34;%c &#34;,P-&gt;data);
            P=P-&gt;rchild;
        }
    }
}&lt;/pre&gt;
&lt;p&gt;本题能实现O1空间复杂度，是因为还有一个从子节点指向父节点的指针。&lt;br&gt;
摘自牛客题解，&lt;strong&gt;可以把中序（DBHEIAFCG）下一结点归为几种类型：&lt;/strong&gt;&lt;br&gt;
DBHEIAFCG&lt;/p&gt;
&lt;div class=&#34;wp-block-image&#34;&gt;
  &lt;figure class=&#34;aligncenter size-full&#34;&gt;
  &lt;div class=&#39;fancybox-wrapper lazyload-container-unload&#39; data-fancybox=&#39;post-images&#39; href=&#39;http://117.72.66.48/wp-content/uploads/2025/06/image-3.png&#39;&gt;
    &lt;img class=&#34;lazyload lazyload-style-1&#34; src=&#34;data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+&#34;  loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;329&#34; height=&#34;353&#34; data-original=&#34;http://117.72.66.48/wp-content/uploads/2025/06/image-3.png&#34; src=&#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC&#34; alt=&#34;&#34; class=&#34;wp-image-213&#34;  sizes=&#34;auto, (max-width: 329px) 100vw, 329px&#34; /&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;1、有右子树，下一结点是&lt;strong&gt;右子树中的最左结点&lt;/strong&gt;，例如 B，下一结点是 H&lt;br&gt;
2、无右子树，且结点是该结点父结点的左子树，则&lt;strong&gt;下一结点是该结点的父结点&lt;/strong&gt;，例如 H，下一结点是 E 3、无右子树，且结点是该结点父结点的右子树，则先要沿着左上方父节点爬树，一直爬到&lt;strong&gt;当前结点是其父节点的左子节点&lt;/strong&gt;为止，返回的就是这个父节点（&lt;strong&gt;例如，针对I，向上爬到B，B满足是其父节点A的左子节点，那么返回B的父节点A&lt;/strong&gt;）；或者没有满足上述情况的则返回为NULL&lt;/p&gt;
&lt;p&gt;其实2、3可以总结为：&lt;strong&gt;若该结点不存在右子树，则「下一个结点」为「该结点的第一个右父结点」&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;/*
struct TreeLinkNode {
    int val;
    struct TreeLinkNode *left;
    struct TreeLinkNode *right;
    struct TreeLinkNode *next;
    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) {
        
    }
};
*/
class Solution {
public:
    TreeLinkNode* GetNext(TreeLinkNode* pNode) {
        //中序遍历左根右
        // 当前节点 如果有右孩子 找出右子树中的最左节点
        if(pNode-&gt;right){
            TreeLinkNode* rchild = pNode-&gt;right;
            while (rchild-&gt;left) {
                    rchild = rchild-&gt;left;
            }
            return rchild;
        }

        // 如果没有右子树 且当前节点是其父节点的左子节点
        if(pNode-&gt;next != nullptr &amp;&amp; pNode-&gt;next-&gt;left == pNode){
            //当前节点父节点就是要找的
            return pNode-&gt;next;
        }

        //最复杂的情况 没有右子树 当前节点是父节点的右子节点
        while(pNode-&gt;next != nullptr){
            //要向上找第一个右父节点
            if(pNode-&gt;next-&gt;left == pNode){
                return pNode-&gt;next;
            }
            pNode = pNode-&gt;next;
        }
        return nullptr;
    }
};
&lt;/pre&gt;

                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/06/%E5%89%91%E6%8C%87offer67%E9%A2%98-no57-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/06/%E5%89%91%E6%8C%87offer67%E9%A2%98-no57-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A0%91/" term="树" label="树" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No56.删除链表中的重复节点</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/06/%E5%89%91%E6%8C%87offer67%E9%A2%98-no56-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/06/%E5%89%91%E6%8C%87offer67%E9%A2%98-no56-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-06-06T08:52:12&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;用哈希的方法比较简单，想想直接遍历的方法。&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    &lt;strong&gt;遍历链表，每次比较相邻两个节点，如果遇到了两个相邻节点相同，则新开内循环将这一段所有的相同都遍历过去。&lt;/strong&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;在这一连串相同的节点前的节点，直接连上后续第一个不相同值的节点。&lt;/strong&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    ListNode* deleteDuplication(ListNode* pHead) {
        if(pHead == nullptr || pHead-&gt;next == nullptr) return pHead;

        ListNode* cur = pHead;   // cur用以遍历链表找重复的 prev为cur的前节点
        ListNode* prev;

        ListNode* curx = new ListNode(0);   // 哑节点
        curx-&gt;next = pHead;
        prev = curx;    // 前置节点-&gt;next = curx

        while(cur != nullptr){
            if(cur-&gt;next != nullptr &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val){
                while(cur-&gt;next != nullptr &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val){
                    cur = cur-&gt;next;
                }
                prev-&gt;next = cur-&gt;next; //prev指向最新的cur-&gt;next 而不更新next
                cur = cur-&gt;next;
            }else{
                // 只有一开始就满足cur-&gt;next-&gt;val != cur-&gt;val 才说明是唯一值 prev才能更新next
                prev = prev-&gt;next;
                cur = cur-&gt;next;
            }
            
        }

        return curx-&gt;next;
    }
};&lt;/pre&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/06/%E5%89%91%E6%8C%87offer67%E9%A2%98-no56-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/06/%E5%89%91%E6%8C%87offer67%E9%A2%98-no56-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;用哈希的方法比较简单，想想直接遍历的方法。&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    &lt;strong&gt;遍历链表，每次比较相邻两个节点，如果遇到了两个相邻节点相同，则新开内循环将这一段所有的相同都遍历过去。&lt;/strong&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;在这一连串相同的节点前的节点，直接连上后续第一个不相同值的节点。&lt;/strong&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    ListNode* deleteDuplication(ListNode* pHead) {
        if(pHead == nullptr || pHead-&gt;next == nullptr) return pHead;

        ListNode* cur = pHead;   // cur用以遍历链表找重复的 prev为cur的前节点
        ListNode* prev;

        ListNode* curx = new ListNode(0);   // 哑节点
        curx-&gt;next = pHead;
        prev = curx;    // 前置节点-&gt;next = curx

        while(cur != nullptr){
            if(cur-&gt;next != nullptr &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val){
                while(cur-&gt;next != nullptr &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val){
                    cur = cur-&gt;next;
                }
                prev-&gt;next = cur-&gt;next; //prev指向最新的cur-&gt;next 而不更新next
                cur = cur-&gt;next;
            }else{
                // 只有一开始就满足cur-&gt;next-&gt;val != cur-&gt;val 才说明是唯一值 prev才能更新next
                prev = prev-&gt;next;
                cur = cur-&gt;next;
            }
            
        }

        return curx-&gt;next;
    }
};&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/06/%E5%89%91%E6%8C%87offer67%E9%A2%98-no56-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/06/%E5%89%91%E6%8C%87offer67%E9%A2%98-no56-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/" term="双指针算法" label="双指针算法" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E9%93%BE%E8%A1%A8/" term="链表" label="链表" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No55.链表中的入口节点</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/06/%E5%89%91%E6%8C%87offer67%E9%A2%98-no55-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/06/%E5%89%91%E6%8C%87offer67%E9%A2%98-no55-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-06-06T08:51:24&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;双指针算法&lt;/p&gt;
&lt;p&gt;快慢指针，指针相遇的时候就是入口。证明如下：&lt;/p&gt;
&lt;p&gt;设快指针的速度是慢指针的两倍，环之前有m个节点，环内有c个节点。当慢指针走了&lt;code&gt;a&lt;/code&gt;步且两指针相遇时，快指针显然走了&lt;code&gt;a+nc&lt;/code&gt;步（n表示快指针的绕环周期）。 再由先前的速度定义，有：&lt;code&gt;2a = a+nc&lt;/code&gt;，即&lt;code&gt;a = nc&lt;/code&gt;，&lt;strong&gt;说明慢指针此时，刚好走了n个环周期&lt;/strong&gt;，**只需要再走m步，就可以到达入口点了。**再重置一个指针，让他从头开始走，那么两指针肯定会相遇在入口节点。&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/06/%E5%89%91%E6%8C%87offer67%E9%A2%98-no55-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/06/%E5%89%91%E6%8C%87offer67%E9%A2%98-no55-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;双指针算法&lt;/p&gt;
&lt;p&gt;快慢指针，指针相遇的时候就是入口。证明如下：&lt;/p&gt;
&lt;p&gt;设快指针的速度是慢指针的两倍，环之前有m个节点，环内有c个节点。当慢指针走了&lt;code&gt;a&lt;/code&gt;步且两指针相遇时，快指针显然走了&lt;code&gt;a+nc&lt;/code&gt;步（n表示快指针的绕环周期）。 再由先前的速度定义，有：&lt;code&gt;2a = a+nc&lt;/code&gt;，即&lt;code&gt;a = nc&lt;/code&gt;，&lt;strong&gt;说明慢指针此时，刚好走了n个环周期&lt;/strong&gt;，**只需要再走m步，就可以到达入口点了。**再重置一个指针，让他从头开始走，那么两指针肯定会相遇在入口节点。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;ListNode* EntryNodeOfLoop(ListNode* pHead) {
        if(pHead == nullptr || pHead-&gt;next == nullptr) return nullptr;

        ListNode* f = pHead;
        ListNode* s = pHead;
        ListNode* cur = pHead;
        while(s != nullptr &amp;&amp; f != nullptr){
            f = f-&gt;next-&gt;next;
            s = s-&gt;next;
            if(f == s) break;
        }
        if(s == nullptr || f == nullptr) return nullptr;
        cur = pHead;
        while(cur != s){
            cur = cur-&gt;next;
            s = s-&gt;next;
        }
        return cur;  
    }
};&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/06/%E5%89%91%E6%8C%87offer67%E9%A2%98-no55-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/06/%E5%89%91%E6%8C%87offer67%E9%A2%98-no55-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/" term="双指针算法" label="双指针算法" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E9%93%BE%E8%A1%A8/" term="链表" label="链表" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No54.字符流中第一个不重复的字符</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no54-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no54-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-06-05T06:04:12&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;&lt;strong&gt;字符串处理&lt;/strong&gt; 哈希表。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;#include &amp;lt;unordered_map&gt;
class Solution
{
public:
  //Insert one char from stringstream
    string s;
    unordered_map&amp;lt;char, int&gt; mp;

    void Insert(char ch) {
         s += ch;
         mp[ch]++;
    }
  //return the first appearence once char in current stringstream
    char FirstAppearingOnce() {
        for(int i = 0; i &amp;lt; s.length(); i++){
            if(mp[s[i]] == 1){
                return s[i];
            }
        }
        return &#39;#&#39;;
    }

};
&lt;/pre&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no54-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no54-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;&lt;strong&gt;字符串处理&lt;/strong&gt; 哈希表。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;#include &amp;lt;unordered_map&gt;
class Solution
{
public:
  //Insert one char from stringstream
    string s;
    unordered_map&amp;lt;char, int&gt; mp;

    void Insert(char ch) {
         s += ch;
         mp[ch]++;
    }
  //return the first appearence once char in current stringstream
    char FirstAppearingOnce() {
        for(int i = 0; i &amp;lt; s.length(); i++){
            if(mp[s[i]] == 1){
                return s[i];
            }
        }
        return &#39;#&#39;;
    }

};
&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no54-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no54-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%93%88%E5%B8%8C/" term="哈希" label="哈希" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" term="字符串" label="字符串" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No53.表示数值的字符串</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no53-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no53-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-06-05T06:03:44&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;&lt;strong&gt;字符串处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leetcode上精简的题解方法。&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    &lt;code&gt;.&lt;/code&gt;出现正确情况：只出现一次，且在e的前面
  &lt;/li&gt;
  &lt;li&gt;
    &lt;code&gt;e&lt;/code&gt;出现正确情况：只出现一次，且出现前有数字
  &lt;/li&gt;
  &lt;li&gt;
    &lt;code&gt;+&lt;/code&gt;和&lt;code&gt;-&lt;/code&gt;出现正确情况：只能在开头和e后一位
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    bool isDigital(char x){
        return x &gt;= &#39;0&#39; &amp;&amp; x &amp;lt;= &#39;9&#39;;
    }
    bool validNumber(string s) {
        if(s.size() == 0) return false;
        int len = s.size();
        int i = 0;
        // 前导空格和尾部空格先删了
        while(i &amp;lt; len &amp;&amp; s[i] == &#39; &#39; ) i++;
        s = s.substr(i);
        while(!s.empty() &amp;&amp; s.back() == &#39; &#39;) s.pop_back();
        len = s.size();
        
        bool dotFlag = false;
        bool eFlag = false;
        bool numFlag = false;

        for(i = 0; i &amp;lt; len; i++){
            if(isDigital(s[i])){
                numFlag = true;
            }
            else if(s[i] == &#39;.&#39; &amp;&amp; !dotFlag &amp;&amp; !eFlag){
                // .只能出现过一次 并且一定在e前先出现
                dotFlag = true;
            }else if((s[i] == &#39;e&#39; || s[i] == &#39;E&#39;) &amp;&amp; !eFlag &amp;&amp; numFlag){
                // e只能出现一次 判定为e 需要出现过数字
                eFlag = true;
                numFlag = false;     // e后必须跟一个整数 所以e之后numFlag要重新reset
            }else if((s[i] == &#39;+&#39; || s[i] == &#39;-&#39;) &amp;&amp; (i == 0 || s[i-1] == &#39;e&#39; || s[i-1] == &#39;E&#39;)){
                continue;

            }else{
                return false;
            }
        }
        return numFlag;

    }
};&lt;/pre&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no53-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no53-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;&lt;strong&gt;字符串处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;leetcode上精简的题解方法。&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    &lt;code&gt;.&lt;/code&gt;出现正确情况：只出现一次，且在e的前面
  &lt;/li&gt;
  &lt;li&gt;
    &lt;code&gt;e&lt;/code&gt;出现正确情况：只出现一次，且出现前有数字
  &lt;/li&gt;
  &lt;li&gt;
    &lt;code&gt;+&lt;/code&gt;和&lt;code&gt;-&lt;/code&gt;出现正确情况：只能在开头和e后一位
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    bool isDigital(char x){
        return x &gt;= &#39;0&#39; &amp;&amp; x &amp;lt;= &#39;9&#39;;
    }
    bool validNumber(string s) {
        if(s.size() == 0) return false;
        int len = s.size();
        int i = 0;
        // 前导空格和尾部空格先删了
        while(i &amp;lt; len &amp;&amp; s[i] == &#39; &#39; ) i++;
        s = s.substr(i);
        while(!s.empty() &amp;&amp; s.back() == &#39; &#39;) s.pop_back();
        len = s.size();
        
        bool dotFlag = false;
        bool eFlag = false;
        bool numFlag = false;

        for(i = 0; i &amp;lt; len; i++){
            if(isDigital(s[i])){
                numFlag = true;
            }
            else if(s[i] == &#39;.&#39; &amp;&amp; !dotFlag &amp;&amp; !eFlag){
                // .只能出现过一次 并且一定在e前先出现
                dotFlag = true;
            }else if((s[i] == &#39;e&#39; || s[i] == &#39;E&#39;) &amp;&amp; !eFlag &amp;&amp; numFlag){
                // e只能出现一次 判定为e 需要出现过数字
                eFlag = true;
                numFlag = false;     // e后必须跟一个整数 所以e之后numFlag要重新reset
            }else if((s[i] == &#39;+&#39; || s[i] == &#39;-&#39;) &amp;&amp; (i == 0 || s[i-1] == &#39;e&#39; || s[i-1] == &#39;E&#39;)){
                continue;

            }else{
                return false;
            }
        }
        return numFlag;

    }
};&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no53-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no53-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" term="字符串" label="字符串" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A8%A1%E6%8B%9F/" term="模拟" label="模拟" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No52.正则表达式匹配</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no52-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no52-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-06-05T05:55:18&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;字符串处理&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;没想到是动态规划题&lt;/strong&gt;，感觉特别难 &lt;a href=&#34;https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solutions/521347/zheng-ze-biao-da-shi-pi-pei-by-leetcode-s3jgn/&#34;&gt;LCR 137. 模糊搜索验证 – 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no52-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no52-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;字符串处理&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;没想到是动态规划题&lt;/strong&gt;，感觉特别难 &lt;a href=&#34;https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solutions/521347/zheng-ze-biao-da-shi-pi-pei-by-leetcode-s3jgn/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LCR 137. 模糊搜索验证 – 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;法1：DP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用&lt;code&gt;f[i][j]&lt;/code&gt;表示s的前i个字符与p的前j个字符是否能匹配。&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;考虑情况：&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    &lt;strong&gt;p的第j个字符是小写字符：&lt;/strong&gt;&lt;br /&gt;&lt;em&gt;&lt;code&gt;f[i][j] = f[i-1][j-1] （if s[i] = p[j]&lt;/code&gt;&lt;/em&gt;）&lt;br /&gt;&lt;em&gt;&lt;code&gt;f[i][j] = false （if s[i] ≠ p[j]&lt;/code&gt;&lt;/em&gt;）&lt;br /&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;p的第j个字符是*：&lt;/strong&gt;如果 &lt;em&gt;p&lt;/em&gt; 的第 &lt;em&gt;j&lt;/em&gt; 个字符是 &lt;code&gt;*&lt;/code&gt;，那么就表示我们可以对 &lt;em&gt;p&lt;/em&gt; 的第 &lt;em&gt;j&lt;/em&gt;−1 个字符匹配任意自然数次。在匹配 0 次的情况下，我们有：&lt;em&gt;&lt;code&gt;f[i][j] = f[i-1][j-2]&lt;/code&gt;&lt;/em&gt;&lt;br /&gt;
  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;实际上，本质上只会有两种情况：&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    匹配 &lt;em&gt;s&lt;/em&gt; 末尾的一个字符，将该字符扔掉，而该组合还可以继续进行匹配；
  &lt;/li&gt;
  &lt;li&gt;
    不匹配字符，将该组合扔掉，不再进行匹配
  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;wp-block-image&#34;&gt;
  &lt;figure class=&#34;aligncenter size-full&#34;&gt;
  &lt;div class=&#39;fancybox-wrapper lazyload-container-unload&#39; data-fancybox=&#39;post-images&#39; href=&#39;http://117.72.66.48/wp-content/uploads/2025/06/image-2.png&#39;&gt;
    &lt;img class=&#34;lazyload lazyload-style-1&#34; src=&#34;data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+&#34;  loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;551&#34; height=&#34;93&#34; data-original=&#34;http://117.72.66.48/wp-content/uploads/2025/06/image-2.png&#34; src=&#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC&#34; alt=&#34;&#34; class=&#34;wp-image-202&#34;  sizes=&#34;auto, (max-width: 551px) 100vw, 551px&#34; /&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.size();
        int n = p.size();

        auto matches = [&amp;](int i, int j) {
            if (i == 0) {
                return false;
            }
            if (p[j - 1] == &#39;.&#39;) {
                return true;
            }
            return s[i - 1] == p[j - 1];
        };

        vector&amp;lt;vector&amp;lt;int&gt;&gt; f(m + 1, vector&amp;lt;int&gt;(n + 1));
        f[0][0] = true;
        for (int i = 0; i &amp;lt;= m; ++i) {
            for (int j = 1; j &amp;lt;= n; ++j) {
                if (p[j - 1] == &#39;*&#39;) {
                    f[i][j] |= f[i][j - 2];
                    if (matches(i, j - 1)) {
                        f[i][j] |= f[i - 1][j];
                    }
                }
                else {
                    if (matches(i, j)) {
                        f[i][j] |= f[i - 1][j - 1];
                    }
                }
            }
        }
        return f[m][n];
    }
};&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;法2：递归&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;贴个leetcode的递归版本代码，更容易理解&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    bool isMatch(string s, string p) 
    {
        if (p.empty())  return s.empty();
        bool first_match = !s.empty() &amp;&amp; (s[0] == p[0] || p[0] == &#39;.&#39;);
        // *前字符重复&gt;=1次 || *前字符重复0次（不出现）
        if (p.size() &gt;= 2 &amp;&amp; p[1] == &#39;*&#39;)  
            return (first_match &amp;&amp; isMatch(s.substr(1), p)) || isMatch(s, p.substr(2));
        // 不是*，剪去已经匹配成功的头部，继续比较
        else
            return first_match &amp;&amp; isMatch(s.substr(1), p.substr(1));    
    }
};&lt;/pre&gt;

                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no52-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no52-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/dp/" term="DP" label="DP" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A8%A1%E6%8B%9F/" term="模拟" label="模拟" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E9%80%92%E5%BD%92/" term="递归" label="递归" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No51.构建乘积数组</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no51-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no51-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-06-05T05:53:32&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;**法1：**暴力&lt;/p&gt;
&lt;p&gt;时间复杂度为On^2&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;vector&amp;lt;int&gt; multiply(vector&amp;lt;int&gt;&amp; A) {
        // write code here
        vector&amp;lt;int&gt; res;
        int len = A.size();

        for(int i = 0; i &amp;lt; len; ++i){
            int b = 1;
            for(int j = 0; j &amp;lt; len; ++j){
                if(j == i) continue;
                b = b * A[j];
            }                
            res.emplace_back(b);
        }
        return res;
    }&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;法2：时间复杂度更低的方法&lt;/strong&gt;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no51-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no51-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;**法1：**暴力&lt;/p&gt;
&lt;p&gt;时间复杂度为On^2&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;vector&amp;lt;int&gt; multiply(vector&amp;lt;int&gt;&amp; A) {
        // write code here
        vector&amp;lt;int&gt; res;
        int len = A.size();

        for(int i = 0; i &amp;lt; len; ++i){
            int b = 1;
            for(int j = 0; j &amp;lt; len; ++j){
                if(j == i) continue;
                b = b * A[j];
            }                
            res.emplace_back(b);
        }
        return res;
    }&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;法2：时间复杂度更低的方法&lt;/strong&gt;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;/p&gt;
&lt;div class=&#39;fancybox-wrapper lazyload-container-unload&#39; data-fancybox=&#39;post-images&#39; href=&#39;http://117.72.66.48/wp-content/uploads/2025/06/image.png&#39;&gt;
  &lt;img class=&#34;lazyload lazyload-style-1&#34; src=&#34;data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+&#34;  loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;985&#34; height=&#34;475&#34; data-original=&#34;http://117.72.66.48/wp-content/uploads/2025/06/image.png&#34; src=&#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC&#34; alt=&#34;&#34; class=&#34;wp-image-193&#34;  sizes=&#34;auto, (max-width: 985px) 100vw, 985px&#34; /&gt;
&lt;/div&gt;&lt;/figure&gt; 
&lt;p&gt;如图所示，矩阵中由对角线1将其分成了上三角和下三角。 *&lt;em&gt;可以发现，B[i]的值可以由两部分相乘得到：左下三角与右上三角，例如，B[2]的值为A[0]&lt;em&gt;A[1]的左下三角，与A[3]到A[n-1]的右上三角相乘得到。&lt;/em&gt;&lt;/em&gt; 分别维护左下三角与右上三角的值，最后相乘，就可以得到结果。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;vector&amp;lt;int&gt; multiply(vector&amp;lt;int&gt;&amp; A) {
        // write code here
        vector&amp;lt;int&gt; res;
        int len = A.size();
        res.resize(len, 1);

        for(int i = 1; i &amp;lt; len; ++i){
            // 先维护左下三角区域
            res[i] = A[i-1] * res[i-1];
        }
        //再计算右上角区域
        int tempA = 1;
        for(int i = len - 2; i &gt;= 0; --i){
            tempA *= A[i + 1];
            res[i] = res[i] * tempA;
        }
        return res;
    }&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no51-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no51-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A8%A1%E6%8B%9F/" term="模拟" label="模拟" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No50.数组中重复的数字</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no50/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no50/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-06-05T05:51:52&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;
  &lt;p&gt;
    在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
  &lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no50/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no50/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;
  &lt;p&gt;
    在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;法1&lt;/strong&gt;：哈希表，时间复杂度On，空间复杂度On&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;bool duplicate(int numbers[], int length, int* duplication) {
	unordered_map&amp;lt;int, int&gt; unmp;
	unmp.reserve(length);
	for (int i = 0; i &amp;lt; length; ++i) {
		if (unmp.find(numbers[i]) == unmp.end()) {
			unmp.insert({ numbers[i],1 });
		}
		else
		{
			*duplication = numbers[i];
			return true;
		}
	}
	return false;
}
&lt;/pre&gt;
&lt;p&gt;**法2：**维护索引表&lt;/p&gt;
&lt;p&gt;理解起来有点困难，最好是自己模拟一下过程。&lt;br&gt;
可以参考下面这段，leetcode评论：&lt;/p&gt;
&lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;
  &lt;p&gt;
    这个原地交换法就相当于分配工作，每个索引代表一个工作岗位，每个岗位必须专业对口，既0索引必须0元素才能上岗。而我们的目的就是找出溢出的人才，既0索引岗位有多个0元素竞争。&lt;br /&gt; 我们先从0索引岗位开始遍历，首先我们看0索引是不是已经专业对口了，如果已经专业对口既nums[0]=0，那我们就跳过0岗位看1岗位。如果0索引没有专业对口，那么我们看现在0索引上的人才调整到他对应的岗位上，比如num[0]=2，那我们就把2这个元素挪到他对应的岗位上既num[2]，这个时候有两种情况:1、num[2]岗位上已经有专业对口的人才了，既num[2]=2，这就说明刚刚那个在num[0]上的2是溢出的人才，我们直接将其返回即可。2、num[2]上的不是专业对口的人才，那我们将num[0]上的元素和num[2]上的元素交换，这样&lt;strong&gt;num[2]就找到专业对口的人才了&lt;/strong&gt;。之后重复这个过程直到帮num[0]找到专业对口的人才，然后以此类推帮num[1]找人才、帮num[2]找人才，直到找到溢出的人才。
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    int findRepeatDocument(vector&amp;lt;int&gt;&amp; documents) {
        int i = 0;
        while(i &amp;lt; documents.size()){
            if(documents[i] == i){ // 如果索引与值相等
                i++;
                continue;
            }
            if(documents[documents[i]] == documents[i]){ // 如果找到了重复的索引
                // 有点递归的感觉 判断的是假如出现documents[2] = 2 和 documents[3] = 2 那么说明已经有重复的索引了 
                return documents[i];
            }else{
                // 例如 2 5 3, 当i=0时
                int tmp = documents[i];  // documents[i] = 2 = tmp
                documents[i] = documents[tmp];  // documents[i] = documents[2] = 3
                documents[tmp] = tmp; // 最后就可以得到 documents[2] = 2 把2这块的索引维护好了
            }
        }
        return -1;
    }
};&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no50/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no50/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%93%88%E5%B8%8C/" term="哈希" label="哈希" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No49.字符串转化为整数</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no49-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B4%E6%95%B0/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no49-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B4%E6%95%B0/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-06-05T05:50:09&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;模拟题，感觉挺复杂的&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    int myAtoi(string str) {
        int len = str.size();
        int i = 0, flag = 1;
        long long base = 0;

        // 跳过前导空格
        while (i &amp;lt; len &amp;&amp; str[i] == &#39; &#39;) {
            i++;
        }

        if (i &amp;lt; len &amp;&amp; (str[i] == &#39;-&#39; || str[i] == &#39;+&#39;)) {
            flag = (str[i] == &#39;-&#39;) ? -1 : 1;
            i++;
        }

        while (i &amp;lt; len &amp;&amp; str[i] &gt;= &#39;0&#39; &amp;&amp; str[i] &amp;lt;= &#39;9&#39;) {
            base = base * 10 + (str[i] - &#39;0&#39;);
            i++;
            
            // 检查溢出
            if (base * flag &gt; INT_MAX) return INT_MAX;
            if (base * flag &amp;lt; INT_MIN) return INT_MIN;
        }

        return flag * base;
    }
};
&lt;/pre&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no49-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B4%E6%95%B0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no49-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B4%E6%95%B0/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;模拟题，感觉挺复杂的&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    int myAtoi(string str) {
        int len = str.size();
        int i = 0, flag = 1;
        long long base = 0;

        // 跳过前导空格
        while (i &amp;lt; len &amp;&amp; str[i] == &#39; &#39;) {
            i++;
        }

        if (i &amp;lt; len &amp;&amp; (str[i] == &#39;-&#39; || str[i] == &#39;+&#39;)) {
            flag = (str[i] == &#39;-&#39;) ? -1 : 1;
            i++;
        }

        while (i &amp;lt; len &amp;&amp; str[i] &gt;= &#39;0&#39; &amp;&amp; str[i] &amp;lt;= &#39;9&#39;) {
            base = base * 10 + (str[i] - &#39;0&#39;);
            i++;
            
            // 检查溢出
            if (base * flag &gt; INT_MAX) return INT_MAX;
            if (base * flag &amp;lt; INT_MIN) return INT_MIN;
        }

        return flag * base;
    }
};
&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no49-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B4%E6%95%B0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no49-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B4%E6%95%B0/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" term="字符串" label="字符串" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A8%A1%E6%8B%9F/" term="模拟" label="模拟" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No48.求两个数相加</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no48-%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9B%B8%E5%8A%A0/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no48-%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9B%B8%E5%8A%A0/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-06-05T05:49:33&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;一般都是位运算，记住怎么用位运算求+吧。 可以参考：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/112407870&#34;&gt;【每日算法Day 66】经典面试题：不用四则运算如何做加法？ – 知乎&lt;/a&gt;&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no48-%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9B%B8%E5%8A%A0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no48-%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9B%B8%E5%8A%A0/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;一般都是位运算，记住怎么用位运算求+吧。 可以参考：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/112407870&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;【每日算法Day 66】经典面试题：不用四则运算如何做加法？ – 知乎&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1）两个数做^运算，得到各位相加不进位的计算结果&lt;br&gt;
2）两个数做&amp;amp;运算，得到进位。因为进位是要加到左一位的，所以需要左移1&lt;br&gt;
3）循环操作，直到进位为0&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;int Add(int num1, int num2) {
        // 最后的循环迭代的结果 会是carry为全0 sum为加和的结果
        // carray表示进位 用&amp;和左移实现
        // sum表示每轮不带进位的结果 用^实现
        while(num2!=0){
            int sum = num1 ^ num2;//不进位的加法
            int carry = (num1 &amp; num2)&amp;lt;&amp;lt;1;//进位
            num1 = sum;
            num2 = carry;
        }
        return num1;
    }&lt;/pre&gt;

                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no48-%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9B%B8%E5%8A%A0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/05/%E5%89%91%E6%8C%87offer67%E9%A2%98-no48-%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9B%B8%E5%8A%A0/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" term="位运算" label="位运算" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No47.求1&#43;2&#43;3&#43;…&#43;n</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/02/%E5%89%91%E6%8C%87offer67%E9%A2%98-no47-%E6%B1%82123-n/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/02/%E5%89%91%E6%8C%87offer67%E9%A2%98-no47-%E6%B1%82123-n/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-06-02T07:24:09&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;
  &lt;p&gt;
    求1+2+3+&amp;#8230;+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
  &lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/02/%E5%89%91%E6%8C%87offer67%E9%A2%98-no47-%E6%B1%82123-n/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/02/%E5%89%91%E6%8C%87offer67%E9%A2%98-no47-%E6%B1%82123-n/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;
  &lt;p&gt;
    求1+2+3+&amp;#8230;+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用短路特性求解。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;int Sum_Solution(int n) {
        n &amp;&amp; (n = n + Sum_Solution(n-1));
        return n;
    }&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/02/%E5%89%91%E6%8C%87offer67%E9%A2%98-no47-%E6%B1%82123-n/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/02/%E5%89%91%E6%8C%87offer67%E9%A2%98-no47-%E6%B1%82123-n/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" term="位运算" label="位运算" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No46.孩子们的游戏(圆圈中最后剩下的数)</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/02/%E5%89%91%E6%8C%87offer67%E9%A2%98-no46-%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/02/%E5%89%91%E6%8C%87offer67%E9%A2%98-no46-%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-06-02T07:23:30&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;&lt;strong&gt;法1:约瑟夫环递归&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;_n_个数相后去掉第m个数，还剩下n−1个数，依然要继续去掉第m个数。由此，从(n,m)的问题变成了(n−1,m)的子问题。时间复杂度和空间复杂度都是On&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/02/%E5%89%91%E6%8C%87offer67%E9%A2%98-no46-%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/02/%E5%89%91%E6%8C%87offer67%E9%A2%98-no46-%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;&lt;strong&gt;法1:约瑟夫环递归&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;_n_个数相后去掉第m个数，还剩下n−1个数，依然要继续去掉第m个数。由此，从(n,m)的问题变成了(n−1,m)的子问题。时间复杂度和空间复杂度都是On&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说实话不理解，先背住吧&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;int f(int n,int m){
    if(n == 1)
        return 0;
    else
        return (f(n-1,m) + m) % n;
}

int LastRemaining_Solution(int n, int m) {
    if(n&amp;lt;1|| m&amp;lt;1)
        return -1;
    return f(n,m);
}&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;法2：暴力模拟&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;int LastRemaining_Solution(int n, int m) {
        if(n == 1) return 0;
        vector&amp;lt;int&gt; child;
        child.resize(n, 0); // 标记是否在圈内 0在 1已出圈
        int cnt = 0; // cnt用以记录出圈的小孩个数
        int j = 0; // j为当前的报数
        for(int i = 0; cnt != n-1; i = (++i) % n){
            if(child[i] == 0){
                j++;    //在圈内 报数
                if(j == m){ 
                    j = 0;
                    child[i] = 1;
                    cnt++;
                }
            }
        }
        for (int i = 0; i &amp;lt; n; i++) { // 找到唯一剩下的孩子
            if (!child[i]) return i;
        }
        return -1;
    }&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/02/%E5%89%91%E6%8C%87offer67%E9%A2%98-no46-%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/02/%E5%89%91%E6%8C%87offer67%E9%A2%98-no46-%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A8%A1%E6%8B%9F/" term="模拟" label="模拟" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No45.扑克牌顺子</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/02/%E5%89%91%E6%8C%87offer67%E9%A2%98-no45-%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/02/%E5%89%91%E6%8C%87offer67%E9%A2%98-no45-%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-06-02T07:22:12&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;模拟写法，时间复杂度Onlogn，花在快排身上。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;bool IsContinuous(vector&amp;lt;int&gt;&amp; numbers) {
        if(numbers.size() == 0) return false;
        sort(numbers.begin(), numbers.end());
        int cnt = 0;
        // 统计赖子个数
        for(auto &amp; i : numbers){
            if(i == 0) cnt++;
        }
        for(int i = 0; i &amp;lt; numbers.size() - 1; i++){
            if(numbers[i] == 0) continue;
            if(numbers[i + 1] == numbers[i]) return false;  // 有重复牌肯定不可能是顺子
            int gap = numbers[i + 1] - numbers[i] - 1;
            if(gap &gt; cnt) return false;     // 赖子不够填
            else cnt -= gap;
        }
        return true;
    }&lt;/pre&gt;
&lt;p&gt;也可以用集合遍历，时间复杂度为On&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/02/%E5%89%91%E6%8C%87offer67%E9%A2%98-no45-%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/02/%E5%89%91%E6%8C%87offer67%E9%A2%98-no45-%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;模拟写法，时间复杂度Onlogn，花在快排身上。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;bool IsContinuous(vector&amp;lt;int&gt;&amp; numbers) {
        if(numbers.size() == 0) return false;
        sort(numbers.begin(), numbers.end());
        int cnt = 0;
        // 统计赖子个数
        for(auto &amp; i : numbers){
            if(i == 0) cnt++;
        }
        for(int i = 0; i &amp;lt; numbers.size() - 1; i++){
            if(numbers[i] == 0) continue;
            if(numbers[i + 1] == numbers[i]) return false;  // 有重复牌肯定不可能是顺子
            int gap = numbers[i + 1] - numbers[i] - 1;
            if(gap &gt; cnt) return false;     // 赖子不够填
            else cnt -= gap;
        }
        return true;
    }&lt;/pre&gt;
&lt;p&gt;也可以用集合遍历，时间复杂度为On&lt;/p&gt;
&lt;p&gt;1、遍历五张牌，遇到大小王（即 0 ）直接跳过。&lt;br&gt;
2、判别重复： 利用 Set 实现遍历判重， Set 的查找方法的时间复杂度为 O(1) ；&lt;br&gt;
3、获取最大 / 最小的牌： 借助辅助变量 ma 和 mi ，遍历统计即可。&lt;/p&gt;
&lt;p&gt;贴个python代码：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;python&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution:
    def IsContinuous(self, numbers):
        # write code here
        repeat = set()
        ma, mi = 0, 14
        for num in numbers:
            if num == 0: continue # 跳过大小王
            ma = max(ma, num) # 最大牌
            mi = min(mi, num) # 最小牌
            if num in repeat: return False # 若有重复，提前返回 false
            repeat.add(num) # 添加牌至 Set
        return ma - mi &amp;lt; 5 # 最大牌 - 最小牌 &amp;lt; 5 则可构成顺子&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/02/%E5%89%91%E6%8C%87offer67%E9%A2%98-no45-%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/02/%E5%89%91%E6%8C%87offer67%E9%A2%98-no45-%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A8%A1%E6%8B%9F/" term="模拟" label="模拟" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No43-44.左旋转字符串、翻转单词序列</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/02/%E5%89%91%E6%8C%87offer67%E9%A2%98-no43-44-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%BA%8F%E5%88%97/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/02/%E5%89%91%E6%8C%87offer67%E9%A2%98-no43-44-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%BA%8F%E5%88%97/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-06-02T07:20:53&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;No43：简单的字符串处理。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;string LeftRotateString(string str, int n) {
        // write code here
        if(str.size() == 0) return {};        
        n = n % str.size();
        if(n == 0) return str;

        string res;

        for(int i = n; i &amp;lt; str.size(); i++){
            res = res + str[i];
        }
        for(int i = 0; i &amp;lt; n; i++){
            res = res + str[i];
        }
        return res;
    }&lt;/pre&gt;
&lt;p&gt;No44：翻转单词序列&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/02/%E5%89%91%E6%8C%87offer67%E9%A2%98-no43-44-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%BA%8F%E5%88%97/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/02/%E5%89%91%E6%8C%87offer67%E9%A2%98-no43-44-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%BA%8F%E5%88%97/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;No43：简单的字符串处理。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;string LeftRotateString(string str, int n) {
        // write code here
        if(str.size() == 0) return {};        
        n = n % str.size();
        if(n == 0) return str;

        string res;

        for(int i = n; i &amp;lt; str.size(); i++){
            res = res + str[i];
        }
        for(int i = 0; i &amp;lt; n; i++){
            res = res + str[i];
        }
        return res;
    }&lt;/pre&gt;
&lt;p&gt;No44：翻转单词序列&lt;/p&gt;
&lt;p&gt;字符串处理&lt;/p&gt;
&lt;p&gt;c++中的string对象，没有内置的split函数，需要自己手写。&lt;br&gt;
可以用&lt;code&gt;istringstream&lt;/code&gt;配合&lt;code&gt;getline&lt;/code&gt;实现。&lt;br&gt;
题外话 ，关于左右值引用的介绍：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/335994370&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;一文读懂C++右值引用和std::move – 知乎&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;vector&amp;lt;string&gt; split(string strs, char s){
        istringstream iss(strs);
        string token;
        vector&amp;lt;string&gt; res;
        while(getline(iss, token, s)){
            res.emplace_back(token);
        }
        return res;
    }
    string ReverseSentence(string str) {
        if(str.size() == 0) return {};
        string res; 
        vector&amp;lt;string&gt; tmp;
        tmp = split(str, &#39; &#39;);
        for(int i = tmp.size() -1; i &gt;=0; i--){
            res = res + tmp[i] + &#34; &#34;;
        }
        res.pop_back();
        return res;
    }&lt;/pre&gt;
&lt;p&gt;另一种O1空间复杂度的算法，整体反转再局部反转。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;string ReverseSentence(string str) {
        if(str.size() == 0) return {};
        reverse(str.begin(), str.end());
        int start = 0;
        str += &#34; &#34;; //加一个&#34; &#34; 方便后续处理
        // .find: 找从pos开始(包括pos处字符)匹配str的位置下标 end = str.find(&#39; &#39;) 找到当前开始第一个&#39; &#39;下标
        for(int end = str.find(&#39; &#39;); end != string::npos; end = str.find(&#39; &#39;, start)){
            // 反转范围为[)
            reverse(str.begin() + start, str.begin() + end);
            start = end + 1;
        }

        str.pop_back(); // 最后要把添加上的空格删掉

        return str;
    }&lt;/pre&gt;

                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/02/%E5%89%91%E6%8C%87offer67%E9%A2%98-no43-44-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%BA%8F%E5%88%97/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/02/%E5%89%91%E6%8C%87offer67%E9%A2%98-no43-44-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%BA%8F%E5%88%97/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" term="字符串" label="字符串" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No41-42.和为S的连续正数序列、和为S的两个数字</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/02/%E5%89%91%E6%8C%87offer67%E9%A2%98-no41-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/02/%E5%89%91%E6%8C%87offer67%E9%A2%98-no41-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-06-02T07:17:39&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;&lt;strong&gt;双指针算法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;法1&lt;/strong&gt;：直接枚举，从头到尾枚举区间，记录出某段区间的值，如果值==sum，把这段区间的值加入res中。&lt;br&gt;
时间复杂度为On√n（n根号n）。因为内层判断不会超过√n次（1+2+3+…+√n &amp;gt; n）。因此空间复杂度为O√n。&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/02/%E5%89%91%E6%8C%87offer67%E9%A2%98-no41-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/02/%E5%89%91%E6%8C%87offer67%E9%A2%98-no41-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;&lt;strong&gt;双指针算法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;法1&lt;/strong&gt;：直接枚举，从头到尾枚举区间，记录出某段区间的值，如果值==sum，把这段区间的值加入res中。&lt;br&gt;
时间复杂度为On√n（n根号n）。因为内层判断不会超过√n次（1+2+3+…+√n &amp;gt; n）。因此空间复杂度为O√n。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;vector&amp;lt;vector&amp;lt;int&gt; &gt; FindContinuousSequence(int sum) {
        // write code here
        if(sum == 0 || sum == 1 || sum == 2) return{};
        vector&amp;lt;vector&amp;lt;int&gt;&gt; res;
        vector&amp;lt;int&gt; temp;

        for(int i = 1; i &amp;lt; sum; i++){
            int curSum = 0;
            for(int j =i; ; j++){
                curSum += j;
                if(curSum &gt; sum){
                    break;
                }else if(curSum == sum){
                    temp.clear();
                    for(int k = i; k &amp;lt;= j; k++){
                        temp.emplace_back(k);                        
                    }
                    res.emplace_back(temp);
                }
            }
        }
            return res;
    }&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;法2&lt;/strong&gt;：滑动窗口 能够实现On的复杂度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路：从某一个数字开始的连续序列和等于目标数如果有，只能有一个，于是我们可以用这个性质来使区间滑动。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;两个指针l、r指向区间首和区间尾，&lt;strong&gt;公式(l+r)∗(r−l+1)/2&lt;/strong&gt;计算区间内部的序列和，如果这个和刚好等于目标数，说明以该区间首开始的序列找到了，记录下区间内的序列，同时以左边开始的起点就没有序列了，于是左区间收缩；如果区间和大于目标数，说明该区间过长需要收缩，只能收缩左边；如果该区间和小于目标数，说明该区间过短需要扩大，只能向右扩大，移动区间尾。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;vector&amp;lt;vector&amp;lt;int&gt; &gt; FindContinuousSequence(int sum) {
        // write code here
        if(sum == 0 || sum == 1 || sum == 2) return{};
        vector&amp;lt;vector&amp;lt;int&gt;&gt; res;
        vector&amp;lt;int&gt; temp;
            int l = 1;
            int r = 2;
            int up = sum / 2 + 1;

            while(l &amp;lt; r &amp;&amp; r &amp;lt;= up){
                int curSum = (l + r) * (r - l + 1) / 2;
                if(curSum == sum){
                    temp.clear();
                    for(int i = l; i &amp;lt;= r; i++){
                        temp.emplace_back(i);
                    }
                    res.emplace_back(temp);
                    l++; // 记得等于条件下，左边界也要收缩
                } else if(curSum &amp;lt; sum){ // 说明序列和小了 r往右边去点
                    r++;
                }else{
                    l++;
                }
            }

            return res;
    }&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;剑指offerNo42：为S的两个数字&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;双指针算法，和41差不多思路&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;vector&amp;lt;int&gt; FindNumbersWithSum(vector&amp;lt;int&gt; array,int sum) {
        if(array.size() == 0 || sum &amp;lt; array.front()) return {};

        int l = 0;
        int r = array.size() - 1;
        int curSum = 0;
        while(l &amp;lt; r){
            curSum = array[l] + array[r];
            if(curSum == sum){
                return {array[l], array[r]};
            }else if(curSum &amp;lt; sum){
                l++;
            }else{
                r--;
            }
        }
        return {};
    }&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/02/%E5%89%91%E6%8C%87offer67%E9%A2%98-no41-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/06/02/%E5%89%91%E6%8C%87offer67%E9%A2%98-no41-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/" term="双指针算法" label="双指针算法" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No40.数组中只出现一次的数字</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/30/%E5%89%91%E6%8C%87offer67%E9%A2%98-no40-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/30/%E5%89%91%E6%8C%87offer67%E9%A2%98-no40-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-30T06:48:06&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;
  &lt;p&gt;
    给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，除某个元素仅出现 &lt;strong&gt;一次&lt;/strong&gt; 外，其余每个元素都恰出现 &lt;strong&gt;三次 。&lt;/strong&gt;请你找出并返回那个只出现了一次的元素。&lt;br /&gt;你必须设计并实现线性时间复杂度的算法且使用常数级空间来解决此问题。
  &lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/30/%E5%89%91%E6%8C%87offer67%E9%A2%98-no40-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/30/%E5%89%91%E6%8C%87offer67%E9%A2%98-no40-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;
  &lt;p&gt;
    给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，除某个元素仅出现 &lt;strong&gt;一次&lt;/strong&gt; 外，其余每个元素都恰出现 &lt;strong&gt;三次 。&lt;/strong&gt;请你找出并返回那个只出现了一次的元素。&lt;br /&gt;你必须设计并实现线性时间复杂度的算法且使用常数级空间来解决此问题。
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;异或、位运算。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有一个简化版的题目：&lt;/p&gt;
&lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;
  &lt;p&gt;
    给你一个 &lt;strong&gt;非空&lt;/strong&gt; 整数数组 &lt;code&gt;nums&lt;/code&gt; ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。&lt;br /&gt; &lt;a href=&#34;https://leetcode.cn/problems/single-number/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://leetcode.cn/problems/single-number/&lt;/a&gt;
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;一个重点：任何数字异或自己结果都是0，即x ^ x = 0&lt;/strong&gt;&lt;br&gt;
本题中，其他数字出现了 3 次。相同的 3 个数字异或的结果是数字本身，即 x ^ x ^ x = x，无法通过简单异或得出只出现一次的数字。&lt;br&gt;
&lt;strong&gt;换种思路，如果有一个数字出现了三次，那他的二进制表示的每一位也要出现3次，如果把这些二进制表示加起来，那么每一位要么是3，要么是0。把数组中所有的数字的二进制表示都加起来，能被3整除，说明要求的数字该位上是0，不能，则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如，[3 3 3 5]&lt;br&gt;
3的二进制为: 0011，5的二进制为0101，把数组的二进制累加起来，可以得到[0 1 3 4]，根据判断，可以还原出0101。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    //判断第index位是不是1
    bool is1(int x, int index){
        if(((x &gt;&gt; index) &amp; 1) == 1) return true;
        return false;
    }

    int singleNumber(vector&amp;lt;int&gt;&amp; nums) {
        if(nums.size() == 0) return 0;
        //遍历每一位
        int base = 0;
        int res = 0;
        while(base &amp;lt; 32){
            int cnt = 0;
            for(auto&amp; i : nums){
                // 对于数组中的每一个数字 判断第base位是不是1
                if(is1(i, base)){
                    cnt++;
                }
            }
            if(cnt % 3 == 1){ //说明要求的那个数，在这个位上是1
                // 移位构造res
                res = res | (1 &amp;lt;&amp;lt; base);
            }
            base++;
        }
        return res;
    }
};&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;剑指offer中还有另外一题，求的是数组中只出现一次的两个数字。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;
  &lt;p&gt;
    给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，除 &lt;strong&gt;2个数字&lt;/strong&gt;外，其余每个元素都恰出现&lt;strong&gt;2次 &lt;/strong&gt;。请你找出并返回&lt;strong&gt;那两个只&lt;/strong&gt;出现了一次的元素。
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    把所有数字异或，最终的结果就是那两个出现一次的数字a,b异或的结果。
  &lt;/li&gt;
  &lt;li&gt;
    把a^b的结果记为x，因为a和b必然不等，所以x肯定不是0。那么&lt;strong&gt;可以找出x的二进制表示中为1的某位。&lt;/strong&gt;
  &lt;/li&gt;
  &lt;li&gt;
    基于这个位，可以将原数组&lt;strong&gt;分堆&lt;/strong&gt;，数字相同的肯定分到同一堆。而要找的两个不同的数字，肯定分到了不同堆里。
  &lt;/li&gt;
  &lt;li&gt;
    最后两堆数组分别异或。得到的两个结果就是要找的两个数。
  &lt;/li&gt;
&lt;/ul&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/30/%E5%89%91%E6%8C%87offer67%E9%A2%98-no40-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/30/%E5%89%91%E6%8C%87offer67%E9%A2%98-no40-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" term="位运算" label="位运算" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No38-39.二叉树的深度、平衡二叉树</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/30/%E5%89%91%E6%8C%87offer67%E9%A2%98-no38-39-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E3%80%81%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/30/%E5%89%91%E6%8C%87offer67%E9%A2%98-no38-39-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E3%80%81%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-30T06:44:58&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;&lt;strong&gt;No38：二叉树的深度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单递归或者层次遍历&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
	int maxDeep = 0;
	int curDeep = 0;
    void dfs(TreeNode* root){
		if(root == nullptr) return;
		curDeep++;
		maxDeep = max(curDeep, maxDeep);
		dfs(root-&gt;left);
		dfs(root-&gt;right);
		curDeep--;
		
	}

	int TreeDepth(TreeNode* pRoot) {
		dfs(pRoot);
		return maxDeep;
    }
};&lt;/pre&gt;
&lt;p&gt;层次遍历方法：&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/30/%E5%89%91%E6%8C%87offer67%E9%A2%98-no38-39-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E3%80%81%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/30/%E5%89%91%E6%8C%87offer67%E9%A2%98-no38-39-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E3%80%81%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;&lt;strong&gt;No38：二叉树的深度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单递归或者层次遍历&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
	int maxDeep = 0;
	int curDeep = 0;
    void dfs(TreeNode* root){
		if(root == nullptr) return;
		curDeep++;
		maxDeep = max(curDeep, maxDeep);
		dfs(root-&gt;left);
		dfs(root-&gt;right);
		curDeep--;
		
	}

	int TreeDepth(TreeNode* pRoot) {
		dfs(pRoot);
		return maxDeep;
    }
};&lt;/pre&gt;
&lt;p&gt;层次遍历方法：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    int maxDepth(TreeNode* root) {
        //空节点没有深度
        if(root == NULL) 
            return 0;
        //队列维护层次后续节点
        queue&amp;lt;TreeNode*&gt; q; 
        //根入队
        q.push(root); 
        //记录深度
        int res = 0; 
        //层次遍历
        while(!q.empty()){ 
            //记录当前层有多少节点
            int n = q.size(); 
            //遍历完这一层，再进入下一层
            for(int i = 0; i &amp;lt; n; i++){ 
                TreeNode* node = q.front();
                q.pop();
                //添加下一层的左右节点
                if(node-&gt;left) 
                    q.push(node-&gt;left);
                if(node-&gt;right)
                    q.push(node-&gt;right);
            }
            //深度加1
            res++; 
        }
        return res;
    }
};
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;NO39：平衡二叉树&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过求左右子树的深度，判断当前节点是否为平衡二叉树； 同时还要递归求左右子节点是否也是平衡二叉树（因为可能有如下情况）：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;A
    / \
   B   C
  /     \
 D       E
/         \
F          G&lt;/pre&gt;
&lt;p&gt;下面这种算法的时间复杂度为On^2，空间复杂度为On&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    int dfs(TreeNode* root){
        if(root == nullptr) return 0;
        int l =  dfs(root-&gt;left);
        int r = dfs(root-&gt;right);
        return (l &gt; r)? l+1 : r+1;
    }

    bool IsBalanced_Solution(TreeNode* pRoot) {
        // write code here
        if(pRoot == nullptr) return true;
        // 分别求出左右子树最大深度
        int lHeight = dfs(pRoot-&gt;left);
        int rHeight = dfs(pRoot-&gt;right);
        if(abs(lHeight-rHeight) &gt;= 2){
            return false;
        }
        return IsBalanced_Solution(pRoot-&gt;left) &amp;&amp; IsBalanced_Solution(pRoot-&gt;right);
    }
};&lt;/pre&gt;
&lt;p&gt;上述方法，实质上遍历了两轮二叉树，因此导致了On^2的时间复杂度。&lt;/p&gt;
&lt;p&gt;**时间复杂度为On的方法：**根据定义，我们只需要后序遍历此树，从树的叶子节点开始计算高度，只要有一个子树不满足定义就返回-1，如果满足继续向上计算高度。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;int dfs(TreeNode* root){
        if(root == nullptr) return 0;
        int l = dfs(root-&gt;left);
        int r = dfs(root-&gt;right);
        if(l == -1 || r == -1 || abs(l-r) &gt;= 2){
            return -1;
        }else{
            return max(l,r) + 1;
        }
    }

    bool IsBalanced_Solution(TreeNode* pRoot) {
        return dfs(pRoot) != -1;
    }&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/30/%E5%89%91%E6%8C%87offer67%E9%A2%98-no38-39-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E3%80%81%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/30/%E5%89%91%E6%8C%87offer67%E9%A2%98-no38-39-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E3%80%81%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A0%91/" term="树" label="树" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E9%80%92%E5%BD%92/" term="递归" label="递归" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No37.第一个只出现一次的字符</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/30/%E5%89%91%E6%8C%87offer67%E9%A2%98-no37-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/30/%E5%89%91%E6%8C%87offer67%E9%A2%98-no37-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-30T06:42:01&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;用两个二分板子，分别是找左边界和右边界的二分。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int整型vector 
     * @param k int整型 
     * @return int整型
     */
    int GetNumberOfK(vector&amp;lt;int&gt;&amp; nums, int k) {
        // write code here
        if(k &gt; nums.back() || k &amp;lt; nums.front() || nums.size() == 0) return 0;
        //用两个求左边界的二分
        int l = 0;
        int r = nums.size() - 1;
        while(l &amp;lt; r){
            int mid = l + r &gt;&gt; 1;
            if(nums[mid] &amp;lt; k){
                l = mid + 1;
            }else{
                r = mid;
            }
        }
        int index1 = l;
        l = 0, r = nums.size() - 1;
        // 找出k的右边界
        while(l &amp;lt; r){
            int mid = l + r + 1 &gt;&gt; 1;
            if(nums[mid] &amp;lt;= k){
                l = mid;
            }else{
                r = mid - 1;
            }
        }
        return l - index1 + 1;
    }
};&lt;/pre&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/30/%E5%89%91%E6%8C%87offer67%E9%A2%98-no37-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/30/%E5%89%91%E6%8C%87offer67%E9%A2%98-no37-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;用两个二分板子，分别是找左边界和右边界的二分。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int整型vector 
     * @param k int整型 
     * @return int整型
     */
    int GetNumberOfK(vector&amp;lt;int&gt;&amp; nums, int k) {
        // write code here
        if(k &gt; nums.back() || k &amp;lt; nums.front() || nums.size() == 0) return 0;
        //用两个求左边界的二分
        int l = 0;
        int r = nums.size() - 1;
        while(l &amp;lt; r){
            int mid = l + r &gt;&gt; 1;
            if(nums[mid] &amp;lt; k){
                l = mid + 1;
            }else{
                r = mid;
            }
        }
        int index1 = l;
        l = 0, r = nums.size() - 1;
        // 找出k的右边界
        while(l &amp;lt; r){
            int mid = l + r + 1 &gt;&gt; 1;
            if(nums[mid] &amp;lt;= k){
                l = mid;
            }else{
                r = mid - 1;
            }
        }
        return l - index1 + 1;
    }
};&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/30/%E5%89%91%E6%8C%87offer67%E9%A2%98-no37-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/30/%E5%89%91%E6%8C%87offer67%E9%A2%98-no37-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" term="二分查找" label="二分查找" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No36.两个链表的第一个公共节点</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/30/%E5%89%91%E6%8C%87offer67%E9%A2%98-no35-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/30/%E5%89%91%E6%8C%87offer67%E9%A2%98-no35-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-30T06:41:01&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;双指针算法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;法1：&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    计算 &lt;code&gt;List1&lt;/code&gt; 和 &lt;code&gt;List2&lt;/code&gt; 的长度 &lt;code&gt;len1&lt;/code&gt; 和 &lt;code&gt;len2&lt;/code&gt;。
  &lt;/li&gt;
  &lt;li&gt;
    让较长的链表的指针先走 &lt;code&gt;|len1 - len2|&lt;/code&gt; 步。
  &lt;/li&gt;
  &lt;li&gt;
    然后两个指针一起走，直到相遇或到达 &lt;code&gt;NULL&lt;/code&gt;。
  &lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;struct ListNode* FindFirstCommonNode(struct ListNode* pHead1, struct ListNode* pHead2 ) {
    // write code here
    if( pHead1 == NULL || pHead2 == NULL) return NULL;
    struct ListNode* cur1 = pHead1;
    struct ListNode* cur2 = pHead2;
    int len1 = 0;
    int len2 = 0;
    // 让更长的先走 |len1-len2|步
    while(cur1 != NULL){
        ++len1;
        cur1 = cur1-&gt;next;
    }
    while(cur2 != NULL){
        ++len2;
        cur2 = cur2-&gt;next;
    }
    cur1 = pHead1;
    cur2 = pHead2;
    if(len1 &gt; len2){
        while(len1 &gt; len2){
            cur1 = cur1-&gt;next;
            len1--;
        }
    }else if(len2 &gt; len1){
        while(len2 &gt; len1){
            cur2 = cur2-&gt;next;
            len2--;
        }
    }
    while(cur1 != cur2){
        cur1 = cur1-&gt;next;
        cur2 = cur2-&gt;next;
    }
    return cur1;
}&lt;/pre&gt;
&lt;p&gt;**法2：**和法1差不多，直接走，有交点或者是都为NULL，就可以退出循环。&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/30/%E5%89%91%E6%8C%87offer67%E9%A2%98-no35-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/30/%E5%89%91%E6%8C%87offer67%E9%A2%98-no35-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;双指针算法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;法1：&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    计算 &lt;code&gt;List1&lt;/code&gt; 和 &lt;code&gt;List2&lt;/code&gt; 的长度 &lt;code&gt;len1&lt;/code&gt; 和 &lt;code&gt;len2&lt;/code&gt;。
  &lt;/li&gt;
  &lt;li&gt;
    让较长的链表的指针先走 &lt;code&gt;|len1 - len2|&lt;/code&gt; 步。
  &lt;/li&gt;
  &lt;li&gt;
    然后两个指针一起走，直到相遇或到达 &lt;code&gt;NULL&lt;/code&gt;。
  &lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;struct ListNode* FindFirstCommonNode(struct ListNode* pHead1, struct ListNode* pHead2 ) {
    // write code here
    if( pHead1 == NULL || pHead2 == NULL) return NULL;
    struct ListNode* cur1 = pHead1;
    struct ListNode* cur2 = pHead2;
    int len1 = 0;
    int len2 = 0;
    // 让更长的先走 |len1-len2|步
    while(cur1 != NULL){
        ++len1;
        cur1 = cur1-&gt;next;
    }
    while(cur2 != NULL){
        ++len2;
        cur2 = cur2-&gt;next;
    }
    cur1 = pHead1;
    cur2 = pHead2;
    if(len1 &gt; len2){
        while(len1 &gt; len2){
            cur1 = cur1-&gt;next;
            len1--;
        }
    }else if(len2 &gt; len1){
        while(len2 &gt; len1){
            cur2 = cur2-&gt;next;
            len2--;
        }
    }
    while(cur1 != cur2){
        cur1 = cur1-&gt;next;
        cur2 = cur2-&gt;next;
    }
    return cur1;
}&lt;/pre&gt;
&lt;p&gt;**法2：**和法1差不多，直接走，有交点或者是都为NULL，就可以退出循环。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;struct ListNode* FindFirstCommonNode(struct ListNode* pHead1, struct ListNode* pHead2) {
    if (pHead1 == NULL || pHead2 == NULL) return NULL;
    
    struct ListNode* cur1 = pHead1;
    struct ListNode* cur2 = pHead2;
    
    while (cur1 != cur2) {
        cur1 = (cur1 == NULL) ? pHead2 : cur1-&gt;next;
        cur2 = (cur2 == NULL) ? pHead1 : cur2-&gt;next;
    }
    return cur1; // 返回交点或NULL（无交点）
}&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/30/%E5%89%91%E6%8C%87offer67%E9%A2%98-no35-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/30/%E5%89%91%E6%8C%87offer67%E9%A2%98-no35-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/" term="双指针算法" label="双指针算法" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E9%93%BE%E8%A1%A8/" term="链表" label="链表" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No35.数组中的逆序对</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/30/%E5%89%91%E6%8C%87offer67%E9%A2%98-no35-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/30/%E5%89%91%E6%8C%87offer67%E9%A2%98-no35-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-30T06:40:04&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;&lt;strong&gt;归并排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在合并数组的时候，当发现右边的小于左边的时候，此时可以直接求出当前产生的逆序对的个数。&lt;br&gt;
可以参考acwing的题解：&lt;a href=&#34;https://www.acwing.com/file_system/file/content/whole/index/content/6664386/&#34;&gt;AcWing 788. 【算法基础课】逆序对的数量（归并排序） – AcWing&lt;/a&gt;&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/30/%E5%89%91%E6%8C%87offer67%E9%A2%98-no35-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/30/%E5%89%91%E6%8C%87offer67%E9%A2%98-no35-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;&lt;strong&gt;归并排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在合并数组的时候，当发现右边的小于左边的时候，此时可以直接求出当前产生的逆序对的个数。&lt;br&gt;
可以参考acwing的题解：&lt;a href=&#34;https://www.acwing.com/file_system/file/content/whole/index/content/6664386/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AcWing 788. 【算法基础课】逆序对的数量（归并排序） – AcWing&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;#include &amp;lt;vector&gt;
class Solution {
public:
    long long merge(vector&amp;lt;int&gt;&amp; a, int l, int r, vector&amp;lt;int&gt;&amp; tmp){
        if( l == r) return 0;
        int mid = l + r &gt;&gt; 1;
        long long res = (merge(a, l, mid, tmp) + merge(a, mid+1, r,tmp)) % 1000000007;
        
        int i = l;
        int j = mid + 1;
        int k = 0;
        while(i &amp;lt;= mid &amp;&amp; j &amp;lt;= r){
            if(a[i] &amp;lt;= a[j]) tmp[k++] = a[i++];
            else{
                tmp[k++] = a[j++];
                //是逆序对 结果累加
                res += mid - i + 1;
            }
        }
        // 处理剩余的
        while (i &amp;lt;= mid) tmp[k++] = a[i++];
        while (j &amp;lt;= r) tmp[k++] = a[j++];
        for(int i = 0, j = l; j&amp;lt;=r; i++, j++){
            a[j] = tmp[i];
        }
        return res % 1000000007;
    }

    int InversePairs(vector&amp;lt;int&gt;&amp; nums) {
        if(nums.size() &amp;lt; 2) return 0;
        // tmp用以暂存合并后的结果
        vector&amp;lt;int&gt; tmp(nums.size());
        return merge(nums, 0, nums.size() - 1, tmp);
    }
};&lt;/pre&gt;

                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/30/%E5%89%91%E6%8C%87offer67%E9%A2%98-no35-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/30/%E5%89%91%E6%8C%87offer67%E9%A2%98-no35-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%8E%92%E5%BA%8F/" term="排序" label="排序" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%95%B0%E7%BB%84/" term="数组" label="数组" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No34.第一个只出现一次的字符</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no34-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no34-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-28T04:18:00&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;哈希表记录出现次数即可。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;int FirstNotRepeatingChar(string str) {
        if(str.size() == 0) return -1;
        std::unordered_map&amp;lt;char, int&gt; mp; // 存字符出现的次数        
        for(int i = 0; i &amp;lt; str.size(); i++){
            //cpp string的[]返回是char类型
            mp[str[i]]++;
        }
        // 基于mp 可以知道哪些字符只出现过一次
        for(int i = 0; i &amp;lt; str.size(); i++){
            if(mp[str[i]] == 1){
                //说明当前的这个字符，只出现过一次 并且是第一个
                return i;
            }
        }
        return -1;

    }&lt;/pre&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no34-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no34-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;哈希表记录出现次数即可。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;int FirstNotRepeatingChar(string str) {
        if(str.size() == 0) return -1;
        std::unordered_map&amp;lt;char, int&gt; mp; // 存字符出现的次数        
        for(int i = 0; i &amp;lt; str.size(); i++){
            //cpp string的[]返回是char类型
            mp[str[i]]++;
        }
        // 基于mp 可以知道哪些字符只出现过一次
        for(int i = 0; i &amp;lt; str.size(); i++){
            if(mp[str[i]] == 1){
                //说明当前的这个字符，只出现过一次 并且是第一个
                return i;
            }
        }
        return -1;

    }&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no34-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no34-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%93%88%E5%B8%8C/" term="哈希" label="哈希" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No33.第N个丑数</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no33-%E7%AC%ACn%E4%B8%AA%E4%B8%91%E6%95%B0/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no33-%E7%AC%ACn%E4%B8%AA%E4%B8%91%E6%95%B0/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-28T04:17:20&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;数学模拟题，&lt;/p&gt;
&lt;p&gt;只包含质因子2、3和5的数称作丑数，所以丑数的形式实质上是：&lt;strong&gt;2&lt;sup&gt;x&lt;/sup&gt;3&lt;sup&gt;y&lt;/sup&gt;5&lt;sup&gt;z&lt;/sup&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于x、y、z的理解，把他们视作三个独立维护的指针，可以想象有三个队列：&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no33-%E7%AC%ACn%E4%B8%AA%E4%B8%91%E6%95%B0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no33-%E7%AC%ACn%E4%B8%AA%E4%B8%91%E6%95%B0/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;数学模拟题，&lt;/p&gt;
&lt;p&gt;只包含质因子2、3和5的数称作丑数，所以丑数的形式实质上是：&lt;strong&gt;2&lt;sup&gt;x&lt;/sup&gt;3&lt;sup&gt;y&lt;/sup&gt;5&lt;sup&gt;z&lt;/sup&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于x、y、z的理解，把他们视作三个独立维护的指针，可以想象有三个队列：&lt;/p&gt;
&lt;pre class=&#34;wp-block-preformatted&#34;&gt;队列2: 1×2 → 2×2 → 3×2 → 4×2 → ...&lt;br /&gt;队列3: 1×3 → 2×3 → 3×3 → 4×3 → ...&lt;br /&gt;队列5: 1×5 → 2×5 → 3×5 → 4×5 → ...&lt;/pre&gt;
&lt;p&gt;每次取三个队首的最小值，并移动对应指针。res就是要比这对求出这三个队列中的最小值。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;int GetUglyNumber_Solution(int index) {
        if(index == 0) return 0;
        // write code here
        // res 用以维护得到的丑数序列
        vector&amp;lt;long long&gt; res(index);
        res[0] = 1;
        // 丑数实质是2^x * 3^y * 5^z
        // x y z 用以标记2，3，5乘的次数
        int x = 0,y = 0, z = 0;
        for(int i = 1; i &amp;lt; index; i++){
            // 因为每个res都是一个丑数，求出下一个res肯定是由先前的丑数*2/*3/*5出来的，所以维护三个不同的指针，指向先前不同的丑数，当前的丑数就是这三个中最小的。
            res[i] = min(res[x]*2, min(res[y]*3, res[z]*5));
            if(res[i] == res[x]*2) x++;
            if(res[i] == res[y]*3) y++;
            if(res[i] == res[z]*5) z++;
        }
        return res[index - 1];
    }&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no33-%E7%AC%ACn%E4%B8%AA%E4%B8%91%E6%95%B0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no33-%E7%AC%ACn%E4%B8%AA%E4%B8%91%E6%95%B0/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A8%A1%E6%8B%9F/" term="模拟" label="模拟" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No32.把数组排成最小的数</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no32-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no32-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-28T04:16:09&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;**法1：**重载比较运算符&lt;/p&gt;
&lt;p&gt;如果字符串a拼接b的得到的数字大于b拼接a，那么肯定b应该排在a的前面，我们要就按照这样的次序将排序的比较重载就可以了。&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no32-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no32-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;**法1：**重载比较运算符&lt;/p&gt;
&lt;p&gt;如果字符串a拼接b的得到的数字大于b拼接a，那么肯定b应该排在a的前面，我们要就按照这样的次序将排序的比较重载就可以了。&lt;/p&gt;
&lt;p&gt;**PS：**重载比较运算符，如何确定是升序还是降序？1. &lt;strong&gt;核心规则&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    &lt;strong&gt;升序&lt;/strong&gt;：当 &lt;code&gt;a &amp;lt; b&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 时，排序算法会将 &lt;code&gt;a&lt;/code&gt; 放在 &lt;code&gt;b&lt;/code&gt; 前面（即 &lt;code&gt;a&lt;/code&gt; 比 &lt;code&gt;b&lt;/code&gt; 小，按从小到大排列）。
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;降序&lt;/strong&gt;：当 &lt;code&gt;a &gt; b&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 时，排序算法会将 &lt;code&gt;a&lt;/code&gt; 放在 &lt;code&gt;b&lt;/code&gt; 前面（即 &lt;code&gt;a&lt;/code&gt; 比 &lt;code&gt;b&lt;/code&gt; 大，按从大到小排列）。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;std::sort(vec.begin(), vec.end(), [](const auto&amp; a, const auto&amp; b) {
    return a.value &gt; b.value; // 降序
});&lt;/pre&gt;
&lt;p&gt;题解答案如下：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;string PrintMinNumber(vector&amp;lt;int&gt;&amp; numbers) {
        // write code here
        string res = &#34;&#34;;
        if(numbers.size() == 0) return res;
        vector&amp;lt;string&gt; sv;
        for(auto&amp; i : numbers){
            sv.emplace_back(std::to_string(i));
        }
        sort(sv.begin(), sv.end(), cmp);
        for(auto&amp; i : sv){
            res += i;
        }
        return res;
    }&lt;/pre&gt;
&lt;p&gt;**法2：**冒泡排序，和法1的思路一样。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;string PrintMinNumber(vector&amp;lt;int&gt;&amp; numbers) {
        // write code here
        string res = &#34;&#34;;
        if(numbers.size() == 0) return  res;
        vector&amp;lt;string&gt; sv;
        for(auto&amp; i : numbers){
            sv.emplace_back(std::to_string(i));
        }

        for(int i = 0; i &amp;lt; numbers.size() - 1; ++i){
            for(int j = 0; j &amp;lt; numbers.size() - i - 1; ++j){
                string s1 = sv[j] + sv[j + 1];
                string s2 = sv[j + 1] + sv[j];
                if(s1 &gt; s2){
                    swap(sv[j], sv[j+1]);
                }
            }
        }

       for(auto &amp; i : sv){
        res += i;
       }
        return res;
    }&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no32-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no32-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" term="字符串" label="字符串" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No31.整数中1出现的次数</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no31-%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no31-%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-28T04:14:30&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;感觉像是模拟题，&lt;br&gt;
&lt;strong&gt;法1&lt;/strong&gt;，暴力遍历，时间复杂度应该是On&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    int get1(int x){
        int sum = 0;
        while(x){
            if(x % 10 == 1){
                sum++;
            }
            x = x / 10;
        }
        return sum;
    }
    int NumberOf1Between1AndN_Solution(int n) {
        int res = 0;
        for(int i = 1; i&amp;lt;=n; ++i){
            res += get1(i);
        }
        return res;
    }
};&lt;/pre&gt;
&lt;p&gt;方法2，参考&lt;a href=&#34;https://interviewguide.cn/notes/03-hunting_job/03-algorithm/02-sword-offer/31-%E5%89%91%E6%8C%87offer.html&#34;&gt;No31、整数中1出现的次数 | 阿秀的学习笔记&lt;/a&gt;，不是很理解，有空再刷吧。&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no31-%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no31-%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;感觉像是模拟题，&lt;br&gt;
&lt;strong&gt;法1&lt;/strong&gt;，暴力遍历，时间复杂度应该是On&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    int get1(int x){
        int sum = 0;
        while(x){
            if(x % 10 == 1){
                sum++;
            }
            x = x / 10;
        }
        return sum;
    }
    int NumberOf1Between1AndN_Solution(int n) {
        int res = 0;
        for(int i = 1; i&amp;lt;=n; ++i){
            res += get1(i);
        }
        return res;
    }
};&lt;/pre&gt;
&lt;p&gt;方法2，参考&lt;a href=&#34;https://interviewguide.cn/notes/03-hunting_job/03-algorithm/02-sword-offer/31-%E5%89%91%E6%8C%87offer.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;No31、整数中1出现的次数 | 阿秀的学习笔记&lt;/a&gt;，不是很理解，有空再刷吧。&lt;/p&gt;

                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no31-%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no31-%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A8%A1%E6%8B%9F/" term="模拟" label="模拟" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No30.连续子树的最大和</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no30-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no30-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-28T04:13:39&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;&lt;strong&gt;动态规划&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方法1，可以通过暴力On^2的方法，循环两次求出每个子数组的和对比。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;法2.DP&lt;/strong&gt;&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no30-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no30-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;&lt;strong&gt;动态规划&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方法1，可以通过暴力On^2的方法，循环两次求出每个子数组的和对比。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;法2.DP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设dp[i]，dp[i]代表以array[i]为结尾的连续子数组最大和。 转移方程为，dp[i] = max(array[i]，dp[i-1] + array[i])，理解如下：&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    因为以第n个数为结尾，所以array[n]是必然被选择的
  &lt;/li&gt;
  &lt;li&gt;
    基于dp[n-1]的值，如果dp[n-1]&gt;0，我们加上这个正数，值必然会增大
  &lt;/li&gt;
  &lt;li&gt;
    如果dp[n-1]&lt;0,那么加上负数，值就会减小，不如不要前面的结果，只要当前这个数，结果反而更优。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;#include &amp;lt;vector&gt;
class Solution {
public:
    int FindGreatestSumOfSubArray(vector&amp;lt;int&gt;&amp; array) {
        // write code here
        if(array.size() == 1) return array.front();
        int res = array.front();
        vector&amp;lt;int&gt; dp;
        dp.resize(array.size() + 10, 0);
        
        dp[0] = array.front();

        for(int i = 1; i&amp;lt;array.size(); ++i){
            dp[i] = max(array[i], dp[i-1] + array[i]);
            res = max(dp[i], res);
        }
        
        return res;

    }
};&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no30-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no30-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/dp/" term="DP" label="DP" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No29.最小的k个数</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no29-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no29-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-28T04:12:20&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;要求空间复杂度On，时间复杂度O(nlogk)。&lt;/p&gt;
&lt;p&gt;一般我们说 &lt;code&gt;topK&lt;/code&gt; 问题，就可以用大顶堆或小顶堆来实现&lt;br&gt;
&lt;strong&gt;最大的 K 个&lt;/strong&gt;：小顶堆&lt;br&gt;
&lt;strong&gt;最小的 K 个&lt;/strong&gt;：大顶堆&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no29-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no29-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;要求空间复杂度On，时间复杂度O(nlogk)。&lt;/p&gt;
&lt;p&gt;一般我们说 &lt;code&gt;topK&lt;/code&gt; 问题，就可以用大顶堆或小顶堆来实现&lt;br&gt;
&lt;strong&gt;最大的 K 个&lt;/strong&gt;：小顶堆&lt;br&gt;
&lt;strong&gt;最小的 K 个&lt;/strong&gt;：大顶堆&lt;/p&gt;
&lt;p&gt;堆是一种非线性结构，可以把堆看作一棵二叉树，也可以看作一个数组，即：&lt;strong&gt;堆就是利用完全二叉树的结构来维护的一维数组&lt;/strong&gt;。&lt;br&gt;
&lt;strong&gt;注意！大顶堆or小顶堆并非是从大到小的序列，因此才需要堆排序！&lt;/strong&gt; 堆可以分为大顶堆和小顶堆，大顶堆在内存中的一维存储（通常用数组或 &lt;code&gt;std::vector&lt;/code&gt; 表示）满足以下性质：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;堆顶元素&lt;/strong&gt;（最大值）位于数组的第一个位置（&lt;code&gt;arr[0]&lt;/code&gt;）。&lt;br&gt;
对于任意节点&lt;code&gt;arr[i]&lt;/code&gt;：&lt;br&gt;
其左子节点为 &lt;code&gt;arr[2*i + 1]&lt;/code&gt;。&lt;br&gt;
其右子节点为 &lt;code&gt;arr[2*i + 2]&lt;/code&gt;。&lt;br&gt;
其父节点为 &lt;code&gt;arr[(i-1)/2]&lt;/code&gt;（向下取整）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;堆的性质&lt;/strong&gt;：&lt;br&gt;
任意节点的值 ≥ 其子节点的值（大顶堆）。&lt;br&gt;
&lt;strong&gt;大顶堆&lt;/strong&gt;：每个结点的值都大于或等于其左右孩子结点的值。&lt;br&gt;
&lt;strong&gt;小顶堆&lt;/strong&gt;：每个结点的值都小于或等于其左右孩子结点的值。&lt;/p&gt;
&lt;p&gt;C++STL中的优先队列可以实现大根堆或小根堆，可以参考blog：&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/qq_38210354/article/details/107506784&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;C++ | STL | 大顶堆 | 小顶堆 | std::priority_queue_c++ stl大顶堆-CSDN博客&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/335322846&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;大顶堆/小顶堆的构建以及排序的应用 – 知乎&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;//构造一个空的优先队列（此优先队列默认为大顶堆）
priority_queue&amp;lt;int&gt; big_heap;   
//另一种构建大顶堆的方法
priority_queue&amp;lt;int,vector&amp;lt;int&gt;,less&amp;lt;int&gt;&gt; big_heap2;   
//构建小顶堆
priority_queue&amp;lt;int, vector&amp;lt;int&gt;, greater&amp;lt;&gt;&gt; less_xheap;
&lt;/pre&gt;
&lt;p&gt;因此本题求最小的k个数，可以维护一个大顶堆，当堆中的数目大于k，说明已经爆了，把堆顶的元素pop出去，最后留下来的k个一定是最小元素。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;#include &amp;lt;vector&gt;
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param input int整型vector 
     * @param k int整型 
     * @return int整型vector
     */
     std:: priority_queue&amp;lt;int&gt; heap;

    vector&amp;lt;int&gt; GetLeastNumbers_Solution(vector&amp;lt;int&gt;&amp; input, int k) {
        // write code here
        if(k == 0) return{};
        if(input.size() &amp;lt;= k) return input;
        vector&amp;lt;int&gt; res;
        for(auto&amp; i : input){
            if(heap.size() &amp;lt;= k){
                heap.push(i);
            }
            if(heap.size() &gt; k){
                heap.pop();
            }
        }
        while(!heap.empty()){
            res.emplace_back(heap.top());
            heap.pop();
        }
        return res;
    }
};&lt;/pre&gt;

                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no29-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no29-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/" term="堆排序" label="堆排序" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No28.数组中出现次数超过一半的数字</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no28-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no28-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-28T04:09:25&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;感觉面试会考 有两种常规方法，哈希表与排序。但是做不到空间复杂度O1，时间复杂度On。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;投票法：&lt;/strong&gt; 核心思想是，如果我们把众数记为 +1，把其他数记为 −1，将它们全部加起来，显然和大于 ``，从结果本身我们可以看出众数比其他数多。&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no28-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no28-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;感觉面试会考 有两种常规方法，哈希表与排序。但是做不到空间复杂度O1，时间复杂度On。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;投票法：&lt;/strong&gt; 核心思想是，如果我们把众数记为 +1，把其他数记为 −1，将它们全部加起来，显然和大于 ``，从结果本身我们可以看出众数比其他数多。&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    选择一个cnt初始化为0，选择一个res
  &lt;/li&gt;
  &lt;li&gt;
    遍历数组，如果cnt为0的时候，就选择当前数字作为res
  &lt;/li&gt;
  &lt;li&gt;
    若cnt不为0，res=当前数字，cnt++，否则&amp;#8211;。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param numbers int整型vector 
     * @return int整型
     */
    int MoreThanHalfNum_Solution(vector&amp;lt;int&gt;&amp; numbers) {
        // write code here
        int cnt = 0;
        int res = numbers.at(0);
        for(auto&amp; i : numbers){
            if(cnt == 0){
                res = i;
                cnt++;
            }else{
                if(res == i) cnt++;
                else cnt--;
            }
        }
        return res;
    }
};&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no28-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no28-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A8%A1%E6%8B%9F/" term="模拟" label="模拟" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No27.字符串的排列</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no27-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no27-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-28T04:07:52&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;类似dfs全排列问题。&lt;/p&gt;
&lt;p&gt;有一道相似的题目，可以参考acwing的解析：&lt;a href=&#34;https://www.acwing.com/solution/content/30988/&#34;&gt;AcWing 842. 排列数字–深度优先遍历代码+注释 – AcWing&lt;/a&gt;，题目如下：&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no27-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no27-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;类似dfs全排列问题。&lt;/p&gt;
&lt;p&gt;有一道相似的题目，可以参考acwing的解析：&lt;a href=&#34;https://www.acwing.com/solution/content/30988/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AcWing 842. 排列数字–深度优先遍历代码+注释 – AcWing&lt;/a&gt;，题目如下：&lt;/p&gt;
&lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;
  &lt;p&gt;
    给定一个整数 nn，将数字 1∼n排成一排，将会有很多种排列方法。&lt;br /&gt;现在，请你按照字典序将所有的排列方法输出。
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;算法：&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    用 path 数组保存排列，当排列的长度为 n 时，是一种方案，输出。
  &lt;/li&gt;
  &lt;li&gt;
    用 state 数组表示数字是否用过。当 state[i] 为 1 时：i 已经被用过，state[i] 为 0 时，i 没有被用过。
  &lt;/li&gt;
  &lt;li&gt;
    dfs(i) 表示的含义是：在 path[i] 处填写数字，然后递归的在下一个位置填写数字。
  &lt;/li&gt;
  &lt;li&gt;
    回溯：第 i 个位置填写某个数字的所有情况都遍历后， 第 i 个位置填写下一个数字。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;#include &amp;lt;iostream&gt;
using namespace std;
int n;
int path[10];
bool st[10];

void dfs(int u, int n) { //从第u个位置开始看, u代表当前的位数
    if (u == n) { // u已经到达n了，说明递归到头了
        for (int i = 0; i &amp;lt; n; i++) {
            cout &amp;lt;&amp;lt; path[i] &amp;lt;&amp;lt; &#34; &#34;;
        }
        cout &amp;lt;&amp;lt; endl;
    }
    for (int i = 1; i &amp;lt;= n; i++) {
        if (st[i] == false) { // 如果数字 i 没有被用过
            path[u] = i;
            st[i] = true;
            dfs(u + 1, n);
            // 递归出来，恢复现场
            path[u] = 0;
            st[i] = false;
        }
    }
}
int main() {
    cin &gt;&gt; n;
    dfs(0, n); //从第u个位置开始看
    return 0;
}&lt;/pre&gt;
&lt;p&gt;本题和排数字差不多，题解如下（摘自牛客）：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;#include &amp;lt;vector&gt;
class Solution {
  public:

    std::unordered_set&amp;lt;string&gt; set;
    vector&amp;lt;bool&gt; state;
    string path;

    vector&amp;lt;string&gt; Permutation(string str) {
        if(str.empty()) return {};
        state.resize(str.size() + 10, false);
        dfs(0, str);
        vector&amp;lt;string&gt; ans;
        for(auto&amp; s : set){
            ans.emplace_back(s);
        }
        return ans;
    }
    void dfs(int u, string&amp; str) {
        if(u == str.size()){
            set.insert(path);
        }
        for(int i = 0; i&amp;lt;str.size(); ++i){
            if(state[i] == false){
                state[i] = true;
                path.push_back(str.at(i));
                dfs(u+1, str);
                // 回溯状态
                state[i] = false;
                path.pop_back();
            }
        }
    }
};&lt;/pre&gt;

                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no27-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/28/%E5%89%91%E6%8C%87offer67%E9%A2%98-no27-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" term="字符串" label="字符串" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E9%80%92%E5%BD%92/" term="递归" label="递归" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No26.二叉搜索树与双向链表</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/26/%E5%89%91%E6%8C%87offer67%E9%A2%98-no26-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/26/%E5%89%91%E6%8C%87offer67%E9%A2%98-no26-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-26T04:00:45&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;
  &lt;p&gt;
    输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。&lt;br /&gt;要求：空间复杂度O(1)（即在原树上操作），时间复杂度 O(n^2)&lt;br /&gt;要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继
  &lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/26/%E5%89%91%E6%8C%87offer67%E9%A2%98-no26-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/26/%E5%89%91%E6%8C%87offer67%E9%A2%98-no26-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;
  &lt;p&gt;
    输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。&lt;br /&gt;要求：空间复杂度O(1)（即在原树上操作），时间复杂度 O(n^2)&lt;br /&gt;要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;二叉搜索树：左&amp;lt;根&amp;lt;右&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;法1：中序遍历&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;将二叉搜索树进行中序遍历可以得到由小到大的顺序排列&lt;/strong&gt;，因此本题最直接的想法就是进行中序遍历。 将中序遍历的结果用数组存储下来，得到的数组是有从小到大顺序的。 最后将数组中的结点依次连接即可。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
	std::vector&amp;lt;TreeNode*&gt; v;
	//中序遍历存数组里
	void dfs(TreeNode* root){
		if(root == nullptr)	return;
		dfs(root-&gt;left);
		v.emplace_back(root);
		dfs(root-&gt;right);
	}
    TreeNode* Convert(TreeNode* pRootOfTree) {
		if(pRootOfTree == nullptr) return nullptr;
		dfs(pRootOfTree);
		//中序遍历二叉搜索树后的结果就是排序好的
		int len = v.size();
		auto head = v[0];
		//需要特判元素为1个的情况，元素1个以上，首尾元素需要特判
		if(len &gt; 1){
			v[0]-&gt;right = v[1];
			for(int i = 1; i&amp;lt;len - 1; ++i){
				v[i]-&gt;left = v[i-1];
				v[i]-&gt;right = v[i + 1];
			}
		}
		if(len &gt; 1) v[len-1]-&gt;left = v[len-2];
		return head;
    }
};&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;法2：线索二叉树&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以参考：&lt;a href=&#34;https://blog.csdn.net/weixin_54186646/article/details/124435916&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;线索二叉树（图解+完整代码）-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;
  &lt;p&gt;
    为什么需要线索二叉树？
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;知道了前驱和后继信息，就可以把二叉树看作一个&lt;strong&gt;链表结构&lt;/strong&gt;，从而可以像遍历链表那样来遍历二叉树，&lt;strong&gt;进而提高效率&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中序线索二叉树的方法:&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    若结点的左子树为空，则该结点的左孩子指针指向其前驱结点
  &lt;/li&gt;
  &lt;li&gt;
    若结点的右子树为空，则该结点的右孩子指针指向其后继结点 例如下图，橙色为左，蓝色为右。中序遍历序列是136810，1的左子树会指向它的前驱（无），6的右子树会指向它的后继（8）。
  &lt;/li&gt;
&lt;/ul&gt;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;
&lt;div class=&#39;fancybox-wrapper lazyload-container-unload&#39; data-fancybox=&#39;post-images&#39; href=&#39;http://117.72.66.48/wp-content/uploads/2025/05/image.png&#39;&gt;
  &lt;img class=&#34;lazyload lazyload-style-1&#34; src=&#34;data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+&#34;  loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;582&#34; height=&#34;464&#34; data-original=&#34;http://117.72.66.48/wp-content/uploads/2025/05/image.png&#34; src=&#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC&#34; alt=&#34;&#34; class=&#34;wp-image-140&#34;  sizes=&#34;auto, (max-width: 582px) 100vw, 582px&#34; /&gt;
&lt;/div&gt;&lt;/figure&gt; 
&lt;p&gt;&lt;strong&gt;如何区分一个lchild指针是指向左孩子还是前驱结点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;添加标志位，这样一来节点有5个数据结构，lrchild，lrtag，data。&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    ltag==0，指向左孩子；ltag==1，指向前驱结点
  &lt;/li&gt;
  &lt;li&gt;
    rtag==0，指向右孩子；rtag==1，指向后继结点
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中序线索化，定义一个&lt;code&gt;pre指针&lt;/code&gt;，&lt;strong&gt;pre指向刚刚访问过的节点（前驱）&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;// 全局变量，记录当前访问节点的前驱
ThreadedNode *pre = NULL;
void InorderThreading(ThreadedNode *root) {
    if (root == NULL) return;
    // 递归线索化左子树
    InorderThreading(root-&gt;left);
    // 处理当前节点
    if (root-&gt;left == NULL) {
        root-&gt;left = pre;    // 左指针指向前驱
        root-&gt;ltag = 1;      // 标记为线索
    } else {
        root-&gt;ltag = 0;      // 标记为子树
    }

    if (pre != NULL &amp;&amp; pre-&gt;right == NULL) {
        pre-&gt;right = root;   // 前驱的后继指向当前节点
        pre-&gt;rtag = 1;       // 标记为线索
    } else if (pre != NULL) {
        pre-&gt;rtag = 0;       // 标记为子树
    }

    pre = root;              // 更新前驱为当前节点

    // 递归线索化右子树
    InorderThreading(root-&gt;right);
}&lt;/pre&gt;
&lt;p&gt;最后，本题的题解：&lt;br&gt;
时间复杂度，中序遍历一遍二叉树，每个节点都只被访问了一次，故时间复杂度为O(n)，n为节点数量&lt;br&gt;
空间复杂度，定义了两个辅助指针，故为O1&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;#include &amp;lt;vector&gt;
class Solution {
public:
	TreeNode* res = nullptr;
	TreeNode* pre = nullptr;
	void inOrder(TreeNode* p){
		if(p == nullptr) return;
		inOrder(p-&gt;left);
		if(p-&gt;left == nullptr){// 如果当前点左子树为null
			// 需要将左子树指向前驱
			if(res == nullptr) res = p;	//返回值的入口
			p-&gt;left = pre;
			// 如果p的前驱存在，把p前驱的后继设为p
			if(pre != nullptr) pre-&gt;right = p;
		}
		if(pre != nullptr &amp;&amp; pre-&gt;right == nullptr){// pre的作为p的前驱，pre的右子树需要指向p
			pre-&gt;right = p;
			p-&gt;left = pre;
		}
		pre = p;
		inOrder(p-&gt;right);
		return;
	}
    TreeNode* Convert(TreeNode* pRootOfTree) {
		if(pRootOfTree == nullptr) return nullptr;
		inOrder(pRootOfTree);
		return res;
    }
};
&lt;/pre&gt;

                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/26/%E5%89%91%E6%8C%87offer67%E9%A2%98-no26-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/26/%E5%89%91%E6%8C%87offer67%E9%A2%98-no26-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A0%91/" term="树" label="树" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E9%93%BE%E8%A1%A8/" term="链表" label="链表" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No25.复杂链表的复制</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/26/%E5%89%91%E6%8C%87offer67%E9%A2%98-no25-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/26/%E5%89%91%E6%8C%87offer67%E9%A2%98-no25-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-26T03:23:28&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;涉及一个知识点，深拷贝与浅拷贝。&lt;figure class=&#34;wp-block-table&#34;&gt;&lt;/p&gt;
&lt;table class=&#34;has-fixed-layout&#34;&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;strong&gt;特性&lt;/strong&gt;
    &lt;/th&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;th&amp;gt;
  &amp;lt;strong&amp;gt;深拷贝 (Deep Copy)&amp;lt;/strong&amp;gt;
&amp;lt;/th&amp;gt;

&amp;lt;th&amp;gt;
  &amp;lt;strong&amp;gt;浅拷贝 (Shallow Copy)&amp;lt;/strong&amp;gt;
&amp;lt;/th&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;strong&gt;定义&lt;/strong&gt;
    &lt;/td&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;td&amp;gt;
  创建一个新对象，并递归复制所有成员及其指向的资源
&amp;lt;/td&amp;gt;

&amp;lt;td&amp;gt;
  仅复制指针值，新旧对象共享同一块内存
&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;strong&gt;内存管理&lt;/strong&gt;
    &lt;/td&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;td&amp;gt;
  新旧对象完全独立，修改互不影响
&amp;lt;/td&amp;gt;

&amp;lt;td&amp;gt;
  修改任一对象会影响另一个（可能导致双重释放或内存泄漏）
&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;strong&gt;性能&lt;/strong&gt;
    &lt;/td&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;td&amp;gt;
  较慢（需分配新内存并复制数据）
&amp;lt;/td&amp;gt;

&amp;lt;td&amp;gt;
  极快（仅复制指针）
&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;strong&gt;使用场景&lt;/strong&gt;
    &lt;/td&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;td&amp;gt;
  需要完全独立的副本（如复杂链表、树、含指针的结构体）
&amp;lt;/td&amp;gt;

&amp;lt;td&amp;gt;
  临时共享数据，无需修改原对象
&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;strong&gt;示例&lt;/strong&gt;
    &lt;/td&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;td&amp;gt;
  &amp;lt;code&amp;gt;std::vector v2 = v1;&amp;lt;/code&amp;gt; （元素逐个复制）
&amp;lt;/td&amp;gt;

&amp;lt;td&amp;gt;
  &amp;lt;code&amp;gt;int* p2 = p1;&amp;lt;/code&amp;gt; （仅复制指针）
&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/tr&gt;
&lt;/table&gt;&lt;/figure&gt; 
&lt;p&gt;示例代码:&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/26/%E5%89%91%E6%8C%87offer67%E9%A2%98-no25-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/26/%E5%89%91%E6%8C%87offer67%E9%A2%98-no25-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;涉及一个知识点，深拷贝与浅拷贝。&lt;figure class=&#34;wp-block-table&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;table-container&#34;&gt;&lt;table class=&#34;has-fixed-layout&#34;&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;strong&gt;特性&lt;/strong&gt;
    &lt;/th&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;th&amp;gt;
  &amp;lt;strong&amp;gt;深拷贝 (Deep Copy)&amp;lt;/strong&amp;gt;
&amp;lt;/th&amp;gt;

&amp;lt;th&amp;gt;
  &amp;lt;strong&amp;gt;浅拷贝 (Shallow Copy)&amp;lt;/strong&amp;gt;
&amp;lt;/th&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;strong&gt;定义&lt;/strong&gt;
    &lt;/td&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;td&amp;gt;
  创建一个新对象，并递归复制所有成员及其指向的资源
&amp;lt;/td&amp;gt;

&amp;lt;td&amp;gt;
  仅复制指针值，新旧对象共享同一块内存
&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;strong&gt;内存管理&lt;/strong&gt;
    &lt;/td&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;td&amp;gt;
  新旧对象完全独立，修改互不影响
&amp;lt;/td&amp;gt;

&amp;lt;td&amp;gt;
  修改任一对象会影响另一个（可能导致双重释放或内存泄漏）
&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;strong&gt;性能&lt;/strong&gt;
    &lt;/td&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;td&amp;gt;
  较慢（需分配新内存并复制数据）
&amp;lt;/td&amp;gt;

&amp;lt;td&amp;gt;
  极快（仅复制指针）
&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;strong&gt;使用场景&lt;/strong&gt;
    &lt;/td&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;td&amp;gt;
  需要完全独立的副本（如复杂链表、树、含指针的结构体）
&amp;lt;/td&amp;gt;

&amp;lt;td&amp;gt;
  临时共享数据，无需修改原对象
&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;strong&gt;示例&lt;/strong&gt;
    &lt;/td&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;td&amp;gt;
  &amp;lt;code&amp;gt;std::vector v2 = v1;&amp;lt;/code&amp;gt; （元素逐个复制）
&amp;lt;/td&amp;gt;

&amp;lt;td&amp;gt;
  &amp;lt;code&amp;gt;int* p2 = p1;&amp;lt;/code&amp;gt; （仅复制指针）
&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/tr&gt;
&lt;/table&gt;&lt;/div&gt;&lt;/figure&gt; 
&lt;p&gt;示例代码:&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Example {
public:
    int* data;
    Example(int val) { data = new int(val); }
    ~Example() { delete data; }
    
    // 浅拷贝（默认拷贝构造函数）
    Example(const Example&amp; other) : data(other.data) {}
    
    // 深拷贝
    Example(const Example&amp; other) : data(new int(*other.data)) {}
};

int main() {
    // 深拷贝，就是new新的节点出来。
    Example e1(10);
    Example e2 = e1;  // 浅拷贝：e2.data 和 e1.data 指向同一内存
    *e2.data = 20;    // 修改 e2 会影响 e1！
    
    Example e3(e1);   // 深拷贝：e3.data 是新的内存
    *e3.data = 30;    // 修改 e3 不会影响 e1
    return 0;
}&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;解法1：哈希表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;摘自牛客题解：&lt;/p&gt;
&lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;
  &lt;ol class=&#34;wp-block-list&#34;&gt;
    &lt;li&gt;
      假如链表没有随机指针, 我们的拷贝方式很简单, 只要先创建一个哨兵节点, 然后遍历一下给定链表, 创建新节点, 并不断和上个节点连接
    &lt;/li&gt;
    &lt;li&gt;
      本题的难点就在于每个节点还有一个指向空或其它节点的指针, 一种比较直观的想法就是先把整条链表连起来, 然后再挨着改变指针, 因此我们可以用哈希表来存放指针的映射关系, 然后根据将随机指针指向原链表随机指针映射在新链表的位置
    &lt;/li&gt;
    &lt;li&gt;
      算法实现：首先&lt;strong&gt;创建一个哨兵节点, 遍历一次原链表, 先将除随机指针外的部分创建并连接, 同时用哈希表记录指针之间的映射, 最后遍历一次哈希表, 将随机指针指向对应的位置&lt;/strong&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;PS：map和unordered_map的差别和使用：&lt;a href=&#34;https://blog.csdn.net/BillCYJ/article/details/78985895&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;map和unordered_map的差别和使用_unorderedmap和map的区别-CSDN博客&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于查找问题，&lt;code&gt;unordered_map&lt;/code&gt;会更加高效一些。&lt;figure class=&#34;wp-block-table&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;table-container&#34;&gt;&lt;table class=&#34;has-fixed-layout&#34;&gt;
  &lt;tr&gt;
    &lt;th&gt;
      操作
    &lt;/th&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;th&amp;gt;
  &amp;lt;code&amp;gt;std::map&amp;lt;/code&amp;gt; (红黑树)
&amp;lt;/th&amp;gt;

&amp;lt;th&amp;gt;
  &amp;lt;code&amp;gt;std::unordered_map&amp;lt;/code&amp;gt; (哈希表)
&amp;lt;/th&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
      插入/删除/查找
    &lt;/td&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;td&amp;gt;
  O(log n)
&amp;lt;/td&amp;gt;

&amp;lt;td&amp;gt;
  &amp;lt;strong&amp;gt;平均 O(1)&amp;lt;/strong&amp;gt;，最坏 O(n)
&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
      遍历
    &lt;/td&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;td&amp;gt;
  有序遍历（中序遍历）
&amp;lt;/td&amp;gt;

&amp;lt;td&amp;gt;
  无序遍历
&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
      空间复杂度
    &lt;/td&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;td&amp;gt;
  较低（无额外哈希开销）
&amp;lt;/td&amp;gt;

&amp;lt;td&amp;gt;
  较高（需维护哈希桶和负载因子）
&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/tr&gt;
&lt;/table&gt;&lt;/div&gt;&lt;/figure&gt; 
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;#include &amp;lt;unordered_map&gt;

class Solution {
public:
    RandomListNode* Clone(RandomListNode* pHead) {
        if (!pHead) return nullptr;
        
        std::unordered_map&amp;lt;RandomListNode*, RandomListNode*&gt; nodeMap;
        
        // 第一次遍历：创建所有新节点并建立映射
        RandomListNode* current = pHead;
        while (current) {
            // key:old node; value:new node
            nodeMap[current] = new RandomListNode(current-&gt;label);
            current = current-&gt;next;
        }
        
        // 第二次遍历：设置新节点的next和random指针
        current = pHead;
        while (current) {
            if (current-&gt;next) {
                // 上一步添加的键值对，值之间是没有指向关系的，要设置新节点的next指针
                nodeMap[current]-&gt;next = nodeMap[current-&gt;next];
            }
            if (current-&gt;random) {
                nodeMap[current]-&gt;random = nodeMap[current-&gt;random];
            }
            current = current-&gt;next;
        }
        
        return nodeMap[pHead];
    }
};&lt;/pre&gt;
&lt;p&gt;此法空间复杂度为On，时间复杂度为On。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;法2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;摘自牛客题解：&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    主要思路是将原链表的结点对应的拷贝节点连在其后, 最后链表变成 原1 -&gt; 拷1 -&gt; 原2 -&gt; 拷2 -&gt; &amp;#8230; -&gt; null 的形式
  &lt;/li&gt;
  &lt;li&gt;
    然后再逐步处理对应的随机指针, 使用双指针, 一个指针指向原链表的节点, 一个指向拷贝链表的节点, 那么就有 拷-&gt;random = 原-&gt;random-&gt;next (random不为空)
  &lt;/li&gt;
  &lt;li&gt;
    最后再用双指针将两条链表拆分即可
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此法的空间复杂度为O1，无需额外的辅助空间&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    RandomListNode* Clone(RandomListNode* pHead) {
        if (!pHead) return nullptr;
        
        // 第一步：在每个节点后面插入复制节点
        RandomListNode* current = pHead;
        while (current) {
            RandomListNode* clone = new RandomListNode(current-&gt;label);
            clone-&gt;next = current-&gt;next;
            current-&gt;next = clone;
            current = clone-&gt;next;
        }
        
        // 第二步：设置复制节点的random指针
        current = pHead;
        while (current) {
            if (current-&gt;random) {
                // 跟在原节点后面的是新节点，新节点的random 指向 原节点random后面的
                current-&gt;next-&gt;random = current-&gt;random-&gt;next;
            }
            current = current-&gt;next-&gt;next;
        }
        
        // 第三步：拆分两个链表
        current = pHead;
        RandomListNode* cloneHead = pHead-&gt;next;
        RandomListNode* cloneCurrent = cloneHead;
        
        while (current) {
            current-&gt;next = current-&gt;next-&gt;next;
            if (cloneCurrent-&gt;next) {
                cloneCurrent-&gt;next = cloneCurrent-&gt;next-&gt;next;
            }
            current = current-&gt;next;
            cloneCurrent = cloneCurrent-&gt;next;
        }
        
        return cloneHead;
    }
};&lt;/pre&gt;

                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/26/%E5%89%91%E6%8C%87offer67%E9%A2%98-no25-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/26/%E5%89%91%E6%8C%87offer67%E9%A2%98-no25-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E9%93%BE%E8%A1%A8/" term="链表" label="链表" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No24.二叉树中和为某一值的路径(二)</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/26/%E5%89%91%E6%8C%87offer67%E9%A2%98-no24-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%E4%BA%8C/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/26/%E5%89%91%E6%8C%87offer67%E9%A2%98-no24-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%E4%BA%8C/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-26T03:20:32&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;递归，用一个vector存储中间的path路径。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;#include &amp;lt;vector&gt;
class Solution {
public:
    // 一个存放最后结果，一个存放临时结果
    vector&amp;lt;vector&amp;lt;int&gt;&gt; res;
    vector&amp;lt;int&gt; path;
    void dfs(TreeNode* root, int target, int temp){
        if(root == nullptr) return;
        path.emplace_back(root-&gt;val);
        if(root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr &amp;&amp; root-&gt;val + temp == target){
            res.emplace_back(path);
        }
        dfs(root-&gt;left, target, temp + root-&gt;val);
        dfs(root-&gt;right, target, temp + root-&gt;val);
        path.pop_back();
    }
    vector&amp;lt;vector&amp;lt;int&gt; &gt; FindPath(TreeNode* root, int target) {
        if(root == nullptr) return {};
        dfs(root, target, 0);
        return res;
    }
};&lt;/pre&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    时间复杂度：O(n^2)，其中&lt;em&gt;n&lt;/em&gt;是树的节点数。
  &lt;/li&gt;
  &lt;li&gt;
    空间复杂度：O(n)，递归栈的深度不会超过节点数量，但最大可能就是节点数量。
  &lt;/li&gt;
&lt;/ul&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/26/%E5%89%91%E6%8C%87offer67%E9%A2%98-no24-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%E4%BA%8C/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/26/%E5%89%91%E6%8C%87offer67%E9%A2%98-no24-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%E4%BA%8C/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;递归，用一个vector存储中间的path路径。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;#include &amp;lt;vector&gt;
class Solution {
public:
    // 一个存放最后结果，一个存放临时结果
    vector&amp;lt;vector&amp;lt;int&gt;&gt; res;
    vector&amp;lt;int&gt; path;
    void dfs(TreeNode* root, int target, int temp){
        if(root == nullptr) return;
        path.emplace_back(root-&gt;val);
        if(root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr &amp;&amp; root-&gt;val + temp == target){
            res.emplace_back(path);
        }
        dfs(root-&gt;left, target, temp + root-&gt;val);
        dfs(root-&gt;right, target, temp + root-&gt;val);
        path.pop_back();
    }
    vector&amp;lt;vector&amp;lt;int&gt; &gt; FindPath(TreeNode* root, int target) {
        if(root == nullptr) return {};
        dfs(root, target, 0);
        return res;
    }
};&lt;/pre&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    时间复杂度：O(n^2)，其中&lt;em&gt;n&lt;/em&gt;是树的节点数。
  &lt;/li&gt;
  &lt;li&gt;
    空间复杂度：O(n)，递归栈的深度不会超过节点数量，但最大可能就是节点数量。
  &lt;/li&gt;
&lt;/ul&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/26/%E5%89%91%E6%8C%87offer67%E9%A2%98-no24-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%E4%BA%8C/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/26/%E5%89%91%E6%8C%87offer67%E9%A2%98-no24-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%E4%BA%8C/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A0%91/" term="树" label="树" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E9%80%92%E5%BD%92/" term="递归" label="递归" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No23.二叉搜索树的后序遍历序列</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/26/%E5%89%91%E6%8C%87offer67%E9%A2%98-no23-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/26/%E5%89%91%E6%8C%87offer67%E9%A2%98-no23-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-26T03:17:16&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回 true ,否则返回 false 。假设输入的数组的任意两个数字都互不相同。&lt;br&gt;
数据范围： 节点数量 0≤n≤10000≤n≤1000 ，节点上的值满足 1≤val≤1051≤val≤105 ，保证节点上的值各不相同 要求：空间复杂度 O(n) ，时间时间复杂度 O(n2)&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/26/%E5%89%91%E6%8C%87offer67%E9%A2%98-no23-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/26/%E5%89%91%E6%8C%87offer67%E9%A2%98-no23-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回 true ,否则返回 false 。假设输入的数组的任意两个数字都互不相同。&lt;br&gt;
数据范围： 节点数量 0≤n≤10000≤n≤1000 ，节点上的值满足 1≤val≤1051≤val≤105 ，保证节点上的值各不相同 要求：空间复杂度 O(n) ，时间时间复杂度 O(n2)&lt;/p&gt;
&lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;
&lt;/blockquote&gt;
&lt;p&gt;完全没思路，值得二刷&lt;/p&gt;
&lt;p&gt;树的题目，用递归，基于二叉搜索树的性质和后序遍历的性质。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    bool VerifySquenceOfBST(vector&amp;lt;int&gt; sequence) {
        int n = sequence.size();
        if(n == 0) return false;
        return check(sequence, 0, n-1);
    }
    // 后序遍历，左右根，二叉搜索树，左&amp;lt;根&amp;lt;右
    bool check(vector&amp;lt;int&gt;&amp; S, int l, int r){
        if(l&gt;=r) return true;
        
        int root = S.at(r);
        int j = r - 1;
        int i = l;
        
        //划分出左右子树
        //划分右子树
        while(j &gt;= 0 &amp;&amp; S.at(j) &gt;= root){
            j--;
        }
		//划分左子树
        while(i &amp;lt;= j){
            if(S.at(i) &gt; root) return false;
            ++i;
        }
        
        return check(S, l, j) &amp;&amp; check(S, j+1, r - 1);
    }
};&lt;/pre&gt;
&lt;p&gt;**时间复杂度：**O(n^2), n为二叉树节点的个数, 当树为链式时时间复杂度最坏为O(n^2) **空间复杂度：**O(n), 当树为链式结构时, 递归深度为n&lt;/p&gt;
&lt;p&gt;还有另一种用辅助栈的方法，没敲，贴这里。 **时间复杂度：**O(nlogn), 时间复杂度取决于排序。**空间复杂度：**O(n), 额外数组和辅助栈的空间。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    bool VerifySquenceOfBST(vector&amp;lt;int&gt; sequence) {
        if(sequence.empty()) return false;
        vector&amp;lt;int&gt; inorder(sequence);
        sort(inorder.begin(), inorder.end());
        return IsPopOrder(inorder, sequence);
    }
 
    bool IsPopOrder(vector&amp;lt;int&gt; pushV,vector&amp;lt;int&gt; popV) {
         int n = pushV.size();
         stack&amp;lt;int&gt; stk;    // 使用STL中的栈容器
         int i = 0, j = 0;
         while(i &amp;lt; n){
             stk.push(pushV[i]);    // 首先将pushV[i]入栈
             while(!stk.empty() &amp;&amp; stk.top() == popV[j]){    // 不断检查栈顶
                 ++j;
                 stk.pop();
             }
             ++i;
         }
         return j == n;    // 判断能否成功对应
     }
};&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/26/%E5%89%91%E6%8C%87offer67%E9%A2%98-no23-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/26/%E5%89%91%E6%8C%87offer67%E9%A2%98-no23-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A0%91/" term="树" label="树" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E9%80%92%E5%BD%92/" term="递归" label="递归" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No22.从上往下打印二叉树</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no22-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no22-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-19T07:55:12&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;层次遍历&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;#include &amp;lt;vector&gt;
class Solution {
public:
    vector&amp;lt;int&gt; PrintFromTopToBottom(TreeNode* root) {
		if(root == nullptr) return {};
		
		std::queue&amp;lt;TreeNode*&gt; Q;
		std::vector&amp;lt;int&gt; res;
		Q.push(root);
		while(!Q.empty()){
			TreeNode* curP = Q.front();
			Q.pop();
			res.push_back(curP-&gt;val);
			if(curP-&gt;left) Q.push(curP-&gt;left);
			if(curP-&gt;right) Q.push(curP-&gt;right);
		}
		return res;
    }
};&lt;/pre&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no22-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no22-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;层次遍历&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;#include &amp;lt;vector&gt;
class Solution {
public:
    vector&amp;lt;int&gt; PrintFromTopToBottom(TreeNode* root) {
		if(root == nullptr) return {};
		
		std::queue&amp;lt;TreeNode*&gt; Q;
		std::vector&amp;lt;int&gt; res;
		Q.push(root);
		while(!Q.empty()){
			TreeNode* curP = Q.front();
			Q.pop();
			res.push_back(curP-&gt;val);
			if(curP-&gt;left) Q.push(curP-&gt;left);
			if(curP-&gt;right) Q.push(curP-&gt;right);
		}
		return res;
    }
};&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no22-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no22-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A0%91/" term="树" label="树" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No21.栈的压入弹出序列</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no21-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no21-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-19T07:54:11&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;&lt;strong&gt;法1：辅助栈&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同时用两个指针i, j分别指向两个序列的头部,&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    每次我们先将i所指向的元素压入栈中, 然后i向后移动一步, 之后再检查当前栈顶, 若对应上了弹出序列中j所指向的元素, 则弹出元素,
  &lt;/li&gt;
  &lt;li&gt;
    j向后移动, 再继续检查, 直到栈空或栈顶元素和j所指元素不等为止
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    stack&amp;lt;int&gt; s1;
    bool IsPopOrder(vector&amp;lt;int&gt;&amp; pushV, vector&amp;lt;int&gt;&amp; popV) {
        // write code here
        int len = pushV.size();
        int i = 0;
        int j = 0;
        while(i &amp;lt; len){
            s1.push(pushV.at(i));
            while(!s1.empty() &amp;&amp; s1.top() == popV[j]){
                ++j;
                s1.pop();
            }
            ++i;
        }
        return j == len;
    }
};&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;法2：直接在数组上操作&lt;/strong&gt;&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no21-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no21-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;&lt;strong&gt;法1：辅助栈&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同时用两个指针i, j分别指向两个序列的头部,&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    每次我们先将i所指向的元素压入栈中, 然后i向后移动一步, 之后再检查当前栈顶, 若对应上了弹出序列中j所指向的元素, 则弹出元素,
  &lt;/li&gt;
  &lt;li&gt;
    j向后移动, 再继续检查, 直到栈空或栈顶元素和j所指元素不等为止
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    stack&amp;lt;int&gt; s1;
    bool IsPopOrder(vector&amp;lt;int&gt;&amp; pushV, vector&amp;lt;int&gt;&amp; popV) {
        // write code here
        int len = pushV.size();
        int i = 0;
        int j = 0;
        while(i &amp;lt; len){
            s1.push(pushV.at(i));
            while(!s1.empty() &amp;&amp; s1.top() == popV[j]){
                ++j;
                s1.pop();
            }
            ++i;
        }
        return j == len;
    }
};&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;法2：直接在数组上操作&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    当&lt;code&gt;pushV[i] != popV[0]&lt;/code&gt;元素，表示还没匹配到待弹出元素；继续&lt;code&gt;i = i + 1&lt;/code&gt;压入元素；
  &lt;/li&gt;
  &lt;li&gt;
    当&lt;code&gt;push[i] == popV[0]&lt;/code&gt;时，即匹配上弹出元素，并i = i &amp;#8211; 1让它始终指向pushV的顶部元素；同时popV也要更新到下一个元素j = j + 1，使其成为新的popV[0]。最后直到pushV 和popV都为空即匹配结束。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    stack&amp;lt;int&gt; s1;
    bool IsPopOrder(vector&amp;lt;int&gt;&amp; pushV, vector&amp;lt;int&gt;&amp; popV) {
        // write code here
        int i = 0;
        int j = 0;
        for(auto p : pushV){
            pushV[i] = p; // 这一步是模拟入栈操作
            while(i&gt;=0 &amp;&amp; pushV[i] == popV[j]){
                j++;
                i--;
            }
            i++;
        }
        return i == 0; // 检查最后的栈是否为空
    }
};&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no21-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no21-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A0%88/" term="栈" label="栈" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No20.包含min函数的栈</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no20/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no20/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-19T07:52:29&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;&lt;strong&gt;法1：双栈&lt;/strong&gt; 再开一个栈，记录单调递减序列，关键是push操作，维护两个栈，每次push元素的时候与第二个栈的栈顶元素比较，若是较小，则进入第二个栈；&lt;strong&gt;若是较大，则第二个栈的栈顶元素再次入栈&lt;/strong&gt;。于是，每次访问最小值即访问第二个栈的栈顶。&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no20/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no20/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;&lt;strong&gt;法1：双栈&lt;/strong&gt; 再开一个栈，记录单调递减序列，关键是push操作，维护两个栈，每次push元素的时候与第二个栈的栈顶元素比较，若是较小，则进入第二个栈；&lt;strong&gt;若是较大，则第二个栈的栈顶元素再次入栈&lt;/strong&gt;。于是，每次访问最小值即访问第二个栈的栈顶。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;#include &amp;lt;stack&gt;
class Solution {
public:
    stack&amp;lt;int&gt; s1;
    stack&amp;lt;int&gt; minS;

    void push(int value) {
        if(s1.empty() &amp;&amp; minS.empty()){
            s1.push(value);
            minS.push(value);
        }else{
            s1.push(value);
            if(value &amp;lt;= minS.top()){
                minS.push(value);
            }else{
                minS.push(minS.top());
            }
        }
    }
    void pop() {
        s1.pop();
        minS.pop();
    }
    int top() {
        return s1.top();
    }

    int min() {
        return minS.top();
    }
};&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;法2：类似前缀和的做法&lt;/strong&gt; 能做到空间复杂度和时间复杂度都是O1。&lt;/p&gt;
&lt;p&gt;在栈中存储 &lt;strong&gt;差值&lt;/strong&gt; 而非原始值，并通过差值还原最小值和原始值。&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    存储差值​​：每次 push(x) 时，存储 x &amp;#8211; current_min（当前最小值）。
  &lt;/li&gt;
  &lt;li&gt;
    更新最小值​​：如果 x &lt; current_min，则更新 current_min = x。
  &lt;/li&gt;
  &lt;li&gt;
    ​恢复原始值​​： 当 pop 时，通过差值和 current_min 还原原始值。 如果弹出的差值 diff ≤ 0，说明该元素是当前最小值，需反向更新 current_min。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;#include &amp;lt;stack&gt;
class Solution {
public:
    stack&amp;lt;int&gt; s1;
    int curMin = INT_MAX;

    void push(int value) {
        if(s1.empty()){
            // 为空，残差为0
            s1.push(0);
            curMin = value;
        }else{
            int diff = value - curMin;
            s1.push(diff);
            if(diff &amp;lt; 0){ // 说明更小
                curMin = value;
            }
        }
    }
    void pop() {
        int diff = s1.top();
        s1.pop();
        if(diff &amp;lt; 0){
            // 还原上一个最小值，由diff = value - curMin;变换来
            curMin = curMin - diff;
        }
    }
    int top() {
        int diff = s1.top();
        if(diff &gt;= 0) return diff + curMin;
        else{
             return curMin; // 当前元素过程中的某个最小值
        }
    }
    int min() {
        return curMin;
    }
};&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no20/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no20/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A0%88/" term="栈" label="栈" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No19.顺时针打印矩阵</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no19/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no19/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-19T07:51:33&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;&lt;strong&gt;边界模拟&lt;/strong&gt; 模拟四个边界情况，并不断收缩。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;vector&amp;lt;int&gt; printMatrix(vector&amp;lt;vector&amp;lt;int&gt; &gt; matrix) {
        if(matrix.size() == 0) return {};
        if(matrix.size() == 1) return matrix.front();

        int l = 0;
        int r = matrix.front().size() -1 ;
        int top = 0;
        int bottom = matrix.size() -1;
        vector&amp;lt;int&gt; res;
        while(l &amp;lt;= r &amp;&amp; top &amp;lt;= bottom){
            // 顶层遍历
            for(int i = l; i &amp;lt;= r; ++i){
                res.push_back(matrix[top][i]);
            }
            if(++top &gt; bottom) break;
            // 右侧遍历
            for(int i = top; i &amp;lt;= bottom; ++i){
                res.push_back(matrix[i][r]);
            }
            if(--r &amp;lt; l) break;
            // 底部遍历
            for(int i = r; i&gt;=l; --i){
                res.push_back(matrix[bottom][i]);
            }
            if(--bottom &amp;lt; top) break;
            // 左侧遍历
            for(int i = bottom; i &gt;=top; --i){
                res.push_back(matrix[i][l]);
            }
            if(++l &gt; r) break;
        }
            return res;
    }&lt;/pre&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no19/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no19/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;&lt;strong&gt;边界模拟&lt;/strong&gt; 模拟四个边界情况，并不断收缩。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;vector&amp;lt;int&gt; printMatrix(vector&amp;lt;vector&amp;lt;int&gt; &gt; matrix) {
        if(matrix.size() == 0) return {};
        if(matrix.size() == 1) return matrix.front();

        int l = 0;
        int r = matrix.front().size() -1 ;
        int top = 0;
        int bottom = matrix.size() -1;
        vector&amp;lt;int&gt; res;
        while(l &amp;lt;= r &amp;&amp; top &amp;lt;= bottom){
            // 顶层遍历
            for(int i = l; i &amp;lt;= r; ++i){
                res.push_back(matrix[top][i]);
            }
            if(++top &gt; bottom) break;
            // 右侧遍历
            for(int i = top; i &amp;lt;= bottom; ++i){
                res.push_back(matrix[i][r]);
            }
            if(--r &amp;lt; l) break;
            // 底部遍历
            for(int i = r; i&gt;=l; --i){
                res.push_back(matrix[bottom][i]);
            }
            if(--bottom &amp;lt; top) break;
            // 左侧遍历
            for(int i = bottom; i &gt;=top; --i){
                res.push_back(matrix[i][l]);
            }
            if(++l &gt; r) break;
        }
            return res;
    }&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no19/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no19/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A8%A1%E6%8B%9F/" term="模拟" label="模拟" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No18.二叉树镜像</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no18-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%95%9C%E5%83%8F/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no18-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%95%9C%E5%83%8F/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-19T07:50:45&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;&lt;strong&gt;递归&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    TreeNode* Mirror(TreeNode* pRoot) {
        //空树返回
        if(pRoot == NULL) 
            return NULL;
        //先递归子树
        TreeNode* left = Mirror(pRoot-&gt;left);  
        TreeNode* right = Mirror(pRoot-&gt;right);
        //交换
        pRoot-&gt;left = right; 
        pRoot-&gt;right = left;
        return pRoot;
    }
};&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;辅助队列层次遍历&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no18-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%95%9C%E5%83%8F/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no18-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%95%9C%E5%83%8F/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;&lt;strong&gt;递归&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    TreeNode* Mirror(TreeNode* pRoot) {
        //空树返回
        if(pRoot == NULL) 
            return NULL;
        //先递归子树
        TreeNode* left = Mirror(pRoot-&gt;left);  
        TreeNode* right = Mirror(pRoot-&gt;right);
        //交换
        pRoot-&gt;left = right; 
        pRoot-&gt;right = left;
        return pRoot;
    }
};&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;辅助队列层次遍历&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    TreeNode* Mirror(TreeNode* pRoot) {
        if(pRoot == nullptr) return nullptr;
        
        auto *newT = new TreeNode(pRoot-&gt;val);
        std::queue&amp;lt;TreeNode*&gt; q;
        q.push(pRoot);
         
        while(!q.empty()){
            TreeNode* cur = q.front();
            q.pop();
            if(cur != nullptr){
                q.push(cur-&gt;left);
                q.push(cur-&gt;right);
                // 节点交换
                TreeNode*  tmp = cur-&gt;left;
                cur-&gt;left = cur-&gt;right;
                cur-&gt;right = tmp;
            }
        }
        return pRoot;

    }
};&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no18-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%95%9C%E5%83%8F/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no18-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%95%9C%E5%83%8F/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A0%91/" term="树" label="树" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No17.树的子结构</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no17-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no17-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-19T07:44:11&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;&lt;strong&gt;树的题目，一般用递归来写&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;双重递归&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    bool isSubtree(TreeNode* p1, TreeNode* p2) {
        if (p2 == nullptr) return true;  // 树 B 已匹配完
        if (p1 == nullptr) return false; // 树 A 已空但树 B 未空
        if (p1-&gt;val != p2-&gt;val) return false;
        return isSubtree(p1-&gt;left, p2-&gt;left) &amp;&amp; isSubtree(p1-&gt;right, p2-&gt;right);
    }

    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) {
        if (pRoot1 == nullptr || pRoot2 == nullptr) return false;
        
        // 当前节点匹配且子树匹配，或左/右子树中匹配
        return (pRoot1-&gt;val == pRoot2-&gt;val &amp;&amp; isSubtree(pRoot1, pRoot2)) ||
               HasSubtree(pRoot1-&gt;left, pRoot2) || 
              w HasSubtree(pRoot1-&gt;right, pRoot2);
    }
};&lt;/pre&gt;
&lt;p&gt;也可以用&lt;strong&gt;层次遍历+递归&lt;/strong&gt;来写：层次遍历找到某个节点和p2的根值相同，然后递归判断是否匹配。&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no17-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no17-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;&lt;strong&gt;树的题目，一般用递归来写&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;双重递归&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    bool isSubtree(TreeNode* p1, TreeNode* p2) {
        if (p2 == nullptr) return true;  // 树 B 已匹配完
        if (p1 == nullptr) return false; // 树 A 已空但树 B 未空
        if (p1-&gt;val != p2-&gt;val) return false;
        return isSubtree(p1-&gt;left, p2-&gt;left) &amp;&amp; isSubtree(p1-&gt;right, p2-&gt;right);
    }

    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) {
        if (pRoot1 == nullptr || pRoot2 == nullptr) return false;
        
        // 当前节点匹配且子树匹配，或左/右子树中匹配
        return (pRoot1-&gt;val == pRoot2-&gt;val &amp;&amp; isSubtree(pRoot1, pRoot2)) ||
               HasSubtree(pRoot1-&gt;left, pRoot2) || 
              w HasSubtree(pRoot1-&gt;right, pRoot2);
    }
};&lt;/pre&gt;
&lt;p&gt;也可以用&lt;strong&gt;层次遍历+递归&lt;/strong&gt;来写：层次遍历找到某个节点和p2的根值相同，然后递归判断是否匹配。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
  public:
    //层次遍历判断两个树是否相同
    bool helper(TreeNode* p1, TreeNode* p2) {
        if (p2 == nullptr) return true;  // 树 B 已匹配完
        if (p1 == nullptr) return false; // 树 A 已空但树 B 未空
        if (p1-&gt;val != p2-&gt;val) return false;
        return helper(p1-&gt;left, p2-&gt;left) &amp;&amp; helper(p1-&gt;right, p2-&gt;right);
    }
    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) {
        if (pRoot1 == nullptr || pRoot2 == nullptr)
            return false;

        queue&amp;lt;TreeNode*&gt; q;
        q.push(pRoot1);
        while (!q.empty()) {
            TreeNode* node = q.front();
            q.pop();
            if (node-&gt;val == pRoot2-&gt;val) {
                if (helper(node, pRoot2))
                    return true;
            }
            if (node-&gt;left)
                q.push(node-&gt;left);
            if (node-&gt;right)
                q.push(node-&gt;right);
        }
        return false;
    }
};&lt;/pre&gt;
&lt;p&gt;还有&lt;strong&gt;双重层次遍历&lt;/strong&gt;的做法，本质上是递归的层次遍历版本：&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    step 1：先判断空树，空树不为子结构。
  &lt;/li&gt;
  &lt;li&gt;
    step 2：利用队列辅助，层次遍历第一棵树，每次检查遍历到的节点是否和第二棵树的根节点相同。
  &lt;/li&gt;
  &lt;li&gt;
    step 3：若是相同，可以以该节点为子树根节点，再次借助队列辅助，同步层次遍历这个子树与第二棵树，这个时候以第二棵树为基，只要找到第二棵树的全部节点，就算找到了子结构。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    //层次遍历判断两个树是否相同
    bool helper(TreeNode* root1, TreeNode* root2){ 
        queue&amp;lt;TreeNode*&gt; q1, q2;
        q1.push(root1);
        q2.push(root2);
        //以树2为基础，树1跟随就可以了
        while(!q2.empty()){ 
            TreeNode* node1 = q1.front(); 
            TreeNode* node2 = q2.front();
            q1.pop();
            q2.pop();
            //树1为空或者二者不相等
            if(node1 == NULL || node1-&gt;val != node2-&gt;val) 
                return false;
            //树2还有左子树
            if(node2-&gt;left){ 
                //子树入队
                q1.push(node1-&gt;left); 
                q2.push(node2-&gt;left);
            }
            //树2还有右子树
            if(node2-&gt;right){ 
                //子树入队
                q1.push(node1-&gt;right); 
                q2.push(node2-&gt;right);
            }
        }
        return true;
    }
    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) {
        if(pRoot1 == NULL || pRoot2 == NULL) 
            return false;
        
        queue&amp;lt;TreeNode*&gt; q;
        q.push(pRoot1);
        while(!q.empty()){ 
            TreeNode* node = q.front();
            q.pop();
            if(node-&gt;val == pRoot2-&gt;val){ 
                if(helper(node, pRoot2))
                    return true;
            }
            if(node-&gt;left) 
                q.push(node-&gt;left);
            if(node-&gt;right) 
                q.push(node-&gt;right);
        }
        return false;
    }
};&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;二叉树的层次遍历模板&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;#include &amp;lt;queue&gt;
#include &amp;lt;vector&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

vector&amp;lt;vector&amp;lt;int&gt;&gt; levelOrder(TreeNode* root) {
    vector&amp;lt;vector&amp;lt;int&gt;&gt; result;
    if (!root) return result;  // 空树直接返回

    queue&amp;lt;TreeNode*&gt; q;
    q.push(root);

    while (!q.empty()) {
        int levelSize = q.size();  // 当前层的节点数
        vector&amp;lt;int&gt; currentLevel;

        for (int i = 0; i &amp;lt; levelSize; ++i) {
            TreeNode* node = q.front();
            q.pop();
            currentLevel.push_back(node-&gt;val);

            if (node-&gt;left) q.push(node-&gt;left);
            if (node-&gt;right) q.push(node-&gt;right);
        }

        result.push_back(currentLevel);  // 保存当前层结果
    }

    return result;
}&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no17-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no17-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A0%91/" term="树" label="树" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No16.合并两个有序链表</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no16-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no16-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-19T07:37:50&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;
  &lt;p&gt;
    要求：空间复杂度 O(1) ，时间复杂度 O(n) 。
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;**方法1：**新链表合并，抄自牛客题解。比较直观。&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no16-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no16-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;
  &lt;p&gt;
    要求：空间复杂度 O(1) ，时间复杂度 O(n) 。
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;**方法1：**新链表合并，抄自牛客题解。比较直观。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
        auto vhead=new ListNode(-1); //设置一个哨兵指针
        ListNode *newhead=vhead;
        while(pHead1&amp;&amp;pHead2)
        {
            if(pHead1-&gt;val &amp;lt;= pHead2-&gt;val){
                newhead-&gt;next = pHead1;
                pHead1 = pHead1-&gt;next;
            }else{
                newhead-&gt;next = pHead2;
                pHead2 = pHead2-&gt;next;
            }
            newhead = newhead-&gt;next;
        }
        if(pHead2==nullptr) 
            newhead-&gt;next=pHead1;
        if(pHead1==nullptr)
            newhead-&gt;next=pHead2;
        return vhead-&gt;next;
    }
};&lt;/pre&gt;
&lt;p&gt;**方法2：**递归。时间复杂度：O(m+n)；空间复杂度：O(m+n)。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
 ListNode* Merge(ListNode* pHead1, ListNode* pHead2)
 {
     if (!pHead1) return pHead2;
     if (!pHead2) return pHead1;
     if (pHead1-&gt;val &amp;lt;= pHead2-&gt;val) {
         pHead1-&gt;next = Merge(pHead1-&gt;next, pHead2);
         return pHead1;
     }
     else {
         pHead2-&gt;next = Merge(pHead1, pHead2-&gt;next);
         return pHead2;
     }
 }
};&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no16-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no16-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E9%93%BE%E8%A1%A8/" term="链表" label="链表" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No15.反转链表</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no15-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no15-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-19T07:33:09&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_45031801/article/details/139496847&#34;&gt;反转链表的三种方法–面试必考（图例超详细解析，小白一看就会！！！）-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;
  &lt;p&gt;
    要求：空间复杂度 O(1) ，时间复杂度 O(n) 。
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;方法1：就地逆置，三指针迭代&lt;/strong&gt;&lt;br&gt;
分不太清头插法和就地逆置的区别，感觉没啥区别。&lt;br&gt;
三个指针temp、cur、newCur；&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no15-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no15-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_45031801/article/details/139496847&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;反转链表的三种方法–面试必考（图例超详细解析，小白一看就会！！！）-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;
  &lt;p&gt;
    要求：空间复杂度 O(1) ，时间复杂度 O(n) 。
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;方法1：就地逆置，三指针迭代&lt;/strong&gt;&lt;br&gt;
分不太清头插法和就地逆置的区别，感觉没啥区别。&lt;br&gt;
三个指针temp、cur、newCur；&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;ListNode* ReverseList(ListNode* head) {
        if(head == nullptr || head-&gt;next == nullptr) return head;
        ListNode* cur = head;
        ListNode* temp = nullptr;
        ListNode* newCur = nullptr;
        while(cur != nullptr){
            temp = cur-&gt;next;
            cur-&gt;next = newCur;
            newCur = cur;
            cur = temp;
        }
        return newCur;
    }&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;方法2：递归&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) :
            val(x), next(NULL) {
    }
};*/
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
    if(pHead==NULL || pHead-&gt;next==NULL){
        return pHead;
    }
        ListNode* ans = ReverseList(pHead-&gt;next);
        //让当前结点的下一个结点的 next 指针指向当前节点
		//同时让当前结点的 next 指针指向NULL ，从而实现从链表尾部开始的局部反转
        //最小递归的情况是321变成123
        pHead-&gt;next-&gt;next=pHead;
        pHead-&gt;next=NULL;
        return ans;
    }
};&lt;/pre&gt;

                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no15-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/19/%E5%89%91%E6%8C%87offer67%E9%A2%98-no15-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E9%93%BE%E8%A1%A8/" term="链表" label="链表" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No14.链表中倒数第k个结点</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/15/%E5%89%91%E6%8C%87offer67%E9%A2%98-no14-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/15/%E5%89%91%E6%8C%87offer67%E9%A2%98-no14-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-15T13:04:00&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;&lt;strong&gt;只遍历链表一次的做法&lt;/strong&gt;： 双指针算法。&lt;br&gt;
第一个指针先走k-1步，从第k步开始，第二个指针也开始和第一个指针同步走。两个指针距离保持k-1，第一个指针走到尾节点时，第二个就刚好到了倒数第k个节点上。&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/15/%E5%89%91%E6%8C%87offer67%E9%A2%98-no14-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/15/%E5%89%91%E6%8C%87offer67%E9%A2%98-no14-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;&lt;strong&gt;只遍历链表一次的做法&lt;/strong&gt;： 双指针算法。&lt;br&gt;
第一个指针先走k-1步，从第k步开始，第二个指针也开始和第一个指针同步走。两个指针距离保持k-1，第一个指针走到尾节点时，第二个就刚好到了倒数第k个节点上。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    int kthToLast(ListNode* head, int k) {
        if(head == nullptr) return 0;
        ListNode* curI = head;
        ListNode* curJ = head;
        int cnt = 0;
        for(int i = 0; i &amp;lt; k -1; i++){
            if(curJ-&gt;next != nullptr) curJ = curJ-&gt;next;
        }
        while(curJ-&gt;next != nullptr){
            curI = curI-&gt;next;
            curJ = curJ-&gt;next;
        }
        return curI-&gt;val;
    }
};&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/15/%E5%89%91%E6%8C%87offer67%E9%A2%98-no14-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/15/%E5%89%91%E6%8C%87offer67%E9%A2%98-no14-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/" term="双指针算法" label="双指针算法" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E9%93%BE%E8%A1%A8/" term="链表" label="链表" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No13.调整数组顺序使奇数位于偶数前面</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/15/%E5%89%91%E6%8C%87offer67%E9%A2%98-no13-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/15/%E5%89%91%E6%8C%87offer67%E9%A2%98-no13-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-15T13:03:09&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;
  &lt;p&gt;
    输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。
  &lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/15/%E5%89%91%E6%8C%87offer67%E9%A2%98-no13-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/15/%E5%89%91%E6%8C%87offer67%E9%A2%98-no13-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;
  &lt;p&gt;
    输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;解法1&lt;/strong&gt;： 从头到尾扫描数组，遇到偶数就取出来，把偶数后面的数字往前挪，偶数填在最后面。&lt;br&gt;
时间复杂度O(n²)，空间复杂度O(1)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解法2&lt;/strong&gt;： 开一个新数组从头到尾扫描，东西存新数组里。时间复杂度O(n)，空间复杂度O(n)。&lt;/p&gt;
&lt;p&gt;解法3： &lt;strong&gt;交错扫描，定义下标i和j，分别从开头和结尾开始扫描，空间复杂度是O(1)，时间复杂度O(n)。&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    当i遇到偶数时，停止扫描
  &lt;/li&gt;
  &lt;li&gt;
    当j遇到奇数时，停止扫描
  &lt;/li&gt;
  &lt;li&gt;
    此时交换i和j位置的值
  &lt;/li&gt;
  &lt;li&gt;
    继续前面的操作，直到i和j交错或相等
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;void reOrderArray(vector&amp;lt;int&gt; &amp;array) {
		if(array.size() == 0) return;
		int i = 0;
		int j = array.size() - 1;
		while(1){
            // i遇到偶数停止，j遇到奇数停止
            while(1 == (array[i]) &amp; 1){
                i++;
            }
            while(0 == (array[j]) &amp; 1){
                j++;
            }
            if(i &amp;lt; j){
                swap(array[i], array[j]);
            }else{
                break;
            }
        }
    }&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/15/%E5%89%91%E6%8C%87offer67%E9%A2%98-no13-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/15/%E5%89%91%E6%8C%87offer67%E9%A2%98-no13-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/" term="双指针算法" label="双指针算法" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No12.数值的整数次方</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/15/%E5%89%91%E6%8C%87offer67%E9%A2%98-no12%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/15/%E5%89%91%E6%8C%87offer67%E9%A2%98-no12%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-15T12:59:42&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;要注意正负号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快速幂&lt;/strong&gt;算法。&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/95902286&#34;&gt;算法学习笔记(4)：快速幂 – 知乎&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;递归快速幂：计算a的n次方，如果n是偶数（不为0），那么就&lt;strong&gt;先计算a的n/2次方，然后平方&lt;/strong&gt;；如果n是奇数，那么就&lt;strong&gt;先计算a的n-1次方，再乘上a&lt;/strong&gt;；递归出口是&lt;strong&gt;a的0次方为1&lt;/strong&gt;。这个算法的时间复杂度是&lt;strong&gt;O(logn)的&lt;/strong&gt;。&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/15/%E5%89%91%E6%8C%87offer67%E9%A2%98-no12%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/15/%E5%89%91%E6%8C%87offer67%E9%A2%98-no12%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;要注意正负号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快速幂&lt;/strong&gt;算法。&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/95902286&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;算法学习笔记(4)：快速幂 – 知乎&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;递归快速幂：计算a的n次方，如果n是偶数（不为0），那么就&lt;strong&gt;先计算a的n/2次方，然后平方&lt;/strong&gt;；如果n是奇数，那么就&lt;strong&gt;先计算a的n-1次方，再乘上a&lt;/strong&gt;；递归出口是&lt;strong&gt;a的0次方为1&lt;/strong&gt;。这个算法的时间复杂度是&lt;strong&gt;O(logn)的&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;int qpow(int a, int n)
{
    if (n == 0)
        return 1;
    else if (n % 2 == 1)
        return qpow(a, n - 1) * a;
    else
    {
        int temp = qpow(a, n / 2);
        return temp * temp;
    }
}&lt;/pre&gt;
&lt;p&gt;另：大素数取模问题，对某个超大的数取模，有以下数学原理：&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    模运算的性质：&lt;code&gt;(a⋅b) % m=[(a % m)⋅(b % m)] % m&lt;/code&gt;
  &lt;/li&gt;
  &lt;li&gt;
    这意味着可以&lt;strong&gt;在每一步乘法后取模，避免数值溢出&lt;/strong&gt;，同时保持结果的正确性。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;快速幂取模：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;//递归快速幂（对大素数取模）
// 对a的n次方取mod
#define MOD 1000000007
typedef long long ll;
ll qpow(ll a, ll n)
{
    if (n == 0)
        return 1;
    else if (n % 2 == 1)
        return qpow(a, n - 1) * a % MOD;
    else
    {
        ll temp = qpow(a, n / 2) % MOD;
        return temp * temp % MOD;
    }
}&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;非递归快速幂：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;非递归快速幂（迭代法）通过 &lt;strong&gt;二进制分解指数&lt;/strong&gt; 来高效计算 &lt;em&gt;a^n&lt;/em&gt;。它的核心原理是：&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    将指数 &lt;em&gt;n&lt;/em&gt; 表示为二进制形式，逐位检查是否为 1。
  &lt;/li&gt;
  &lt;li&gt;
    如果某一位是 1，就将当前的 &lt;em&gt;a&lt;/em&gt; 的幂乘到结果中。
  &lt;/li&gt;
  &lt;li&gt;
    每一步 &lt;em&gt;a&lt;/em&gt; 都会平方，对应二进制位的权重。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;每一次循环，a都会平方，但是只有移位的那一位是1的时候，才能算入最终结果中。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
  public:
    double Power(double base, int exponent) {
        if(exponent == 0) return 1.0;
        if(base == 0) return 0;
        int flag = 0;
        if(exponent &amp;lt; 0){
            exponent = -exponent;
            base = 1 / base;
        }
        double answer = 1;
        while(exponent &gt; 0){
            if((exponent &amp; 1) == 1){ // 说明这一位是1 最后的结果需要乘入
                answer = answer * base;
            }
            base = base * base;
            exponent = exponent &gt;&gt; 1;
        }
        return answer;
    }
};&lt;/pre&gt;

                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/15/%E5%89%91%E6%8C%87offer67%E9%A2%98-no12%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/15/%E5%89%91%E6%8C%87offer67%E9%A2%98-no12%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/" term="快速幂" label="快速幂" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No11.二进制中1的个数</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/15/no11%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/15/no11%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-15T12:24:21&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;可以用移位运算来写，这样的问题在于，负数，c++中的右移是算数右移，（高位补 &lt;code&gt;1&lt;/code&gt;），而不是逻辑右移（高位补 &lt;code&gt;）。`n`永远不会变成 &lt;/code&gt;，而是会一直保持 &lt;code&gt;-1&lt;/code&gt;。&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/15/no11%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/15/no11%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;可以用移位运算来写，这样的问题在于，负数，c++中的右移是算数右移，（高位补 &lt;code&gt;1&lt;/code&gt;），而不是逻辑右移（高位补 &lt;code&gt;）。`n`永远不会变成 &lt;/code&gt;，而是会一直保持 &lt;code&gt;-1&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;//    错误的示例
int NumberOf1(int n) {
        // write code here
        int cnt = 0;
        while(n != 0){
            if((n &amp; 0x1) == 1){
                cnt++;
            }
            n = n &gt;&gt; 1;
        }
        return cnt;
    }&lt;/pre&gt;
&lt;p&gt;解决方法，可以固定只检查32位；&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;int NumberOf1(int n) {
    int cnt = 0;
    for (int i = 0; i &amp;lt; 32; i++) {
        if ((n &amp; (1 &amp;lt;&amp;lt; i)) != 0) {  // 检查第i位是否为1
            cnt++;
        }
    }
    return cnt;
}&lt;/pre&gt;
&lt;p&gt;还有一种使用&lt;code&gt;std::bitset&lt;/code&gt;的方法。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;int  NumberOf1(int n) {
	return bitset&amp;lt;32&gt;(n).count(); //统计32位中有多少位是1
	}&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;bitset&lt;/code&gt;的一些用法：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;bitset&amp;lt;8&gt; bitset2(12);　　//长度为８，二进制保存，前面用０补充

string s = &#34;100101&#34;;
bitset&amp;lt;10&gt; bitset3(s);　　//长度为10，前面用０补充

char s2[] = &#34;10101&#34;;
bitset&amp;lt;13&gt; bitset4(s2);　　//长度为13，前面用０补充

cout &amp;lt;&amp;lt; bitset1 &amp;lt;&amp;lt; endl;　　//0000
cout &amp;lt;&amp;lt; bitset2 &amp;lt;&amp;lt; endl;　　//00001100
cout &amp;lt;&amp;lt; bitset3 &amp;lt;&amp;lt; endl;　　//0000100101
cout &amp;lt;&amp;lt; bitset4 &amp;lt;&amp;lt; endl;　　//0000000010101

bitset&amp;lt;8&gt; foo (&#34;10011011&#34;);
 
cout &amp;lt;&amp;lt; foo.count() &amp;lt;&amp;lt; endl;　　//5　　（count函数用来求bitset中1的位数，foo中共有５个１
cout &amp;lt;&amp;lt; foo.size() &amp;lt;&amp;lt; endl;　　 //8　　（size函数用来求bitset的大小，一共有８位

cout &amp;lt;&amp;lt; foo.test(0) &amp;lt;&amp;lt; endl;　　//true　　（test函数用来查下标处的元素是０还是１，并返回false或true，此处foo[0]为１，返回true
cout &amp;lt;&amp;lt; foo.test(2) &amp;lt;&amp;lt; endl;　　//false　　（同理，foo[2]为０，返回false
  
cout &amp;lt;&amp;lt; foo.any() &amp;lt;&amp;lt; endl;　　//true　　（any函数检查bitset中是否有１
cout &amp;lt;&amp;lt; foo.none() &amp;lt;&amp;lt; endl;　　//false　　（none函数检查bitset中是否没有１
cout &amp;lt;&amp;lt; foo.all() &amp;lt;&amp;lt; endl;　　//false　　（all函数检查bitset中是全部为１&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/15/no11%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/15/no11%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" term="位运算" label="位运算" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No7-No10.简单dp递归合集</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/13/%E5%89%91%E6%8C%87offer67%E9%A2%98-no7-no10-%E7%AE%80%E5%8D%95dp%E9%80%92%E5%BD%92%E5%90%88%E9%9B%86/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/13/%E5%89%91%E6%8C%87offer67%E9%A2%98-no7-no10-%E7%AE%80%E5%8D%95dp%E9%80%92%E5%BD%92%E5%90%88%E9%9B%86/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-13T09:26:34&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;h2 class=&#34;wp-block-heading&#34; id=&#34;no7斐波那契数列&#34;&gt;NO7斐波那契数列&lt;/h2&gt;
&lt;p&gt;用递归的写法，复杂度将是O(2^n)级别的，无法忍受。 用三个变量存储递归的中间值，时间复杂度能到O(n)。&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/13/%E5%89%91%E6%8C%87offer67%E9%A2%98-no7-no10-%E7%AE%80%E5%8D%95dp%E9%80%92%E5%BD%92%E5%90%88%E9%9B%86/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/13/%E5%89%91%E6%8C%87offer67%E9%A2%98-no7-no10-%E7%AE%80%E5%8D%95dp%E9%80%92%E5%BD%92%E5%90%88%E9%9B%86/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;no7斐波那契数列&#34;&gt;NO7斐波那契数列&lt;/h2&gt;
&lt;p&gt;用递归的写法，复杂度将是O(2^n)级别的，无法忍受。 用三个变量存储递归的中间值，时间复杂度能到O(n)。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;   public int Fibonacci (int n) {
        // write code here
       int t1 = 1;
       int t2 = 1;
       int t3 = 1;
       for(int i = 2; i &amp;lt; n; i++){
            t3 = t1 + t2;
            t1 = t2;
            t2 = t3;
       }
       return t3;
    }&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;no8跳台阶&#34;&gt;NO8跳台阶&lt;/h2&gt;
&lt;p&gt;递归做法&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    int jumpFloor(int number) {
        // write code here
        if(number == 1) return 1;
        if(number == 2) return 2;
        return jumpFloor(number -1) + jumpFloor(number - 2);
    }
};&lt;/pre&gt;
&lt;p&gt;简单dp做法&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    int jumpFloor(int number) {
        // write code here
        std::array&amp;lt;int, 50&gt; dp{};
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3; i &amp;lt;= number; i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
​
        return dp[number];
    }
};&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;no9跳台阶扩展&#34;&gt;NO9跳台阶扩展&lt;/h2&gt;
&lt;p&gt;dp，找规律：dp[i] = 2 * dp[i-1];&lt;/p&gt;
&lt;p&gt;第i次跳，可以是第i-1次的数目+1跳，也可以是第i-2次的数目+2跳，也可以是第i-3次的数目+3跳，即：&lt;/p&gt;
&lt;p&gt;dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + … + dp[0] dp[i-1] = dp[i-2] + dp[i-3] + … + dp[0] 所以，dp[i] = 2 * dp[i-1];&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;   int jumpFloorII(int number) {
        // write code here
        std::array&amp;lt;int, 50&gt; dp{};
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3; i&amp;lt;=number; i++){
            dp[i] = 2*dp[i-1];
        }
        return dp[number];&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;no10矩形覆盖&#34;&gt;NO10矩形覆盖&lt;/h2&gt;
&lt;p&gt;找规律？类似斐波那契数列&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    int rectCover(int number) {
        if(number &amp;lt;= 2) 
            return number;
        int dpi_2 = 1; 
        int dpi_1 = 2; 
        int res = 0;
        for(int i = 3; i &amp;lt;= number; i++){
            //公式相加
            res = dpi_1 + dpi_2; 
            //变量更新
            dpi_2 = dpi_1; 
            dpi_1 = res;
        }
        return res;
    }
};&lt;/pre&gt;
&lt;p&gt;PS：感觉以后遇到简单的dp问题，想不出来转移方程可以先多写几个找规律？&lt;/p&gt;

                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/13/%E5%89%91%E6%8C%87offer67%E9%A2%98-no7-no10-%E7%AE%80%E5%8D%95dp%E9%80%92%E5%BD%92%E5%90%88%E9%9B%86/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/13/%E5%89%91%E6%8C%87offer67%E9%A2%98-no7-no10-%E7%AE%80%E5%8D%95dp%E9%80%92%E5%BD%92%E5%90%88%E9%9B%86/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/dp/" term="DP" label="DP" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E9%80%92%E5%BD%92/" term="递归" label="递归" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No6.旋转数组中的最小数字</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/13/%E5%89%91%E6%8C%87offer67%E9%A2%98-no6-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/13/%E5%89%91%E6%8C%87offer67%E9%A2%98-no6-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-13T09:22:58&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;二分法。 &lt;a href=&#34;https://zhuanlan.zhihu.com/p/259545903&#34;&gt;二分法的本质、模板、例题 – 知乎&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;二分法的关键是找出目标点的性质。&lt;/p&gt;
&lt;p&gt;观察题目中，旋转数组的性质，能发现最小的数字一定是小于等于最右端点的。即&lt;strong&gt;找出某区间的最左值&lt;/strong&gt;，用&lt;strong&gt;二分法的右区间模板&lt;/strong&gt;。&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/13/%E5%89%91%E6%8C%87offer67%E9%A2%98-no6-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/13/%E5%89%91%E6%8C%87offer67%E9%A2%98-no6-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;二分法。 &lt;a href=&#34;https://zhuanlan.zhihu.com/p/259545903&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;二分法的本质、模板、例题 – 知乎&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;二分法的关键是找出目标点的性质。&lt;/p&gt;
&lt;p&gt;观察题目中，旋转数组的性质，能发现最小的数字一定是小于等于最右端点的。即&lt;strong&gt;找出某区间的最左值&lt;/strong&gt;，用&lt;strong&gt;二分法的右区间模板&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    int minArray(vector&amp;lt;int&gt; &amp;numbers) {
        int pivot = numbers.back();
        int l = 0, r = numbers.size() - 1;
        while (l &amp;lt; r) {
            int mid = l + r &gt;&gt; 1;
            if (numbers[mid] &amp;lt;= pivot) r = mid;//考虑到可能只旋转了一个数，最小值就是最后一个，故小于等于
            else l = mid + 1;
        }
        return numbers[l];
    }
};&lt;/pre&gt;
&lt;p&gt;上述方法无法解决重复数字的问题。&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    &lt;code&gt;pivot&lt;/code&gt; 取的是数组最后一个元素 &lt;code&gt;numbers.back()&lt;/code&gt;，且视为 &lt;code&gt;numbers[mid] &amp;lt;= pivot&lt;/code&gt; 时，最小值在 &lt;code&gt;[l, mid]&lt;/code&gt; 区间。
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;但旋转数组可能有重复元素&lt;/strong&gt;（如 &lt;code&gt;[1,1,1,0,1]&lt;/code&gt;），此时 &lt;code&gt;numbers[mid] == pivot&lt;/code&gt; 并不能保证最小值在 &lt;code&gt;[l, mid]&lt;/code&gt;，可能仍在右侧。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决的方法很简单：&lt;strong&gt;l从第一个非重复元素开始&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    int minArray(vector&amp;lt;int&gt; &amp;numbers) {
        //3 4 1 2 3
        int l = 0, r = numbers.size() - 1;
        int pivot = numbers.back();
        while(l &amp;lt; numbers.size() - 1 &amp;&amp; numbers[l] == pivot) l++; //上一版代码的补丁，从第一个不同的数字开始。
        if(numbers[l] &amp;lt;= pivot) return numbers[l]; //特判
        while (l &amp;lt; r) {
            int mid = l + r &gt;&gt; 1;
            if (numbers[mid] &amp;lt;= pivot) r = mid;
            else l = mid + 1;
        }
        return numbers[l];
    }
};&lt;/pre&gt;
&lt;p&gt;另注：二分法有两个模板。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;右区间模板：
得到右区间的左端点。
	int search(vector&amp;lt;int&gt; &amp;nums, int target) {
        int l = 0, r = nums.size() - 1;
        while (l &amp;lt; r) {
            int mid = (l + r) / 2;
            if (check(mid)) r = mid;
            else l = mid + 1;
        }
        if (nums[l] != target) return -1;
        return l;
    }&lt;/pre&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;左区间模板：
得到左区间的右端点。 
int search(vector&amp;lt;int&gt; &amp;nums, int target) {
        int l = 0, r = nums.size() - 1;
        while (l &amp;lt; r) {
            int mid = (l + r + 1) / 2;
            if (check(mid)) l = mid;
            else r = mid - 1;
        }
        if (nums[l] != target) return -1;
        return l;
    }
};&lt;/pre&gt;

                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/13/%E5%89%91%E6%8C%87offer67%E9%A2%98-no6-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/13/%E5%89%91%E6%8C%87offer67%E9%A2%98-no6-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" term="二分查找" label="二分查找" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No5.两个栈来实现一个队列</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/13/%E5%89%91%E6%8C%87offer67%E9%A2%98-no5-%E4%B8%A4%E4%B8%AA%E6%A0%88%E6%9D%A5%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/13/%E5%89%91%E6%8C%87offer67%E9%A2%98-no5-%E4%B8%A4%E4%B8%AA%E6%A0%88%E6%9D%A5%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-13T09:20:24&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;借助栈的&lt;strong&gt;先进后出&lt;/strong&gt;规则模拟实现队列的&lt;strong&gt;先进先出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、当插入时，直接插入 stack1&lt;/p&gt;
&lt;p&gt;2、当弹出时，当 stack2 不为空，弹出 stack2 栈顶元素，如果 stack2 为空，将 stack1 中的全部数逐个出栈入栈到 stack2，再弹出 stack2 栈顶元素。&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/13/%E5%89%91%E6%8C%87offer67%E9%A2%98-no5-%E4%B8%A4%E4%B8%AA%E6%A0%88%E6%9D%A5%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/13/%E5%89%91%E6%8C%87offer67%E9%A2%98-no5-%E4%B8%A4%E4%B8%AA%E6%A0%88%E6%9D%A5%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;借助栈的&lt;strong&gt;先进后出&lt;/strong&gt;规则模拟实现队列的&lt;strong&gt;先进先出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、当插入时，直接插入 stack1&lt;/p&gt;
&lt;p&gt;2、当弹出时，当 stack2 不为空，弹出 stack2 栈顶元素，如果 stack2 为空，将 stack1 中的全部数逐个出栈入栈到 stack2，再弹出 stack2 栈顶元素。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution
{
public:
    void push(int node) {
        stack1.push(node);
    }

    int pop() {
        if(stack2.empty()){
            while(!stack1.empty()){
                stack2.push(stack1.top());
                stack1.pop();
            }
        }
        int node = stack2.top();
        stack2.pop();
        return node;
    }

private:
    stack&amp;lt;int&gt; stack1;
    stack&amp;lt;int&gt; stack2;

};&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/13/%E5%89%91%E6%8C%87offer67%E9%A2%98-no5-%E4%B8%A4%E4%B8%AA%E6%A0%88%E6%9D%A5%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/13/%E5%89%91%E6%8C%87offer67%E9%A2%98-no5-%E4%B8%A4%E4%B8%AA%E6%A0%88%E6%9D%A5%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A0%88/" term="栈" label="栈" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No4.重建二叉树</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/12/%E5%89%91%E6%8C%87offer67%E9%A2%98-no4-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/12/%E5%89%91%E6%8C%87offer67%E9%A2%98-no4-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-12T05:29:08&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;剑指offer第三题：从头到尾打印链表，比较简单。代码如下：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;#include &amp;lt;vector&gt;
class Solution {
public:
    vector&amp;lt;int&gt; printListFromTailToHead(ListNode* head) {
        if(head == nullptr) return vector&amp;lt;int&gt;();

        vector&amp;lt;int&gt; r;
        while (head != nullptr) {
            r.push_back(head-&gt;val);
            head = head-&gt;next;
        }
        reverse(r.begin(), r.end());
        return r;
    }
};&lt;/pre&gt;
&lt;p&gt;重建二叉树：比较难的题目。&lt;br&gt;
题目&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/12/%E5%89%91%E6%8C%87offer67%E9%A2%98-no4-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/12/%E5%89%91%E6%8C%87offer67%E9%A2%98-no4-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;剑指offer第三题：从头到尾打印链表，比较简单。代码如下：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;#include &amp;lt;vector&gt;
class Solution {
public:
    vector&amp;lt;int&gt; printListFromTailToHead(ListNode* head) {
        if(head == nullptr) return vector&amp;lt;int&gt;();

        vector&amp;lt;int&gt; r;
        while (head != nullptr) {
            r.push_back(head-&gt;val);
            head = head-&gt;next;
        }
        reverse(r.begin(), r.end());
        return r;
    }
};&lt;/pre&gt;
&lt;p&gt;重建二叉树：比较难的题目。&lt;br&gt;
题目&lt;/p&gt;
&lt;blockquote class=&#34;wp-block-quote is-layout-flow wp-block-quote-is-layout-flow&#34;&gt;
  &lt;p&gt;
    给定节点数为 n 的二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考博客：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/149513536&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;剑指 Offer 07. 重建二叉树 – leetcode 剑指offer系列 – 知乎&lt;/a&gt;&lt;br&gt;
思想1：递归。&lt;br&gt;
前序遍历是根左右，中序遍历是左根右。&lt;br&gt;
前序遍历可以得到根节点，&lt;strong&gt;拿根节点去对应中序遍历&lt;/strong&gt;，可以知道中序遍历序列中根节点左边的是根的左子树，右边的是根的右子树。如：&lt;/p&gt;
&lt;pre class=&#34;wp-block-preformatted&#34;&gt;pre: 1 2 3 4 5 6 7&lt;br /&gt;tin: 3 2 4 1 6 5 7&lt;br /&gt;说明1的左边肯定是324,右边肯定是657&lt;/pre&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;TreeNode* reConstructBinaryTree(vector&amp;lt;int&gt; pre,vector&amp;lt;int&gt; vin) {
    int n = pre.size();
    int m = vin.size();
    if(n == 0 || m == 0) 
        return nullptr;

    TreeNode *root = new TreeNode(pre[0]); 
    int root_val = pre[0];

    for(int i = 0; i &amp;lt; vin.size(); i++){
        //找到中序遍历中的前序第一个元素
        if(root_val == vin[i]){ 
            //左子树的前序遍历
            vector&amp;lt;int&gt; leftpre(pre.begin() + 1, pre.begin() + i + 1); 
            //左子树的中序遍历
            vector&amp;lt;int&gt; leftvin(vin.begin(), vin.begin() + i); 
            //构建左子树
            root-&gt;left = reConstructBinaryTree(leftpre, leftvin); 
            //右子树的前序遍历
            vector&amp;lt;int&gt; rightpre(pre.begin() + i + 1, pre.end()); 
            //右子树的中序遍历
            vector&amp;lt;int&gt; rightvin(vin.begin() + i + 1, vin.end()); 
            //构建右子树
            root-&gt;right = reConstructBinaryTree(rightpre, rightvin); 
            break;
        }
    }
    return root;
}&lt;/pre&gt;
&lt;p&gt;这种算法的时空复杂度都是O(n)。&lt;/p&gt;
&lt;p&gt;另一种方法是栈，时空复杂度一样都是O(n)。 思路是基于前序遍历的性质：根左右。某个点p的下一个节点q，只有下面3种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;q是p的左节点&lt;/li&gt;
&lt;li&gt;q是p的右节点(p没有左节点)&lt;/li&gt;
&lt;li&gt;q是p的祖先节点的右节点&lt;br&gt;
其中2，3情况可以归结为：q是某子树的右节点。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体例子：&lt;/p&gt;
&lt;pre class=&#34;wp-block-preformatted&#34;&gt;前序遍历 preorder = [3,9,20,15,7]&lt;br /&gt;中序遍历 inorder = [9,3,15,20,7]&lt;/pre&gt;
&lt;p&gt;判断3之后的9究竟是哪一种情况，要结合中序遍历，中序遍历第一个数字是9而不是3，说明9肯定是在3的左侧(中序遍历左根右)。20呢，根据中序遍历，20不可能是9的左节点，只可能是3的右子树节点。&lt;/p&gt;
&lt;ol class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    遍历前序序列, 使用栈保存当前前序已经遍历的节点
  &lt;/li&gt;
  &lt;li&gt;
    然后使用一个下标记录当前中序节点位置
  &lt;/li&gt;
  &lt;li&gt;
    最后根据栈顶节点和当前中序节点的值是否相等来判断节点关系 &lt;ol class=&#34;wp-block-list&#34;&gt;
      &lt;li&gt;
        &lt;strong&gt;不相等: 表示当前节点一定是栈顶节点的左子节点&lt;/strong&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;strong&gt;相等（如果栈顶节点值 = 当前中序节点值，说明栈顶节点的左子树已处理完毕）: 则需要弹出栈并向后移中序下标, 直到值不相等或者栈为空位置, 记录最后一个值相等的节点, 其右子节点就是当前节点了&lt;/strong&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;class Solution {
public:
    TreeNode* reConstructBinaryTree(vector&amp;lt;int&gt; pre,vector&amp;lt;int&gt; vin) {
        int n = pre.size();
        int m = vin.size();
        if(n == 0 || m == 0) 
            return NULL;
        stack&amp;lt;TreeNode*&gt; s;
        
        //首先建立前序根节点
        TreeNode *root = new TreeNode(pre[0]); 
        TreeNode *cur = root;
        for(int i = 1, j = 0; i &amp;lt; n; i++){
            //前序序列的值和中序序列的值不一样
            if(cur-&gt;val != vin[j]){ 
                cur-&gt;left = new TreeNode(pre[i]);
                //入栈
                s.push(cur);
                cur = cur-&gt;left; 
            }else{// 值相等，说明栈顶节点的左子树已处理完毕
                j++;
                //弹出到符合的祖先
                while(!s.empty() &amp;&amp; s.top()-&gt;val == vin[j]){ 
                    cur = s.top();
                    s.pop();
                    j++;
                }
                //添加右节点
                cur-&gt;right = new TreeNode(pre[i]); 
                cur = cur-&gt;right;
            }
        }
        return root;
    }
};&lt;/pre&gt;

                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/12/%E5%89%91%E6%8C%87offer67%E9%A2%98-no4-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/12/%E5%89%91%E6%8C%87offer67%E9%A2%98-no4-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%80%BC%E5%BE%97%E4%BA%8C%E5%88%B7/" term="值得二刷" label="值得二刷" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E6%A0%91/" term="树" label="树" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E9%80%92%E5%BD%92/" term="递归" label="递归" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No2.替换空格</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/12/%E5%89%91%E6%8C%87offer67%E9%A2%98-no2-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/12/%E5%89%91%E6%8C%87offer67%E9%A2%98-no2-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-12T04:50:02&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;&lt;strong&gt;双指针算法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;朴素思想是顺序查找，查找到了之后再进行移动替换。时间复杂度是O(n²)。&lt;br&gt;
更优秀的&lt;strong&gt;O(n)解法&lt;/strong&gt;是，先遍历一遍，找出空格的个数，进而可以得出替换后的字符串长度，用双指针P1，P2。&lt;br&gt;
P1指向原字符串的最后一位字符，P2指向替换后字符串的最后一位（目前为空）。P1、P2开始&lt;strong&gt;从后往前&lt;/strong&gt;，边移动边复制，直到P1遇到了空格，P2添加%20之后，继续双指针移动。&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/12/%E5%89%91%E6%8C%87offer67%E9%A2%98-no2-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/12/%E5%89%91%E6%8C%87offer67%E9%A2%98-no2-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;&lt;strong&gt;双指针算法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;朴素思想是顺序查找，查找到了之后再进行移动替换。时间复杂度是O(n²)。&lt;br&gt;
更优秀的&lt;strong&gt;O(n)解法&lt;/strong&gt;是，先遍历一遍，找出空格的个数，进而可以得出替换后的字符串长度，用双指针P1，P2。&lt;br&gt;
P1指向原字符串的最后一位字符，P2指向替换后字符串的最后一位（目前为空）。P1、P2开始&lt;strong&gt;从后往前&lt;/strong&gt;，边移动边复制，直到P1遇到了空格，P2添加%20之后，继续双指针移动。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;char* ReplaceBlank(char string[], int length) {
    if (string == nullptr || length &amp;lt;= 0) {
        return nullptr;  // 返回 nullptr 而不是直接 return
    }

    int blank_cnt = 0;
    for (int i = 0; i &amp;lt; length; i++) {
        if (string[i] == &#39; &#39;) blank_cnt++;
    }

    int new_length = length + 2 * blank_cnt;
    char* new_str = new char[new_length + 1];  // +1 用于 &#39;\0&#39;

    int p2 = new_length - 1;
    int p1 = length - 1;

    while (p1 &gt;= 0 &amp;&amp; p2 &gt;= 0) {
        if (string[p1] != &#39; &#39;) {
            new_str[p2--] = string[p1--];
        } else {
            new_str[p2--] = &#39;0&#39;;
            new_str[p2--] = &#39;2&#39;;
            new_str[p2--] = &#39;%&#39;;
            p1--;
        }
    }

    new_str[new_length] = &#39;\0&#39;;
    return new_str;
}&lt;/pre&gt;
&lt;p&gt;另tag：&lt;br&gt;
悬垂指针：悬垂指针是指指针指向的内存已经被释放或失效，但指针本身仍然保留原来的地址。例如：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;int* func() {
    int arr[5] = {1, 2, 3, 4, 5};  // 局部数组，函数结束后被销毁
    return arr;  // 返回悬垂指针！
}

int main() {
    int* ptr = func();  // ptr 现在指向已被释放的内存
    std::cout &amp;lt;&amp;lt; ptr[0];  // 未定义行为（可能崩溃或输出垃圾值）
    return 0;
}&lt;/pre&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/12/%E5%89%91%E6%8C%87offer67%E9%A2%98-no2-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/12/%E5%89%91%E6%8C%87offer67%E9%A2%98-no2-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/" term="双指针算法" label="双指针算法" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
剑指offer67题-No1.二维数组的查找</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/10/%E5%89%91%E6%8C%87offer67%E9%A2%98-no1-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/10/%E5%89%91%E6%8C%87offer67%E9%A2%98-no1-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-10T14:35:17&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;牛客链接：&lt;a href=&#34;https://www.nowcoder.com/share/jump/8851183521746887578447&#34;&gt;二维数组的查找&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;wp-block-columns is-layout-flex wp-container-core-columns-is-layout-9d6595d7 wp-block-columns-is-layout-flex&#34;&gt;
  &lt;div class=&#34;wp-block-column is-layout-flow wp-block-column-is-layout-flow&#34; style=&#34;flex-basis:100%&#34;&gt;
    &lt;p&gt;
      暴力方法是遍历两边，复杂度是O(mn)。&lt;br /&gt;核心是二分查找。&lt;br /&gt;二分法：O(nlogm)。
    &lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/10/%E5%89%91%E6%8C%87offer67%E9%A2%98-no1-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/10/%E5%89%91%E6%8C%87offer67%E9%A2%98-no1-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;牛客链接：&lt;a href=&#34;https://www.nowcoder.com/share/jump/8851183521746887578447&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;二维数组的查找&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;wp-block-columns is-layout-flex wp-container-core-columns-is-layout-9d6595d7 wp-block-columns-is-layout-flex&#34;&gt;
  &lt;div class=&#34;wp-block-column is-layout-flow wp-block-column-is-layout-flow&#34; style=&#34;flex-basis:100%&#34;&gt;
    &lt;p&gt;
      暴力方法是遍历两边，复杂度是O(mn)。&lt;br /&gt;核心是二分查找。&lt;br /&gt;二分法：O(nlogm)。
    &lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;bool Find(int target, vector&amp;lt;vector&amp;lt;int&gt; &gt;&amp; array) {
        // write code here
        for(auto &amp;row : array){
            int l = 0;
            int r = row.size() - 1;
            while(l &amp;lt;= r){
                int mid = l + r &gt;&gt; 1;
                if(target == row[mid]){
                    return true;
                }else if(target &amp;lt; row[mid]){
                    r = mid - 1;
                }else{
                    l = mid + 1;
                }
            }
        }
        return false;
    }&lt;/pre&gt;
&lt;p&gt;另外方法：复杂度更低O(n+m)。从右上到左下遍历。这样的思路是因为，从右上到左下，要想变大就只能row++，想变小就只能col–。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;bool Find(int target, vector&amp;lt;vector&amp;lt;int&gt; &gt;&amp; array) {
        // write code here
        //右上角逼近左下角
        int row = 0;
        int col = array[0].size() - 1;
        while(row &amp;lt; array.size() &amp;&amp; col &gt;=0){
            if(target == array[row][col]) return true;
            if(target &amp;lt; array[row][col]) col--;
            else row++;
        }
        return false;
    }&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;另&lt;/strong&gt;：关注c++模式的写法：相比传统的索引ij写法，c++11风格的写法有更多的好处。&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    更简洁，更抽象，可读性更强，不需要管理索引，管理索引可能导致越界。
  &lt;/li&gt;
  &lt;li&gt;
    性能更优秀，&amp;是引用传递，避免了一些不必要的拷贝操作。&lt;br /&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;cpp&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;for(auto &amp;row : array) {
    for(auto &amp;element : row) {
        if(target == element) return true;
    }
}&lt;/pre&gt;

                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/10/%E5%89%91%E6%8C%87offer67%E9%A2%98-no1-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/10/%E5%89%91%E6%8C%87offer67%E9%A2%98-no1-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%9567%E9%A2%98/" term="剑指offer算法67题" label="剑指offer算法67题" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" term="二分查找" label="二分查找" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
基于LangChain4j框架的简单AI对话平台</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/07/aboutme/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/07/aboutme/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-07T14:12:50&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;项目参考自B站程序员鱼皮，基于LangChain4j和Spring Boot实现的一个简单的对话平台。&lt;br&gt;
视频： &lt;a href=&#34;https://www.bilibili.com/video/BV1X4GGziEyr/?p=7&amp;amp;share_source=copy_web&amp;amp;vd_source=678f52c7135e8109c9d58a20f6e13fbc&#34;&gt;https://www.bilibili.com/video/BV1X4GGziEyr/p=7&amp;amp;share_source=copy_web&amp;amp;vd_source=678f52c7135e8109c9d58a20f6e13fbc&lt;/a&gt;&lt;br&gt;
GitHub：&lt;a href=&#34;https://github.com/liyupi/ai-code-helper&#34;&gt;https://github.com/liyupi/ai-code-helper&lt;/a&gt;&lt;br&gt;
我的实现：&lt;a href=&#34;https://gitee.com/wkling/toy-aibot&#34;&gt;toyAIBot: 基于langchain4j和SpringBoot实现的微型AI对话平台&lt;/a&gt;&lt;br&gt;
Demo展示：&lt;a href=&#34;http://117.72.66.48:3000/&#34;&gt;ToyAiHelper&lt;/a&gt;&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/07/aboutme/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/07/aboutme/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;项目参考自B站程序员鱼皮，基于LangChain4j和Spring Boot实现的一个简单的对话平台。&lt;br&gt;
视频： &lt;a href=&#34;https://www.bilibili.com/video/BV1X4GGziEyr/?p=7&amp;amp;share_source=copy_web&amp;amp;vd_source=678f52c7135e8109c9d58a20f6e13fbc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.bilibili.com/video/BV1X4GGziEyr/p=7&amp;amp;share_source=copy_web&amp;amp;vd_source=678f52c7135e8109c9d58a20f6e13fbc&lt;/a&gt;&lt;br&gt;
GitHub：&lt;a href=&#34;https://github.com/liyupi/ai-code-helper&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/liyupi/ai-code-helper&lt;/a&gt;&lt;br&gt;
我的实现：&lt;a href=&#34;https://gitee.com/wkling/toy-aibot&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;toyAIBot: 基于langchain4j和SpringBoot实现的微型AI对话平台&lt;/a&gt;&lt;br&gt;
Demo展示：&lt;a href=&#34;http://117.72.66.48:3000/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ToyAiHelper&lt;/a&gt;&lt;/p&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;多模态&#34;&gt;多模态&lt;/h2&gt;
&lt;p&gt;多模态是指能够同时处理、理解和生成多种不同类型数据的能力，比如文本、图像、音频、视频、PDF 等等。&lt;/p&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;系统提示词&#34;&gt;系统提示词&lt;/h2&gt;
&lt;p&gt;系统提示词是设置 AI 模型行为规则和角色定位的隐藏指令，用户通常不能直接看到。系统 Prompt 相当于给 AI 设定人格和能力边界。&lt;/p&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;ai-service&#34;&gt;AI Service&lt;/h3&gt;
&lt;p&gt;LangChain4j 最重要的开发模式 —— AI Service，提供了很多高层抽象的、用起来更方便的 API，把 AI 应用当做服务来开发。&lt;/p&gt;
&lt;p&gt;调用 &lt;code&gt;AiServices.create&lt;/code&gt; 方法就可以创建出 AI Service 的实现类了，背后的原理是利用 Java 反射机制创建了一个实现接口的代理对象，代理对象负责输入和输出的转换，比如把 String 类型的用户消息参数转为 UserMessage 类型并调用 ChatModel，再将 AI 返回的 AiMessage 类型转换为 String 类型作为返回值。&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;java&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;@Configuration
public class AiCodeHelperFactory {

    @Resource
    private ChatModel qwenChatModel;

    @Bean
    public AiCodeService aiCodeService(){
        // 直接调用AiServices.create 就能够创建出AiCodeService这个Service接口的实现类 背后的原理基于反射
        // 用反射机制创建了一个实现接口的代理对象
        return AiServices.create(AiCodeService.class, qwenChatModel);
    }
}&lt;/pre&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;会话记忆&#34;&gt;会话记忆&lt;/h3&gt;
&lt;p&gt;会话记忆是指让 AI 能够记住用户之前的对话内容，并保持上下文连贯性，这是实现 AI 应用的核心特性。&lt;/p&gt;
&lt;p&gt;LangChain4j 为我们提供了开箱即用的 &lt;code&gt;MessageWindowChatMemory&lt;/code&gt; 会话记忆，最多保存 N 条消息，多余的会自动淘汰。创建会话记忆后，在构造 AI Service 设置 chatMemory&lt;/p&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;结构化输出&#34;&gt;结构化输出&lt;/h3&gt;
&lt;p&gt;结构化输出是指将大模型返回的文本输出转换为结构化的数据格式，比如一段 JSON、一个对象、或者是复杂的对象列表。&lt;/p&gt;
&lt;p&gt;结构化输出有 3 种实现方式：&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    利用大模型的 JSON schema
  &lt;/li&gt;
  &lt;li&gt;
    利用 Prompt + JSON Mode
  &lt;/li&gt;
  &lt;li&gt;
    利用 Prompt(让大模型输出Json)
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实际用&lt;code&gt;LangChain4j&lt;/code&gt;开发时，不需要定义这些方式，只需要修改对话方法的返回值，框架就回自动实现结构化输出。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;rag检索增强生成&#34;&gt;RAG：检索增强生成&lt;/h3&gt;
&lt;p&gt;RAG（Retrieval-Augmented Generation，检索增强生成）是一种结合信息检索技术和 AI 内容生成的混合架构，可以解决大模型的知识时效性限制和幻觉问题。&lt;/p&gt;
&lt;p&gt;简单来说，RAG让 AI 回答问题前先查一查特定的知识库来获取知识，确保回答是基于真实资料而不是凭空想象。很多企业也基于 RAG 搭建了自己的智能客服，可以用自己积累的领域知识回复用户。&lt;/p&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;工具调用&#34;&gt;工具调用&lt;/h3&gt;
&lt;p&gt;工具调用（Tool Calling）可以理解为让 AI 大模型 &lt;strong&gt;借用外部工具&lt;/strong&gt; 来完成它自己做不到的事情。&lt;/p&gt;
&lt;p&gt;跟人类一样，如果只凭手脚完成不了工作，那么就可以利用工具箱来完成。&lt;/p&gt;
&lt;p&gt;工具可以是任何东西，比如网页搜索、对外部 API 的调用、访问外部数据、或执行特定的代码等。&lt;/p&gt;
&lt;p&gt;比如用户提问 “帮我查询上海最新的天气”，AI 本身并没有这些知识，它就可以调用 “查询天气工具”，来完成任务。&lt;/p&gt;
&lt;p&gt;需要注意的是，工具调用的本质 &lt;strong&gt;并不是 AI 服务器自己调用这些工具、也不是把工具的代码发送给 AI 服务器让它执行&lt;/strong&gt;，它只能提出要求，表示 “我需要执行 XX 工具完成任务”。而真正执行工具的是我们自己的应用程序，执行后再把结果告诉 AI，让它继续工作。&lt;/p&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;mcp&#34;&gt;MCP&lt;/h3&gt;
&lt;p&gt;MCP（Model Context Protocol，模型上下文协议）是一种开放标准，目的是增强 AI 与外部系统的交互能力。MCP 为 AI 提供了与外部工具、资源和服务交互的标准化方式，让 AI 能够访问最新数据、执行复杂操作，并与现有系统集成。&lt;/p&gt;
&lt;p&gt;调用MCP实现全网内容搜索：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;java&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;@Configuration
public class MCPConfig {
    @Value(&#34;${bigmodel.api-key}&#34;)
    private String apiKey;

    @Bean
    public McpToolProvider mcpToolProvider() {
        // 和 MCP 服务通讯 通过sse
        McpTransport transport = new HttpMcpTransport.Builder()
                .sseUrl(&#34;https://open.bigmodel.cn/api/mcp/web_search/sse?Authorization=&#34; + apiKey)
                .logRequests(true) // 开启日志，查看更多信息
                .logResponses(true)
                .build();
        // 创建 MCP 客户端
        McpClient mcpClient = new DefaultMcpClient.Builder()
                .key(&#34;yupiMcpClient&#34;)
                .transport(transport)
                .build();
        // 从 MCP 客户端获取工具
        McpToolProvider toolProvider = McpToolProvider.builder()
                .mcpClients(mcpClient)
                .build();
        return toolProvider;
    }
}
&lt;/pre&gt;
&lt;p&gt;然后在service中添加工具调用即可&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;java&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;AiCodeService aiCodeHelperService = AiServices.builder(AiCodeService.class)
                .chatModel(qwenChatModel)
                .chatMemory(chatMemory) // 提供会话记忆功能
                .contentRetriever(contentRetriever) // 提供内容检索器 RAG检索增强生成
                .tools(new InterviewQuestionTool() )    // 工具调用
                .toolProvider(mcpToolProvider) // MCP 工具调用
                .build();&lt;/pre&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;护轨-guardrail&#34;&gt;&lt;strong&gt;护轨 Guardrail&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;把它理解为拦截器就好了。分为输入护轨（input guardrails）和输出护轨（output guardrails），可以在请求 AI 前和接收到 AI 的响应后执行一些额外操作，比如调用 AI 前鉴权、调用 AI 后记录日志。&lt;/p&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;sse-流式接口开发&#34;&gt;&lt;strong&gt;SSE 流式接口开发&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;我们平时开发的大多数接口都是同步接口，也就是等后端处理完再返回。但是对于 AI 应用，特别是响应时间较长的对话类应用，可能会让用户失去耐心等待，因此推荐使用 SSE（Server-Sent Events）技术实现实时流式输出，类似打字机效果，大幅提升用户体验。&lt;/p&gt;
&lt;p&gt;注意，&lt;strong&gt;流式响应不支持结构化输出&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;使用 Flux 代替 TokenStream，让 AI 对话方法返回 Flux 响应式对象即可。&lt;/p&gt;
&lt;p&gt;service接口中实现：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;java&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;   @SystemMessage(fromResource = &#34;system-prompt.txt&#34;)
    Flux&amp;lt;String&gt; chatStream(@MemoryId int memoryId, @UserMessage String userMessage);&lt;/pre&gt;
&lt;p&gt;serviceFactory中添加：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;java&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;AiCodeHelperService aiCodeHelperService = AiServices.builder(AiCodeHelperService.class)
        .chatModel(myQwenChatModel)
        .streamingChatModel(qwenStreamingChatModel)&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;项目难点的点&#34;&gt;项目难点的点&lt;/h2&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;一些零碎知识&#34;&gt;一些零碎知识&lt;/h3&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    @Service注解：&lt;br /&gt;&lt;code&gt;@Service&lt;/code&gt;注解的作用是标记一个类是“业务逻辑层”（Service层）的组件，并告诉Spring：“请创建这个类的实例并放入你的容器中，以便在需要的地方自动注入”。本质是&lt;code&gt;@Component&lt;/code&gt;注解的​&lt;strong&gt;​特化​&lt;/strong&gt;​，用于自动扫描和装配，默认情况下&lt;code&gt;@Service&lt;/code&gt;和&lt;code&gt;@Component&lt;/code&gt;行为一样。
  &lt;/li&gt;
  &lt;li&gt;
    .text和.toString方法区别：&lt;br /&gt;在Jsoup中，.text()方法能够提取HTML中的纯文本内容（去除掉&lt;h1&gt;、&lt;p&gt;这类标签），.toString()方法会把这些HTML源码一起获取下来。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;部署过程的问题&#34;&gt;部署过程的问题&lt;/h3&gt;
&lt;h4 class=&#34;wp-block-heading&#34; id=&#34;1rag资源路径问题&#34;&gt;1.RAG资源路径问题&lt;/h4&gt;
&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code&gt;Caused by: java.lang.IllegalArgumentException: &#39;src/main/resources/docs&#39; is not a directory&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码（在 &lt;code&gt;RAGConfig&lt;/code&gt; 类中）试图从路径 &lt;code&gt;src/main/resources/docs&lt;/code&gt; 加载文档，但在&lt;strong&gt;云服务器的运行环境中&lt;/strong&gt;，这个路径&lt;strong&gt;不存在或者不是一个目录&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;原因是，&lt;strong&gt;本地开发时&lt;/strong&gt;：&lt;code&gt;src/main/resources/docs&lt;/code&gt; 是项目源代码里的一个目录，Maven 会将其打包进 JAR 文件，&lt;strong&gt;云服务器运行时&lt;/strong&gt;：JAR 包内的文件结构是&lt;strong&gt;只读的&lt;/strong&gt;，并且路径不再是文件系统路径。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将文档目录外置&lt;/strong&gt;，然后用&lt;code&gt;@Value(&amp;quot;${app.rag.docs-path}&amp;quot;)&lt;/code&gt;直接配置项目的RAG路径。&lt;/p&gt;
&lt;h4 class=&#34;wp-block-heading&#34; id=&#34;2跨域&#34;&gt;2.跨域&lt;/h4&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;   public void addCorsMappings(CorsRegistry registry){
        // 覆盖所有请求
        registry.addMapping(&#34;/**&#34;)
                // 允许发送 Cookie
                .allowCredentials(true)
                // 放行哪些域名
                .allowedOriginPatterns(&#34;*&#34;)
                .allowedMethods(&#34;GET&#34;,&#34;POST&#34;,&#34;PUT&#34;,&#34;DELETE&#34;,&#34;OPTIONS&#34;)
                .allowedHeaders(&#34;*&#34;)
                .exposedHeaders(&#34;*&#34;);
    }&lt;/pre&gt;
&lt;p&gt;在后端部署到服务器上，前端仍在本机上调用调试的时候，使用.&lt;code&gt;allowedOriginPatterns(&amp;quot;*&amp;quot;)&lt;/code&gt;时候，有跨域问题，改一下：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;               .allowedOriginPatterns(
                        &#34;http://localhost:3000&#34;,
                        &#34;http://127.0.0.1:3000&#34;,
                        &#34;http://117.72.66.48:3000&#34;,
                        &#34;https://117.72.66.48:3000&#34;,
                        &#34;https://yuyuyuyi1.xyz:300&#34;
                )&lt;/pre&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;项目部署&#34;&gt;项目部署&lt;/h2&gt;
&lt;p&gt;前端：进入ai-code-helper-frontend目录，命令行中：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;npm install
npm run dev&lt;/pre&gt;
&lt;p&gt;后端：默认启用8081接口。&lt;/p&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;项目环境&#34;&gt;项目环境&lt;/h3&gt;
&lt;p&gt;云服务器：&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    京东云 CPU 2核 内存 2GB
  &lt;/li&gt;
  &lt;li&gt;
    京东云服务器是直接使用WordPress-6.0.1应用镜像创建的，其Linux系统为CentOS7
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;**该项目需要使用JDK21。**安装方式：&lt;a href=&#34;https://www.jianshu.com/p/bba5d12389ff&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;阿里云 CentOS 7.6 / 7.9 yum 安装 Oracle JDK 21 – 简书&lt;/a&gt;&lt;/p&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;前端部署&#34;&gt;前端部署&lt;/h3&gt;
&lt;p&gt;前端命令行：&lt;code&gt;npm run build&lt;/code&gt;，上传dist文件到服务器。 创建&lt;code&gt;/etc/nginx/conf.d/vue-app.conf&lt;/code&gt;，配置nginx：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;# 前端 Vue 应用服务器配置
server {
    listen 3000;                # 前端访问端口
    server_name ;   # 服务器IP
    root ;           # Vue dist 文件的实际路径
    index index.html;
​
    # 错误页面配置
    error_page 404 /index.html;
    error_page 500 502 503 504 /50x.html;
​
    # 前端静态文件服务 - 处理 Vue Router 的路由
    location / {
        try_files $uri $uri/ /index.html;
        add_header Cache-Control &#34;no-cache, no-store, must-revalidate&#34;;
        add_header X-Frame-Options &#34;SAMEORIGIN&#34;;
        add_header X-Content-Type-Options &#34;nosniff&#34;;
    }
​
    # 静态资源缓存配置
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
        expires 1y;
        add_header Cache-Control &#34;public, immutable&#34;;
        try_files $uri =404;
    }
​
    # API 代理配置 - 将前端的/api请求转发到后端8081端口
    location /api/ {
        # 代理到后端Spring Boot
        proxy_pass http://117.72.66.48:8081/api/;
        
        # 传递必要的头信息
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # CORS 头
        add_header Access-Control-Allow-Origin $http_origin always;
        add_header Access-Control-Allow-Credentials true always;
        add_header Access-Control-Allow-Methods &#39;GET, POST, PUT, DELETE, OPTIONS&#39; always;
        add_header Access-Control-Allow-Headers &#39;*&#39; always;
        
        # 处理 OPTIONS 预检请求
        if ($request_method = &#39;OPTIONS&#39;) {
            add_header Access-Control-Allow-Origin $http_origin;
            add_header Access-Control-Allow-Methods &#39;GET, POST, PUT, DELETE, OPTIONS&#39;;
            add_header Access-Control-Allow-Headers &#39;*&#39;;
            add_header Access-Control-Max-Age 1728000;
            add_header Content-Type &#39;text/plain; charset=utf-8&#39;;
            add_header Content-Length 0;
            return 204;
        }
    }
​
    # 安全头
    add_header X-XSS-Protection &#34;1; mode=block&#34;;
    add_header Strict-Transport-Security &#34;max-age=31536000; includeSubDomains&#34; always;
}&lt;/pre&gt;
&lt;p&gt;设置文件权限：&lt;/p&gt;
&lt;pre class=&#34;EnlighterJSRAW&#34; data-enlighter-language=&#34;generic&#34; data-enlighter-theme=&#34;&#34; data-enlighter-highlight=&#34;&#34; data-enlighter-linenumbers=&#34;&#34; data-enlighter-lineoffset=&#34;&#34; data-enlighter-title=&#34;&#34; data-enlighter-group=&#34;&#34;&gt;# 设置正确的文件权限
chown -R nginx:nginx /AIbot/dist/
chmod -R 755 /AIbot/dist/
​
# 检查权限
ls -la /AIbot/dist/&lt;/pre&gt;
&lt;p&gt;重启Nginx：&lt;code&gt;systemctl restart nginx&lt;/code&gt;&lt;/p&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;后端部署&#34;&gt;后端部署&lt;/h3&gt;
&lt;p&gt;打包SpringBoot项目，打包后的结果是一个/target/下的jar包。&lt;/p&gt;
&lt;p&gt;后台运行：&lt;code&gt;nohup java -jar your-app.jar &amp;gt; app.log 2&amp;gt;&amp;amp;1 &amp;amp;&lt;/code&gt;&lt;/p&gt;

                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/07/aboutme/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/07/aboutme/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/" term="项目学习" label="项目学习" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E9%A1%B9%E7%9B%AE/" term="项目" label="项目" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
无线路由协议学习</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/06/%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/06/%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2025-05-06T08:30:49&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;h2 class=&#34;wp-block-heading.has-large-font-size&#34; id=&#34;概览&#34;&gt;&lt;strong&gt;概览&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://bbs.huaweicloud.com/blogs/399479&#34;&gt;这七种常见的路由协议，每一个网络工程师都应该知道！-云社区-华为云&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;无线路由协议，通常可以从&lt;strong&gt;工作方式&lt;/strong&gt;和&lt;strong&gt;算法类型&lt;/strong&gt;两个维度进行分类：&lt;/p&gt;
&lt;ol class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    &lt;strong&gt;按工作方式分类&lt;/strong&gt; &lt;ul class=&#34;wp-block-list&#34;&gt;
      &lt;li&gt;
        &lt;strong&gt;主动式（Proactive / Table-Driven）&lt;/strong&gt;：每个节点&lt;strong&gt;主动维护完整的路由表&lt;/strong&gt;，定期更新路由信息（即使没有通信需求）低延迟，高开销，RIP\OLSR\BGP
      &lt;/li&gt;
      &lt;li&gt;
        &lt;strong&gt;反应式（Reactive / On-Demand）&lt;/strong&gt;：&lt;strong&gt;按需发现路由&lt;/strong&gt;，仅在需要通信时启动路由发现过程。低开销，高延迟，DSR\AODV
      &lt;/li&gt;
      &lt;li&gt;
        &lt;strong&gt;混合式（Hybrid）&lt;/strong&gt;（结合主动和反应式）
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;按算法类型分类&lt;/strong&gt; &lt;ul class=&#34;wp-block-list&#34;&gt;
      &lt;li&gt;
        &lt;strong&gt;距离向量（Distance Vector）&lt;/strong&gt;：每个节点维护到其他节点的&lt;strong&gt;距离&lt;/strong&gt;（如跳数、延迟）和&lt;strong&gt;下一跳信息&lt;/strong&gt;，通过邻居节点交换路由表
      &lt;/li&gt;
      &lt;li&gt;
        &lt;strong&gt;链路状态（Link State）&lt;/strong&gt;：每个节点收集全网的链路状态信息（如带宽、延迟），构建网络拓扑图，使用 &lt;strong&gt;Dijkstra 算法&lt;/strong&gt; 计算最短路径。
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;距离向量路由协议&#34;&gt;距离向量路由协议&lt;/h2&gt;
&lt;p&gt;常见：RIP，IGRP&lt;br&gt;
&lt;strong&gt;距离向量路由协议（Distance Vector Routing Protocols）&lt;/strong&gt;：&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/06/%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/06/%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;h2 class=&#34;wp-block-heading.has-large-font-size&#34; id=&#34;概览&#34;&gt;&lt;strong&gt;概览&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://bbs.huaweicloud.com/blogs/399479&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这七种常见的路由协议，每一个网络工程师都应该知道！-云社区-华为云&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;无线路由协议，通常可以从&lt;strong&gt;工作方式&lt;/strong&gt;和&lt;strong&gt;算法类型&lt;/strong&gt;两个维度进行分类：&lt;/p&gt;
&lt;ol class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    &lt;strong&gt;按工作方式分类&lt;/strong&gt; &lt;ul class=&#34;wp-block-list&#34;&gt;
      &lt;li&gt;
        &lt;strong&gt;主动式（Proactive / Table-Driven）&lt;/strong&gt;：每个节点&lt;strong&gt;主动维护完整的路由表&lt;/strong&gt;，定期更新路由信息（即使没有通信需求）低延迟，高开销，RIP\OLSR\BGP
      &lt;/li&gt;
      &lt;li&gt;
        &lt;strong&gt;反应式（Reactive / On-Demand）&lt;/strong&gt;：&lt;strong&gt;按需发现路由&lt;/strong&gt;，仅在需要通信时启动路由发现过程。低开销，高延迟，DSR\AODV
      &lt;/li&gt;
      &lt;li&gt;
        &lt;strong&gt;混合式（Hybrid）&lt;/strong&gt;（结合主动和反应式）
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;按算法类型分类&lt;/strong&gt; &lt;ul class=&#34;wp-block-list&#34;&gt;
      &lt;li&gt;
        &lt;strong&gt;距离向量（Distance Vector）&lt;/strong&gt;：每个节点维护到其他节点的&lt;strong&gt;距离&lt;/strong&gt;（如跳数、延迟）和&lt;strong&gt;下一跳信息&lt;/strong&gt;，通过邻居节点交换路由表
      &lt;/li&gt;
      &lt;li&gt;
        &lt;strong&gt;链路状态（Link State）&lt;/strong&gt;：每个节点收集全网的链路状态信息（如带宽、延迟），构建网络拓扑图，使用 &lt;strong&gt;Dijkstra 算法&lt;/strong&gt; 计算最短路径。
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;距离向量路由协议&#34;&gt;距离向量路由协议&lt;/h2&gt;
&lt;p&gt;常见：RIP，IGRP&lt;br&gt;
&lt;strong&gt;距离向量路由协议（Distance Vector Routing Protocols）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    &lt;strong&gt;工作原理&lt;/strong&gt;：每个路由器维护一个到所有其他路由器的距离（通常是跳数）表。路由器定期向其邻居节点发送这些信息，并从邻居接收信息更新自己的表。
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;信息传递&lt;/strong&gt;：&lt;strong&gt;距离向量协议只知道直接相连的邻居的状态，不具备全网链路的详细信息&lt;/strong&gt;。每个路由器只知道自己的邻居及其到其他节点的距离，通过邻居的更新逐步了解整个网络的状态。
  &lt;/li&gt;
  &lt;li&gt;
    优缺点： &lt;ul class=&#34;wp-block-list&#34;&gt;
      &lt;li&gt;
        优点：实现简单，所需资源较少。
      &lt;/li&gt;
      &lt;li&gt;
        缺点：&lt;strong&gt;收敛速度慢&lt;/strong&gt;，易产生路由环路（尤其是在拓扑变化时），对大规模网络不太适合。
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;链路状态路由协议&#34;&gt;链路状态路由协议&lt;/h2&gt;
&lt;p&gt;常见：OSPF，IS-IS&lt;br&gt;
&lt;strong&gt;链路状态路由协议（Link State Routing Protocols）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    &lt;strong&gt;工作原理&lt;/strong&gt;：每个路由器通过链路状态广告（Link State Advertisement, LSA）向全网广播自己与直接邻居的连接状态。所有路由器收集这些信息，并构建出整个网络的拓扑图。
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;信息传递&lt;/strong&gt;：链路状态协议可以获得全体链路的信息，允许每个路由器通过网络中所有节点的链路状态信息计算到其他节点的最优路径。使用Dijkstra算法等算法进行路径计算。
  &lt;/li&gt;
  &lt;li&gt;
    优缺点： &lt;ul class=&#34;wp-block-list&#34;&gt;
      &lt;li&gt;
        优点：收敛速度快，能够快速适应网络的拓扑变化，支持复杂的网络结构。
      &lt;/li&gt;
      &lt;li&gt;
        缺点：每个路由器需存储更多的信息，相对复杂，可能导致&lt;strong&gt;控制开销较大&lt;/strong&gt;。
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://yinxiu.in/2020/adhoc-olsr.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;🔬【Ad Hoc】OLSR 协议详解 (yinxiu.in)&lt;/a&gt;&lt;/p&gt;
&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;olsr协议学习&#34;&gt;OLSR协议学习&lt;/h2&gt;
&lt;p&gt;路由协议分类：&lt;a href=&#34;https://blog.csdn.net/qq_40950957/article/details/104856367&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;【Ad Hoc】壹 速览 Ad Hoc 网络_ad hoc网络-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;YouTube视频介绍OLSR：&lt;a href=&#34;https://www.youtube.com/watch?v=3V19nPxpMp8&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Optimized Link State Routing (OLSR) Mobile Adhoc Network Proactive Routing Protocol&lt;/a&gt;&lt;br&gt;
OLSR算法原理：&lt;a href=&#34;https://www.codewoody.com/posts/17082/#olsr&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OLSR 路由算法原理 | 治部少辅&lt;/a&gt;&lt;br&gt;
MPR的选择过程：&lt;a href=&#34;https://yinxiu.in/2020/adhoc-olsr.html#3olsr-%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%93%8D%E4%BD%9C&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;🔬【Ad Hoc】OLSR 协议详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;OLSR是Ad Hoc自组织网络的一种，Ad Hoc 网络采用分组交换机制，网络中的每个用户终端都建有路由器和主机两种功能。作为主机，终端可以运行各种面向用户的应用程序；作为路由器，终端需要运行相应的路由协议。&lt;br&gt;
&lt;strong&gt;OLSR本质上是一种链路状态协议的改进，传统的lsr协议包洪泛太严重了，olsr适用在移动和资源受限的情形下&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OLSR&lt;/strong&gt;通过&lt;strong&gt;定期交换链路状态信息来维持路由信息&lt;/strong&gt;（HELLO消息和TC消息）。每个节点保持一个完整的拓扑信息，因此&lt;strong&gt;控制信息的开销较大&lt;/strong&gt;。OLSR 是&lt;strong&gt;基于状态链接的表驱动路由协议&lt;/strong&gt;，&lt;strong&gt;虽然所有节点都会接收信息，但是只有很少的节点（被选为MPR的节点）有权利广播信息。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;协议过程&#34;&gt;&lt;strong&gt;协议过程&lt;/strong&gt;&lt;/h3&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    节点先互传hello包，感知自己的一跳邻居和两跳邻居节点。
  &lt;/li&gt;
  &lt;li&gt;
    通过感知到的信息，寻找他们的MPR（&lt;strong&gt;节点选择自己的部分相邻节点作为MPR集，只有MPR集才能广播消息&lt;/strong&gt;） &lt;ul class=&#34;wp-block-list&#34;&gt;
      &lt;li&gt;
        &lt;strong&gt;MPR 的选择主要分为两步（可以参考&lt;a href=&#34;https://yinxiu.in/2020/adhoc-olsr.html#3olsr-%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%93%8D%E4%BD%9C&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;🔬【Ad Hoc】OLSR 协议详解&lt;/a&gt;）：&lt;/strong&gt; &lt;ol class=&#34;wp-block-list&#34;&gt;
          &lt;li&gt;
            首先选择能够覆盖&lt;strong&gt;孤立两跳邻节点&lt;/strong&gt;的一跳邻节点。这里的孤立两跳邻节点是指仅通过一个邻节点同目标节点相连的两跳邻节点。
          &lt;/li&gt;
          &lt;li&gt;
            在余下的一跳邻节点中，按照覆盖二跳邻节点的数量从高到低依次选择，直到覆盖所有的两跳邻节点。
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    路由计算，用迪杰斯特拉算法计算路由。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结起来就是：邻居发现构建邻居表（基于hello包）&lt;strong&gt;——&lt;/strong&gt; MPR选举构建mpr表  &lt;strong&gt;——&lt;/strong&gt; 基于TC消息扩散建立拓扑表 &lt;strong&gt;——&lt;/strong&gt; 基于拓扑表建立路由表 &lt;strong&gt;——&lt;/strong&gt; 从路由表中取出最优路径，建立转发表。&lt;/p&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;olsrv2&#34;&gt;OLSRv2&lt;/h3&gt;
&lt;p&gt;RFC7181:&lt;a href=&#34;https://rfc2cn.com/rfc7181.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC7181 中文翻译 中文RFC RFC文档 RFC翻译 RFC中文版&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;OLSR路由协议总共拥有4种控制消息:&lt;strong&gt;HELLO消息、TC消息、MID消息(multiple interfacedeclaration,交换多接口声明)、HNA消息(host andnetwork association,主机和网络关联信息)&lt;/strong&gt;。而OLSRv2路由协议仅&lt;strong&gt;依靠两种基本类型的控制消息&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;(1) HELLO消息：OLSRv2协议的邻居发现过程使用HELLO消息。&lt;br&gt;
(2)TC消息:TC消息在网络中定期被传播使得每个节点都能够获得全网的变化状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OLSRv2经历的阶段和构建过程&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    邻居发现阶段，构造一跳邻居表和二跳邻居表。
  &lt;/li&gt;
  &lt;li&gt;
    MPR选择，基于一跳和二跳，构建出一个mpr表和mpr_Selector表，主要是确定哪些节点能发TC消息。
  &lt;/li&gt;
  &lt;li&gt;
    通过发TC，构造出拓扑表，每个点的拓扑表一开始不同，但是最后会收敛到同一张。
  &lt;/li&gt;
  &lt;li&gt;
    通过拓扑表，构造出路由表。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;邻居发现过程使用了Hello消息&lt;/strong&gt;，路由发现则使用另一种格式的消息：Topology Control消息。&lt;br&gt;
&lt;strong&gt;TC消息的作用是为节点建立起全局的路由信息。只有MPR节点才会转发TC消息&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;基于TC消息的交换，各个节点可以维护一个Topology Table（拓扑表），基于拓扑表节点可以计算出路由表&lt;/strong&gt;。&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    &lt;strong&gt;在 OLSRv2 协议中，只有对称链路才能用于路由计算&lt;/strong&gt;。
  &lt;/li&gt;
  &lt;li&gt;
    非对称链路或丢失的链路无法保证双向通信，因此不能用于转发数据包。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;. OLSRv2的核心改进（对比OLSRv1）&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    &lt;strong&gt;多接口支持&lt;/strong&gt;：每个接口独立维护邻居关系，可跨子网协作。
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;动态链路感知&lt;/strong&gt;：基于NHDP（Neighbor Discovery Protocol）实时探测链路状态。
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;路由度量扩展&lt;/strong&gt;：支持ETX（Expected Transmission Count）等链路质量指标。
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;MPR优化&lt;/strong&gt;：MPR（Multi-Point Relay）选择更灵活，支持多接口协同。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;exata中的olsrv2&#34;&gt;Exata中的OLSRv2&lt;/h3&gt;
&lt;div class=&#34;wp-block-image&#34;&gt;
  &lt;figure class=&#34;aligncenter size-full&#34;&gt;
  &lt;div class=&#39;fancybox-wrapper lazyload-container-unload&#39; data-fancybox=&#39;post-images&#39; href=&#39;http://117.72.66.48/wp-content/uploads/2025/05/image-2.png&#39;&gt;
    &lt;img class=&#34;lazyload lazyload-style-1&#34; src=&#34;data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+&#34;  loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;603&#34; height=&#34;421&#34; data-original=&#34;http://117.72.66.48/wp-content/uploads/2025/05/image-2.png&#34; src=&#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC&#34; alt=&#34;&#34; class=&#34;wp-image-267&#34;  sizes=&#34;auto, (max-width: 603px) 100vw, 603px&#34; /&gt;
  &lt;/div&gt;&lt;figcaption class=&#34;wp-element-caption&#34;&gt;EXata中的OLSRv2协议源码，涉及的表&lt;/figcaption&gt;&lt;/figure&gt;
&lt;/div&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    &lt;strong&gt;MPR selector set&lt;/strong&gt;：这个表记录选择当前节点作为 MPR 的邻居节点集合（只有当本地节点的MPR Selector Set&lt;strong&gt;非空&lt;/strong&gt;（即至少有一个邻居选择本地节点为MPR）时，本地节点才会生成并广播TC消息）。
  &lt;/li&gt;
  &lt;li&gt;
    mpr set：当前节点选择的邻居节点，用来转发TC。
  &lt;/li&gt;
  &lt;li&gt;
    neighbor set：这个表记录了某节点的所有的一跳邻节点。
  &lt;/li&gt;
  &lt;li&gt;
    Two-hop neighbor set：这个表记录了可通过一跳邻节点接触的节点。
  &lt;/li&gt;
  &lt;li&gt;
    relay set：中继表，记录两个点之间是否有中继关系。
  &lt;/li&gt;
  &lt;li&gt;
    forward set：转发表，添加转发条目以让接口转发。
  &lt;/li&gt;
  &lt;li&gt;
    topology set：拓扑表，由TC构建而来，用来构建路由表routing set。
  &lt;/li&gt;
  &lt;li&gt;
    associate neighbor set：邻居关联表，来记录多接口信息。
  &lt;/li&gt;
&lt;/ul&gt;

                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/06/%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2025/05/06/%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E7%A7%91%E7%A0%94/" term="科研" label="科研" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/" term="路由协议" label="路由协议" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">
学术论文搜集</title>
            <link rel="alternate" type="text/html" href="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2024/10/01/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%E6%90%9C%E9%9B%86/" />
            <id>https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2024/10/01/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%E6%90%9C%E9%9B%86/</id>
            <updated>2025-12-23T14:05:20&#43;00:00</updated>
            <published>2024-10-01T08:35:00&#43;00:00</published>
            <author>
                    <name>wangkunlin</name>
                    <uri>https://io-oi.me/</uri>
                    <email>wangkunlin2001@163.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">
                &lt;p&gt;收集一些学术论文，可能会用到。&lt;br&gt;
论文内容为无线路由协议、OLSR协议、仿真软件、卫星路由协议相关。&lt;/p&gt;
                
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2024/10/01/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%E6%90%9C%E9%9B%86/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2024/10/01/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%E6%90%9C%E9%9B%86/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
            </summary>
            
                <content type="html">
                    
&lt;p&gt;收集一些学术论文，可能会用到。&lt;br&gt;
论文内容为无线路由协议、OLSR协议、仿真软件、卫星路由协议相关。&lt;/p&gt;
&lt;h1 class=&#34;wp-block-heading&#34; id=&#34;olsr相关工作&#34;&gt;OLSR相关工作&lt;/h1&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    &lt;em&gt;Sinky H, Hamdaoui B. Implementation and performance measurement and analysis of OLSR protocol[C]//Proceedings of the 6th International Wireless Communications and Mobile Computing Conference. 2010: 286-290.&lt;/em&gt;&lt;strong&gt; &lt;/strong&gt;&lt;br /&gt;&lt;strong&gt;论文提出OLSR-ETT（预期传输时间），并对比了OLSR-ETX&lt;/strong&gt;。
  &lt;/li&gt;
  &lt;li&gt;
    &lt;em&gt;Kunavut K. Performance evaluation of ETX metric on OLSR in heterogeneous networks[C]//2013 13th International Symposium on Communications and Information Technologies (ISCIT). IEEE, 2013: 20-25&lt;/em&gt;.&lt;br /&gt;&lt;strong&gt;论文较为具体的说明了OLSR-ETX实现流程，并且有一些OLSR的度量相关工作可以引用。&lt;/strong&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;em&gt;王昊天.基于ETX度量的无线多跳网络路由研究与优化[D].大连理工大学,2015.&lt;/em&gt;&lt;strong&gt; &lt;/strong&gt;&lt;br /&gt;&lt;strong&gt;传统的ETX缺陷与优化&lt;/strong&gt;。
  &lt;/li&gt;
  &lt;li&gt;
    &lt;em&gt;Xie P. An enhanced OLSR routing protocol based on node link expiration time and residual energy in ocean FANETS[C]//2018 24th Asia-Pacific Conference on Communications (APCC). IEEE, 2018: 598-603.&lt;/em&gt;&lt;strong&gt; &lt;/strong&gt;&lt;br /&gt;&lt;strong&gt;改进的OLSR协议，关键思想是充分利用全球定位系统（GPS）信息来计算节点链路到期时间并考虑剩余能量&lt;/strong&gt;。
  &lt;/li&gt;
  &lt;li&gt;
    &lt;em&gt;向展鹏,李鉴,谢卫,等.OLSR路由协议MPR机制研究与改进[J].无线电通信技术,2025,51(02):321-331.&lt;/em&gt;&lt;br /&gt;&lt;strong&gt;传统MPR选择算法优化。&lt;/strong&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;em&gt;Wheeb A H, Nordin R, Samah A A, et al. Performance evaluation of standard and modified OLSR protocols for uncoordinated UAV ad-hoc networks in search and rescue environments[J]. Electronics, 2023, 12(6): 1334.&lt;/em&gt;&lt;br /&gt;&lt;strong&gt;对比了4种改良版OLSR算法，可以从里面找相关工作和参考文献。&lt;/strong&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;em&gt;许向阳,杨申铭.无人机自组网低时延改进OLSR协议[J].长江信息通信,2023,36(05):55-58.&lt;/em&gt;&lt;br /&gt;&lt;strong&gt;简单论文，改进OLSR的MPR。&lt;/strong&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;em&gt;Wheeb A H, Nordin R, Samah A A, et al. Topology-based routing protocols and mobility models for flying ad hoc networks: A contemporary review and future research directions[J]. Drones, 2021, 6(1): 9.&lt;/em&gt;&lt;br /&gt;&lt;strong&gt;无人机路由协议综述&lt;/strong&gt;。
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h1 class=&#34;wp-block-heading&#34; id=&#34;卫星网络相关工作&#34;&gt;卫星网络相关工作&lt;/h1&gt;
&lt;ul class=&#34;wp-block-list&#34;&gt;
  &lt;li&gt;
    &lt;em&gt;Han Z, Xu C, Zhao G, et al. Time-varying topology model for dynamic routing in LEO satellite constellation networks[J]. IEEE Transactions on Vehicular Technology, 2022, 72(3): 3440-3454.&lt;/em&gt; &lt;br /&gt;&lt;strong&gt;提出了一种新的低轨卫星网络时变拓扑模型，仿真用的是STK和EXata，可以参考他的仿真场景设置方法。&lt;/strong&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;em&gt;Kunavut K. Performance evaluation of ETX metric on OLSR in heterogeneous networks[C]//2013 13th International Symposium on Communications and Information Technologies (ISCIT). IEEE, 2013: 20-25.&lt;/em&gt;&lt;br /&gt;&lt;strong&gt;研究了ETX度量在异构网络负载和速度变化条件下的影响&lt;/strong&gt;，&lt;strong&gt;可以写相关工作&lt;/strong&gt;。
  &lt;/li&gt;
  &lt;li&gt;
    &lt;em&gt;黄昀辉.卫星网络智能传输研究[D].中国科学技术大学,2023.DOI:10.27517/d.cnki.gzkju.2023.000021.&lt;/em&gt; &lt;br /&gt;&lt;strong&gt;博士论文，可以在里面找相关工作和参考文献。&lt;/strong&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;em&gt;Han Z, Xu C, Zhao G, et al. Time-varying topology model for dynamic routing in LEO satellite constellation networks[J]. IEEE Transactions on Vehicular Technology, 2022, 72(3): 3440-3454.&lt;/em&gt; &lt;br /&gt;&lt;strong&gt;时变拓扑LEO模型，仿真器是STK+EXata。&lt;/strong&gt;
  &lt;/li&gt;
&lt;/ul&gt;
                    
&lt;blockquote&gt;
&lt;p&gt;阅读原文：&lt;a href=&#34;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2024/10/01/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%E6%90%9C%E9%9B%86/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/2024/10/01/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%E6%90%9C%E9%9B%86/&lt;/a&gt;&lt;br&gt;
博客公告：博客现已开通邮件订阅，欢迎&lt;a href=&#34;https://username.substack.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Substack 订阅&lt;/a&gt;支持我的创作！&lt;/p&gt;
&lt;/blockquote&gt;
                </content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E7%A7%91%E7%A0%94/" term="科研" label="科研" />
                            
                        
                            
                            
                            
                                <category scheme="https://yuyuyuyi12001.github.io/yuyuyuyi1.github.io/tags/%E8%AE%BA%E6%96%87/" term="论文" label="论文" />
                            
                        
                    
                
            
        </entry>
    
</feed>
